"""
Network Scanner Module
======================

Comprehensive network reconnaissance and scanning capabilities.
"""

import asyncio
import socket
import struct
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
import ipaddress

from rich.console import Console
from rich.table import Table

from ..config import get_settings
from .ports import PortScanner, ScanResult


console = Console()


@dataclass
class NetworkInfo:
    """Network information for a target"""
    target: str
    ip_addresses: List[str] = field(default_factory=list)
    hostnames: List[str] = field(default_factory=list)
    mx_records: List[str] = field(default_factory=list)
    ns_records: List[str] = field(default_factory=list)
    txt_records: List[str] = field(default_factory=list)
    asn_info: Dict[str, Any] = field(default_factory=dict)
    whois_info: Dict[str, Any] = field(default_factory=dict)
    geolocation: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "ip_addresses": self.ip_addresses,
            "hostnames": self.hostnames,
            "mx_records": self.mx_records,
            "ns_records": self.ns_records,
            "txt_records": self.txt_records,
            "asn_info": self.asn_info,
            "whois_info": self.whois_info,
            "geolocation": self.geolocation,
        }


@dataclass  
class NetworkScanResult:
    """Complete network scan result"""
    target: str
    network_info: NetworkInfo
    port_scan: Optional[ScanResult] = None
    traceroute: List[Dict[str, Any]] = field(default_factory=list)
    vulnerabilities: List[Dict[str, Any]] = field(default_factory=list)
    scan_time: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "network_info": self.network_info.to_dict(),
            "port_scan": self.port_scan.to_dict() if self.port_scan else None,
            "traceroute": self.traceroute,
            "vulnerabilities": self.vulnerabilities,
            "scan_time": self.scan_time.isoformat(),
        }


class NetworkScanner:
    """
    Comprehensive network scanner for reconnaissance
    
    Features:
    - DNS enumeration
    - Port scanning
    - Service detection
    - WHOIS lookup
    - Network mapping
    """
    
    def __init__(self):
        self.settings = get_settings()
        self.port_scanner = PortScanner()
    
    async def resolve_dns(self, target: str) -> NetworkInfo:
        """
        Perform comprehensive DNS resolution
        
        Args:
            target: Domain or hostname to resolve
            
        Returns:
            NetworkInfo with DNS records
        """
        import dns.resolver
        import dns.reversename
        
        info = NetworkInfo(target=target)
        
        console.print(f"[cyan]Resolving DNS for {target}...[/cyan]")
        
        resolver = dns.resolver.Resolver()
        resolver.timeout = self.settings.subdomain.timeout
        resolver.lifetime = self.settings.subdomain.timeout
        
        # A records
        try:
            answers = resolver.resolve(target, 'A')
            info.ip_addresses = [str(rdata) for rdata in answers]
            console.print(f"  [green]A records:[/green] {', '.join(info.ip_addresses)}")
        except Exception as e:
            console.print(f"  [dim]No A records found[/dim]")
        
        # AAAA records (IPv6)
        try:
            answers = resolver.resolve(target, 'AAAA')
            ipv6_addresses = [str(rdata) for rdata in answers]
            info.ip_addresses.extend(ipv6_addresses)
            console.print(f"  [green]AAAA records:[/green] {', '.join(ipv6_addresses)}")
        except Exception:
            pass
        
        # MX records
        try:
            answers = resolver.resolve(target, 'MX')
            info.mx_records = [str(rdata.exchange).rstrip('.') for rdata in answers]
            console.print(f"  [green]MX records:[/green] {', '.join(info.mx_records)}")
        except Exception:
            pass
        
        # NS records
        try:
            answers = resolver.resolve(target, 'NS')
            info.ns_records = [str(rdata).rstrip('.') for rdata in answers]
            console.print(f"  [green]NS records:[/green] {', '.join(info.ns_records)}")
        except Exception:
            pass
        
        # TXT records
        try:
            answers = resolver.resolve(target, 'TXT')
            info.txt_records = [str(rdata) for rdata in answers]
            for txt in info.txt_records[:3]:  # Show first 3
                console.print(f"  [green]TXT:[/green] {txt[:80]}...")
        except Exception:
            pass
        
        # Reverse DNS for primary IP
        if info.ip_addresses:
            try:
                rev_name = dns.reversename.from_address(info.ip_addresses[0])
                answers = resolver.resolve(rev_name, 'PTR')
                info.hostnames = [str(rdata).rstrip('.') for rdata in answers]
                console.print(f"  [green]PTR records:[/green] {', '.join(info.hostnames)}")
            except Exception:
                pass
        
        return info
    
    async def whois_lookup(self, target: str) -> Dict[str, Any]:
        """
        Perform WHOIS lookup
        
        Args:
            target: Domain to lookup
            
        Returns:
            WHOIS information dictionary
        """
        try:
            import whois
            
            console.print(f"[cyan]WHOIS lookup for {target}...[/cyan]")
            
            w = whois.whois(target)
            
            whois_info = {
                "domain_name": w.domain_name,
                "registrar": w.registrar,
                "creation_date": str(w.creation_date) if w.creation_date else None,
                "expiration_date": str(w.expiration_date) if w.expiration_date else None,
                "name_servers": w.name_servers if w.name_servers else [],
                "status": w.status if w.status else [],
                "emails": w.emails if w.emails else [],
                "organization": w.org,
                "country": w.country,
            }
            
            console.print(f"  [green]Registrar:[/green] {whois_info['registrar']}")
            console.print(f"  [green]Created:[/green] {whois_info['creation_date']}")
            console.print(f"  [green]Expires:[/green] {whois_info['expiration_date']}")
            
            return whois_info
            
        except Exception as e:
            console.print(f"  [yellow]WHOIS lookup failed: {str(e)}[/yellow]")
            return {}
    
    async def scan(
        self,
        target: str,
        port_scan: bool = True,
        port_range: str = "quick",
        dns_enum: bool = True,
        whois: bool = True
    ) -> NetworkScanResult:
        """
        Perform comprehensive network scan
        
        Args:
            target: Target host or domain
            port_scan: Perform port scanning
            port_range: Port range for scanning
            dns_enum: Perform DNS enumeration
            whois: Perform WHOIS lookup
            
        Returns:
            NetworkScanResult with all findings
        """
        console.print(f"\n[bold cyan]═══ Network Scan: {target} ═══[/bold cyan]\n")
        
        start_time = datetime.now()
        
        # DNS Resolution
        if dns_enum:
            network_info = await self.resolve_dns(target)
        else:
            network_info = NetworkInfo(target=target)
            try:
                network_info.ip_addresses = [socket.gethostbyname(target)]
            except Exception:
                pass
        
        # WHOIS Lookup
        if whois:
            network_info.whois_info = await self.whois_lookup(target)
        
        # Port Scanning
        port_result = None
        if port_scan:
            console.print(f"\n[cyan]Port Scanning...[/cyan]")
            port_result = await self.port_scanner.scan(target, ports=port_range)
        
        result = NetworkScanResult(
            target=target,
            network_info=network_info,
            port_scan=port_result,
            scan_time=start_time
        )
        
        # Display summary
        self._display_summary(result)
        
        return result
    
    def _display_summary(self, result: NetworkScanResult):
        """Display scan summary"""
        console.print(f"\n[bold cyan]═══ Scan Summary ═══[/bold cyan]")
        
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Category", style="cyan")
        table.add_column("Details", style="white")
        
        table.add_row("Target", result.target)
        table.add_row("IP Addresses", ", ".join(result.network_info.ip_addresses) or "N/A")
        table.add_row("Hostnames", ", ".join(result.network_info.hostnames) or "N/A")
        
        if result.port_scan:
            open_ports = [str(p.port) for p in result.port_scan.ports]
            table.add_row("Open Ports", ", ".join(open_ports) or "None")
        
        if result.network_info.whois_info:
            table.add_row("Registrar", result.network_info.whois_info.get("registrar", "N/A"))
            table.add_row("Organization", result.network_info.whois_info.get("organization", "N/A"))
        
        console.print(table)
    
    async def discover_hosts(
        self,
        network: str,
        ports: str = "22,80,443"
    ) -> List[Dict[str, Any]]:
        """
        Discover live hosts in a network range
        
        Args:
            network: Network in CIDR notation (e.g., 192.168.1.0/24)
            ports: Ports to check for liveness
            
        Returns:
            List of discovered hosts
        """
        console.print(f"[cyan]Discovering hosts in {network}...[/cyan]")
        
        try:
            net = ipaddress.ip_network(network, strict=False)
        except ValueError as e:
            console.print(f"[red]Invalid network: {e}[/red]")
            return []
        
        hosts = list(net.hosts())
        
        if len(hosts) > 256:
            console.print(f"[yellow]Warning: Large network ({len(hosts)} hosts)[/yellow]")
        
        discovered = []
        port_list = [int(p) for p in ports.split(",")]
        
        semaphore = asyncio.Semaphore(50)
        
        async def check_host(ip: str) -> Optional[Dict[str, Any]]:
            async with semaphore:
                for port in port_list:
                    try:
                        reader, writer = await asyncio.wait_for(
                            asyncio.open_connection(str(ip), port),
                            timeout=2.0
                        )
                        writer.close()
                        await writer.wait_closed()
                        return {"ip": str(ip), "port": port}
                    except Exception:
                        continue
                return None
        
        tasks = [check_host(str(ip)) for ip in hosts]
        results = await asyncio.gather(*tasks)
        
        discovered = [r for r in results if r is not None]
        
        console.print(f"[green]Discovered {len(discovered)} live hosts[/green]")
        
        return discovered
