"""
SSL/TLS Scanner Module
======================

Comprehensive SSL/TLS security analysis.
"""

import asyncio
import ssl
import socket
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum

from rich.console import Console
from rich.table import Table

from ..config import get_settings


console = Console()


class SSLGrade(Enum):
    """SSL security grade"""
    A_PLUS = "A+"
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    F = "F"


@dataclass
class CertificateInfo:
    """SSL Certificate information"""
    subject: Dict[str, str] = field(default_factory=dict)
    issuer: Dict[str, str] = field(default_factory=dict)
    serial_number: str = ""
    not_before: Optional[datetime] = None
    not_after: Optional[datetime] = None
    days_until_expiry: int = 0
    is_expired: bool = False
    is_self_signed: bool = False
    san: List[str] = field(default_factory=list)
    signature_algorithm: str = ""
    key_size: int = 0
    key_type: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "subject": self.subject,
            "issuer": self.issuer,
            "serial_number": self.serial_number,
            "not_before": self.not_before.isoformat() if self.not_before else None,
            "not_after": self.not_after.isoformat() if self.not_after else None,
            "days_until_expiry": self.days_until_expiry,
            "is_expired": self.is_expired,
            "is_self_signed": self.is_self_signed,
            "san": self.san,
            "signature_algorithm": self.signature_algorithm,
            "key_size": self.key_size,
            "key_type": self.key_type,
        }


@dataclass
class SSLVulnerability:
    """SSL/TLS vulnerability"""
    name: str
    severity: str
    description: str
    remediation: str
    cve: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "severity": self.severity,
            "description": self.description,
            "remediation": self.remediation,
            "cve": self.cve,
        }


@dataclass
class SSLScanResult:
    """Complete SSL scan result"""
    target: str
    port: int = 443
    certificate: Optional[CertificateInfo] = None
    protocols: Dict[str, bool] = field(default_factory=dict)
    cipher_suites: List[Dict[str, Any]] = field(default_factory=list)
    vulnerabilities: List[SSLVulnerability] = field(default_factory=list)
    grade: SSLGrade = SSLGrade.F
    supports_tls_1_3: bool = False
    supports_tls_1_2: bool = False
    has_weak_ciphers: bool = False
    scan_time: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "port": self.port,
            "certificate": self.certificate.to_dict() if self.certificate else None,
            "protocols": self.protocols,
            "cipher_suites": self.cipher_suites,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "grade": self.grade.value,
            "supports_tls_1_3": self.supports_tls_1_3,
            "supports_tls_1_2": self.supports_tls_1_2,
            "has_weak_ciphers": self.has_weak_ciphers,
            "scan_time": self.scan_time.isoformat(),
        }


class SSLScanner:
    """
    SSL/TLS Security Scanner
    
    Features:
    - Certificate analysis
    - Protocol version detection
    - Cipher suite enumeration
    - Known vulnerability detection
    - Security grading
    """
    
    # Weak cipher patterns
    WEAK_CIPHERS = [
        "NULL", "EXPORT", "DES", "RC4", "RC2", "MD5",
        "ANON", "ADH", "EDH-RSA-DES", "3DES"
    ]
    
    # Strong cipher patterns
    STRONG_CIPHERS = [
        "ECDHE", "DHE", "AES-GCM", "AES256-GCM", "CHACHA20"
    ]
    
    def __init__(self, timeout: float = 15.0):
        self.settings = get_settings()
        self.timeout = timeout
    
    async def scan(
        self,
        target: str,
        port: int = 443
    ) -> SSLScanResult:
        """
        Perform comprehensive SSL/TLS scan
        
        Args:
            target: Target hostname
            port: Port to scan (default: 443)
            
        Returns:
            SSLScanResult with all findings
        """
        console.print(f"\n[bold cyan]═══ SSL/TLS Scan: {target}:{port} ═══[/bold cyan]\n")
        
        result = SSLScanResult(target=target, port=port)
        
        # Get certificate info
        console.print("[cyan]Analyzing certificate...[/cyan]")
        result.certificate = await self._get_certificate(target, port)
        
        if result.certificate:
            self._display_cert_info(result.certificate)
        else:
            console.print("[red]Failed to retrieve certificate[/red]")
            return result
        
        # Check protocols
        console.print("\n[cyan]Checking protocol versions...[/cyan]")
        result.protocols = await self._check_protocols(target, port)
        result.supports_tls_1_3 = result.protocols.get("TLS 1.3", False)
        result.supports_tls_1_2 = result.protocols.get("TLS 1.2", False)
        
        # Get cipher suites
        console.print("\n[cyan]Enumerating cipher suites...[/cyan]")
        result.cipher_suites = await self._get_cipher_suites(target, port)
        result.has_weak_ciphers = any(
            any(weak in c.get("name", "") for weak in self.WEAK_CIPHERS)
            for c in result.cipher_suites
        )
        
        # Check for vulnerabilities
        console.print("\n[cyan]Checking for vulnerabilities...[/cyan]")
        result.vulnerabilities = self._check_vulnerabilities(result)
        
        # Calculate grade
        result.grade = self._calculate_grade(result)
        
        # Display summary
        self._display_summary(result)
        
        return result
    
    async def _get_certificate(
        self,
        target: str,
        port: int
    ) -> Optional[CertificateInfo]:
        """Get and parse SSL certificate"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            loop = asyncio.get_event_loop()
            
            def get_cert():
                with socket.create_connection((target, port), timeout=self.timeout) as sock:
                    with context.wrap_socket(sock, server_hostname=target) as ssock:
                        cert = ssock.getpeercert(binary_form=True)
                        cipher = ssock.cipher()
                        version = ssock.version()
                        
                        # Parse with cryptography
                        from cryptography import x509
                        from cryptography.hazmat.primitives import hashes
                        from cryptography.hazmat.primitives.asymmetric import rsa, ec
                        
                        cert_obj = x509.load_der_x509_certificate(cert)
                        
                        # Extract subject
                        subject = {}
                        for attr in cert_obj.subject:
                            subject[attr.oid._name] = attr.value
                        
                        # Extract issuer
                        issuer = {}
                        for attr in cert_obj.issuer:
                            issuer[attr.oid._name] = attr.value
                        
                        # Check if self-signed
                        is_self_signed = (
                            cert_obj.subject == cert_obj.issuer
                        )
                        
                        # Get SAN
                        san = []
                        try:
                            ext = cert_obj.extensions.get_extension_for_class(
                                x509.SubjectAlternativeName
                            )
                            san = [str(name.value) for name in ext.value]
                        except x509.ExtensionNotFound:
                            pass
                        
                        # Get key info
                        pub_key = cert_obj.public_key()
                        key_size = pub_key.key_size
                        key_type = "RSA" if isinstance(pub_key, rsa.RSAPublicKey) else "EC"
                        
                        # Calculate expiry
                        now = datetime.now(timezone.utc)
                        not_after = cert_obj.not_valid_after_utc
                        days_until_expiry = (not_after - now).days
                        
                        return CertificateInfo(
                            subject=subject,
                            issuer=issuer,
                            serial_number=str(cert_obj.serial_number),
                            not_before=cert_obj.not_valid_before_utc,
                            not_after=not_after,
                            days_until_expiry=days_until_expiry,
                            is_expired=days_until_expiry < 0,
                            is_self_signed=is_self_signed,
                            san=san,
                            signature_algorithm=cert_obj.signature_algorithm_oid._name,
                            key_size=key_size,
                            key_type=key_type,
                        )
            
            return await loop.run_in_executor(None, get_cert)
            
        except Exception as e:
            console.print(f"[red]Certificate error: {str(e)}[/red]")
            return None
    
    async def _check_protocols(
        self,
        target: str,
        port: int
    ) -> Dict[str, bool]:
        """Check supported SSL/TLS protocols"""
        protocols = {
            "SSL 2.0": False,
            "SSL 3.0": False,
            "TLS 1.0": False,
            "TLS 1.1": False,
            "TLS 1.2": False,
            "TLS 1.3": False,
        }
        
        protocol_map = {
            "TLS 1.0": ssl.TLSVersion.TLSv1,
            "TLS 1.1": ssl.TLSVersion.TLSv1_1,
            "TLS 1.2": ssl.TLSVersion.TLSv1_2,
            "TLS 1.3": ssl.TLSVersion.TLSv1_3,
        }
        
        for proto_name, proto_version in protocol_map.items():
            try:
                context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                context.minimum_version = proto_version
                context.maximum_version = proto_version
                
                loop = asyncio.get_event_loop()
                
                def test_protocol():
                    try:
                        with socket.create_connection((target, port), timeout=5) as sock:
                            with context.wrap_socket(sock, server_hostname=target) as ssock:
                                return True
                    except Exception:
                        return False
                
                protocols[proto_name] = await loop.run_in_executor(None, test_protocol)
                
                status = "[green]✓[/green]" if protocols[proto_name] else "[dim]✗[/dim]"
                color = "green" if proto_name in ["TLS 1.2", "TLS 1.3"] else (
                    "red" if protocols[proto_name] else "dim"
                )
                console.print(f"  {status} {proto_name}")
                
            except Exception:
                pass
        
        return protocols
    
    async def _get_cipher_suites(
        self,
        target: str,
        port: int
    ) -> List[Dict[str, Any]]:
        """Get supported cipher suites"""
        suites = []
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            loop = asyncio.get_event_loop()
            
            def get_ciphers():
                ciphers = []
                try:
                    with socket.create_connection((target, port), timeout=self.timeout) as sock:
                        with context.wrap_socket(sock, server_hostname=target) as ssock:
                            cipher = ssock.cipher()
                            if cipher:
                                ciphers.append({
                                    "name": cipher[0],
                                    "protocol": cipher[1],
                                    "bits": cipher[2],
                                })
                except Exception:
                    pass
                return ciphers
            
            suites = await loop.run_in_executor(None, get_ciphers)
            
            # Display cipher info
            for suite in suites:
                is_weak = any(w in suite["name"] for w in self.WEAK_CIPHERS)
                color = "red" if is_weak else "green"
                console.print(
                    f"  [{color}]•[/{color}] {suite['name']} ({suite['bits']} bits)"
                )
                
        except Exception as e:
            console.print(f"[yellow]Cipher enumeration limited: {str(e)}[/yellow]")
        
        return suites
    
    def _check_vulnerabilities(self, result: SSLScanResult) -> List[SSLVulnerability]:
        """Check for known SSL/TLS vulnerabilities"""
        vulns = []
        
        # Check certificate issues
        if result.certificate:
            cert = result.certificate
            
            # Expired certificate
            if cert.is_expired:
                vulns.append(SSLVulnerability(
                    name="Expired Certificate",
                    severity="high",
                    description="The SSL certificate has expired",
                    remediation="Renew the SSL certificate immediately"
                ))
                console.print("  [red]✗[/red] Certificate expired!")
            
            # Soon to expire
            elif cert.days_until_expiry < 30:
                vulns.append(SSLVulnerability(
                    name="Certificate Expiring Soon",
                    severity="medium",
                    description=f"Certificate expires in {cert.days_until_expiry} days",
                    remediation="Plan to renew the certificate before expiration"
                ))
                console.print(f"  [yellow]⚠[/yellow] Certificate expires in {cert.days_until_expiry} days")
            
            # Self-signed
            if cert.is_self_signed:
                vulns.append(SSLVulnerability(
                    name="Self-Signed Certificate",
                    severity="medium",
                    description="The certificate is self-signed and not trusted by browsers",
                    remediation="Use a certificate from a trusted Certificate Authority"
                ))
                console.print("  [yellow]⚠[/yellow] Self-signed certificate")
            
            # Weak key size
            if cert.key_size < 2048:
                vulns.append(SSLVulnerability(
                    name="Weak Key Size",
                    severity="high",
                    description=f"RSA key size is only {cert.key_size} bits",
                    remediation="Use at least 2048-bit RSA keys or 256-bit ECDSA"
                ))
                console.print(f"  [red]✗[/red] Weak key size: {cert.key_size} bits")
            
            # Weak signature
            if "sha1" in cert.signature_algorithm.lower():
                vulns.append(SSLVulnerability(
                    name="SHA-1 Signature",
                    severity="medium",
                    description="Certificate uses deprecated SHA-1 signature algorithm",
                    remediation="Use SHA-256 or stronger signature algorithm"
                ))
                console.print("  [yellow]⚠[/yellow] SHA-1 signature algorithm")
        
        # Protocol vulnerabilities
        if result.protocols.get("SSL 2.0", False):
            vulns.append(SSLVulnerability(
                name="SSL 2.0 Enabled",
                severity="critical",
                description="SSLv2 is severely deprecated and vulnerable",
                remediation="Disable SSL 2.0 immediately",
                cve="Multiple"
            ))
        
        if result.protocols.get("SSL 3.0", False):
            vulns.append(SSLVulnerability(
                name="SSL 3.0 Enabled (POODLE)",
                severity="high",
                description="SSLv3 is vulnerable to POODLE attack",
                remediation="Disable SSL 3.0",
                cve="CVE-2014-3566"
            ))
        
        if result.protocols.get("TLS 1.0", False):
            vulns.append(SSLVulnerability(
                name="TLS 1.0 Enabled",
                severity="medium",
                description="TLS 1.0 is deprecated and has known weaknesses",
                remediation="Disable TLS 1.0 and use TLS 1.2 or higher",
                cve="Multiple"
            ))
            console.print("  [yellow]⚠[/yellow] TLS 1.0 enabled (deprecated)")
        
        if result.protocols.get("TLS 1.1", False):
            vulns.append(SSLVulnerability(
                name="TLS 1.1 Enabled",
                severity="low",
                description="TLS 1.1 is deprecated",
                remediation="Disable TLS 1.1 and use TLS 1.2 or higher"
            ))
            console.print("  [yellow]⚠[/yellow] TLS 1.1 enabled (deprecated)")
        
        if not result.protocols.get("TLS 1.2", False) and not result.protocols.get("TLS 1.3", False):
            vulns.append(SSLVulnerability(
                name="No Modern TLS Support",
                severity="critical",
                description="Server doesn't support TLS 1.2 or 1.3",
                remediation="Enable TLS 1.2 and TLS 1.3"
            ))
        
        # Weak ciphers
        if result.has_weak_ciphers:
            vulns.append(SSLVulnerability(
                name="Weak Cipher Suites",
                severity="medium",
                description="Server supports weak cipher suites",
                remediation="Disable weak ciphers (NULL, EXPORT, DES, RC4, MD5)"
            ))
            console.print("  [yellow]⚠[/yellow] Weak cipher suites enabled")
        
        return vulns
    
    def _calculate_grade(self, result: SSLScanResult) -> SSLGrade:
        """Calculate overall SSL security grade"""
        score = 100
        
        # Certificate issues
        if result.certificate:
            if result.certificate.is_expired:
                score -= 50
            elif result.certificate.days_until_expiry < 30:
                score -= 10
            if result.certificate.is_self_signed:
                score -= 20
            if result.certificate.key_size < 2048:
                score -= 30
            if "sha1" in result.certificate.signature_algorithm.lower():
                score -= 15
        else:
            score -= 50
        
        # Protocol issues
        if result.protocols.get("SSL 2.0", False):
            score -= 40
        if result.protocols.get("SSL 3.0", False):
            score -= 30
        if result.protocols.get("TLS 1.0", False):
            score -= 10
        if result.protocols.get("TLS 1.1", False):
            score -= 5
        if not result.supports_tls_1_3:
            score -= 5
        
        # Cipher issues
        if result.has_weak_ciphers:
            score -= 15
        
        # Vulnerability count
        critical = sum(1 for v in result.vulnerabilities if v.severity == "critical")
        high = sum(1 for v in result.vulnerabilities if v.severity == "high")
        
        score -= critical * 20
        score -= high * 10
        
        # Map score to grade
        if score >= 95:
            return SSLGrade.A_PLUS
        elif score >= 80:
            return SSLGrade.A
        elif score >= 65:
            return SSLGrade.B
        elif score >= 50:
            return SSLGrade.C
        elif score >= 35:
            return SSLGrade.D
        else:
            return SSLGrade.F
    
    def _display_cert_info(self, cert: CertificateInfo):
        """Display certificate information"""
        table = Table(show_header=False, box=None)
        table.add_column("Field", style="cyan")
        table.add_column("Value", style="white")
        
        table.add_row("Subject CN", cert.subject.get("commonName", "N/A"))
        table.add_row("Issuer", cert.issuer.get("commonName", "N/A"))
        table.add_row("Valid From", str(cert.not_before)[:10] if cert.not_before else "N/A")
        table.add_row("Valid Until", str(cert.not_after)[:10] if cert.not_after else "N/A")
        table.add_row("Days Left", str(cert.days_until_expiry))
        table.add_row("Key Type", f"{cert.key_type} {cert.key_size}-bit")
        table.add_row("Signature", cert.signature_algorithm)
        
        if cert.san:
            table.add_row("SANs", ", ".join(cert.san[:5]) + ("..." if len(cert.san) > 5 else ""))
        
        console.print(table)
    
    def _display_summary(self, result: SSLScanResult):
        """Display scan summary"""
        console.print(f"\n[bold cyan]═══ SSL/TLS Summary ═══[/bold cyan]")
        
        # Grade display with color
        grade_colors = {
            SSLGrade.A_PLUS: "green",
            SSLGrade.A: "green",
            SSLGrade.B: "yellow",
            SSLGrade.C: "yellow",
            SSLGrade.D: "orange1",
            SSLGrade.F: "red",
        }
        
        grade_color = grade_colors.get(result.grade, "white")
        console.print(f"\n[bold]Security Grade: [{grade_color}]{result.grade.value}[/{grade_color}][/bold]")
        
        # Summary table
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Check", style="cyan")
        table.add_column("Status", style="white")
        
        table.add_row(
            "TLS 1.3 Support",
            "[green]Yes[/green]" if result.supports_tls_1_3 else "[yellow]No[/yellow]"
        )
        table.add_row(
            "TLS 1.2 Support",
            "[green]Yes[/green]" if result.supports_tls_1_2 else "[red]No[/red]"
        )
        table.add_row(
            "Weak Ciphers",
            "[red]Yes[/red]" if result.has_weak_ciphers else "[green]No[/green]"
        )
        table.add_row(
            "Vulnerabilities",
            f"{len(result.vulnerabilities)} found"
        )
        
        console.print(table)
        
        # Show vulnerabilities
        if result.vulnerabilities:
            console.print("\n[bold red]Issues Found:[/bold red]")
            for v in result.vulnerabilities:
                severity_color = {
                    "critical": "red",
                    "high": "orange1",
                    "medium": "yellow",
                    "low": "green",
                }.get(v.severity, "white")
                
                console.print(
                    f"  [{severity_color}]•[/{severity_color}] "
                    f"[{severity_color}]{v.severity.upper()}[/{severity_color}] - {v.name}"
                )
