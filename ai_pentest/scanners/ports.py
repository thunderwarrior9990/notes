"""
Port Scanner Module
===================

Fast asynchronous port scanning for network reconnaissance.
"""

import asyncio
import socket
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

from rich.console import Console
from rich.progress import Progress, TaskID

from ..config import get_settings


console = Console()


class PortState(Enum):
    """Port state enumeration"""
    OPEN = "open"
    CLOSED = "closed"
    FILTERED = "filtered"


@dataclass
class PortResult:
    """Result of a port scan"""
    port: int
    state: PortState
    service: str = ""
    version: str = ""
    banner: str = ""


@dataclass
class ScanResult:
    """Complete scan result for a target"""
    target: str
    ip_address: str
    scan_time: datetime
    ports: List[PortResult] = field(default_factory=list)
    hostname: str = ""
    os_guess: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "target": self.target,
            "ip_address": self.ip_address,
            "hostname": self.hostname,
            "scan_time": self.scan_time.isoformat(),
            "os_guess": self.os_guess,
            "ports": [
                {
                    "port": p.port,
                    "state": p.state.value,
                    "service": p.service,
                    "version": p.version,
                    "banner": p.banner
                }
                for p in self.ports
            ],
            "open_ports_count": len([p for p in self.ports if p.state == PortState.OPEN])
        }


class PortScanner:
    """
    Asynchronous port scanner for network reconnaissance
    
    Features:
    - Fast concurrent scanning
    - Service detection
    - Banner grabbing
    - Common service identification
    """
    
    # Common ports and their typical services
    COMMON_SERVICES = {
        21: "ftp",
        22: "ssh",
        23: "telnet",
        25: "smtp",
        53: "dns",
        80: "http",
        110: "pop3",
        111: "rpcbind",
        135: "msrpc",
        139: "netbios-ssn",
        143: "imap",
        443: "https",
        445: "microsoft-ds",
        993: "imaps",
        995: "pop3s",
        1433: "mssql",
        1521: "oracle",
        3306: "mysql",
        3389: "rdp",
        5432: "postgresql",
        5900: "vnc",
        6379: "redis",
        8080: "http-proxy",
        8443: "https-alt",
        27017: "mongodb",
    }
    
    def __init__(
        self,
        timeout: float = 2.0,
        max_concurrent: int = 100,
        grab_banners: bool = True
    ):
        self.settings = get_settings()
        self.timeout = timeout
        self.max_concurrent = min(max_concurrent, self.settings.network.max_concurrent)
        self.grab_banners = grab_banners
        self._semaphore: Optional[asyncio.Semaphore] = None
    
    def _parse_port_range(self, port_spec: str) -> List[int]:
        """Parse port specification into list of ports"""
        ports = []
        for part in port_spec.split(","):
            part = part.strip()
            if "-" in part:
                start, end = part.split("-")
                ports.extend(range(int(start), int(end) + 1))
            else:
                ports.append(int(part))
        return sorted(set(ports))
    
    async def _resolve_host(self, target: str) -> Tuple[str, str]:
        """Resolve hostname to IP address"""
        try:
            ip = socket.gethostbyname(target)
            try:
                hostname = socket.gethostbyaddr(ip)[0]
            except socket.herror:
                hostname = target
            return ip, hostname
        except socket.gaierror:
            return target, target
    
    async def _check_port(self, host: str, port: int) -> PortResult:
        """Check if a single port is open"""
        async with self._semaphore:
            try:
                # Attempt connection
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port),
                    timeout=self.timeout
                )
                
                # Get service name
                service = self.COMMON_SERVICES.get(port, "unknown")
                banner = ""
                
                # Attempt banner grab
                if self.grab_banners:
                    try:
                        # Send probe for some services
                        if port in [80, 8080, 8443]:
                            writer.write(b"HEAD / HTTP/1.0\r\n\r\n")
                        elif port == 22:
                            pass  # SSH sends banner automatically
                        else:
                            writer.write(b"\r\n")
                        
                        await writer.drain()
                        
                        # Read response
                        banner_data = await asyncio.wait_for(
                            reader.read(1024),
                            timeout=2.0
                        )
                        banner = banner_data.decode("utf-8", errors="ignore").strip()[:200]
                        
                        # Try to identify service from banner
                        if not service or service == "unknown":
                            service = self._identify_service(banner, port)
                            
                    except (asyncio.TimeoutError, Exception):
                        pass
                
                writer.close()
                await writer.wait_closed()
                
                return PortResult(
                    port=port,
                    state=PortState.OPEN,
                    service=service,
                    banner=banner
                )
                
            except asyncio.TimeoutError:
                return PortResult(port=port, state=PortState.FILTERED)
            except ConnectionRefusedError:
                return PortResult(port=port, state=PortState.CLOSED)
            except Exception:
                return PortResult(port=port, state=PortState.FILTERED)
    
    def _identify_service(self, banner: str, port: int) -> str:
        """Identify service from banner"""
        banner_lower = banner.lower()
        
        if "ssh" in banner_lower:
            return "ssh"
        elif "http" in banner_lower:
            return "http"
        elif "ftp" in banner_lower:
            return "ftp"
        elif "smtp" in banner_lower:
            return "smtp"
        elif "mysql" in banner_lower:
            return "mysql"
        elif "postgresql" in banner_lower:
            return "postgresql"
        elif "redis" in banner_lower:
            return "redis"
        elif "mongodb" in banner_lower:
            return "mongodb"
        elif "apache" in banner_lower:
            return "http-apache"
        elif "nginx" in banner_lower:
            return "http-nginx"
        elif "microsoft" in banner_lower or "iis" in banner_lower:
            return "http-iis"
        
        return self.COMMON_SERVICES.get(port, "unknown")
    
    async def scan(
        self,
        target: str,
        ports: str = "quick",
        show_progress: bool = True
    ) -> ScanResult:
        """
        Scan target for open ports
        
        Args:
            target: Host to scan (IP or hostname)
            ports: Port specification ("quick", "common", "full", or custom like "80,443,8080")
            show_progress: Show progress bar
        
        Returns:
            ScanResult with discovered ports
        """
        # Parse ports
        if ports == "quick":
            port_list = self._parse_port_range(self.settings.network.quick_ports)
        elif ports == "common":
            port_list = self._parse_port_range(self.settings.network.common_ports)
        elif ports == "full":
            port_list = self._parse_port_range(self.settings.network.full_ports)
        else:
            port_list = self._parse_port_range(ports)
        
        # Initialize semaphore
        self._semaphore = asyncio.Semaphore(self.max_concurrent)
        
        # Resolve host
        ip_address, hostname = await self._resolve_host(target)
        
        console.print(f"[cyan]Scanning {target} ({ip_address})[/cyan]")
        console.print(f"[dim]Ports to scan: {len(port_list)}[/dim]")
        
        start_time = datetime.now()
        open_ports = []
        
        if show_progress:
            with Progress() as progress:
                task = progress.add_task(
                    f"[cyan]Scanning ports...",
                    total=len(port_list)
                )
                
                # Scan in batches
                for i in range(0, len(port_list), self.max_concurrent):
                    batch = port_list[i:i + self.max_concurrent]
                    tasks = [self._check_port(ip_address, port) for port in batch]
                    results = await asyncio.gather(*tasks)
                    
                    for result in results:
                        if result.state == PortState.OPEN:
                            open_ports.append(result)
                            console.print(
                                f"  [green]âœ“[/green] Port {result.port}/{result.service} - OPEN"
                                + (f" [{result.banner[:50]}...]" if result.banner else "")
                            )
                    
                    progress.advance(task, len(batch))
        else:
            tasks = [self._check_port(ip_address, port) for port in port_list]
            results = await asyncio.gather(*tasks)
            open_ports = [r for r in results if r.state == PortState.OPEN]
        
        scan_result = ScanResult(
            target=target,
            ip_address=ip_address,
            hostname=hostname,
            scan_time=start_time,
            ports=open_ports
        )
        
        console.print(f"\n[green]Scan complete![/green] Found {len(open_ports)} open ports")
        
        return scan_result
    
    async def quick_scan(self, target: str) -> ScanResult:
        """Perform quick scan of common ports"""
        return await self.scan(target, ports="quick")
    
    async def full_scan(self, target: str) -> ScanResult:
        """Perform full port scan (1-65535)"""
        console.print("[yellow]Warning: Full scan may take a long time[/yellow]")
        return await self.scan(target, ports="full", show_progress=True)
