"""
Subdomain Enumeration Module
============================

Discover subdomains using multiple techniques.
"""

import asyncio
import socket
from typing import Dict, List, Optional, Set, Any
from dataclasses import dataclass, field
from datetime import datetime
import ssl
import re

import httpx
from rich.console import Console
from rich.progress import Progress

from ..config import get_settings


console = Console()


# Common subdomain wordlist
DEFAULT_WORDLIST = [
    "www", "mail", "ftp", "localhost", "webmail", "smtp", "pop", "ns1", "ns2",
    "webdisk", "ns", "cpanel", "whm", "autodiscover", "autoconfig", "m", "imap",
    "test", "ns3", "blog", "pop3", "dev", "www2", "admin", "forum", "news",
    "vpn", "ns4", "www1", "mobile", "ssl", "shop", "ftp2", "api", "staging",
    "cdn", "stats", "cloud", "secure", "demo", "cp", "calendar", "wiki", "web",
    "media", "email", "images", "img", "www3", "support", "home", "video",
    "ads", "host", "mx", "mx1", "mx2", "mail2", "mail3", "pda", "remote",
    "server", "server1", "server2", "ns5", "ns6", "ns7", "ns8", "ns9", "ns10",
    "db", "dns", "dns1", "dns2", "wap", "intranet", "extranet", "gateway",
    "old", "new", "beta", "alpha", "stage", "staging2", "dev2", "uat",
    "qa", "test2", "sandbox", "portal", "app", "apps", "static", "assets",
    "git", "gitlab", "jenkins", "ci", "cd", "build", "deploy", "docker",
    "k8s", "kubernetes", "status", "health", "monitoring", "grafana", "prometheus",
    "elastic", "kibana", "logstash", "redis", "mysql", "postgres", "mongodb",
    "backup", "bak", "archive", "tmp", "temp", "files", "downloads", "uploads",
    "internal", "private", "public", "external", "partner", "client", "customer",
    "sso", "auth", "login", "oauth", "api-gateway", "graphql", "rest", "ws",
    "socket", "realtime", "chat", "messaging", "notification", "push",
    "payment", "billing", "invoice", "order", "cart", "checkout", "store",
    "docs", "documentation", "help", "faq", "kb", "knowledge", "learn",
    "crm", "erp", "hr", "sales", "marketing", "analytics", "reports",
]


@dataclass
class SubdomainResult:
    """Result for a discovered subdomain"""
    subdomain: str
    ip_addresses: List[str] = field(default_factory=list)
    is_alive: bool = False
    http_status: Optional[int] = None
    https_status: Optional[int] = None
    title: str = ""
    server: str = ""
    technologies: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "subdomain": self.subdomain,
            "ip_addresses": self.ip_addresses,
            "is_alive": self.is_alive,
            "http_status": self.http_status,
            "https_status": self.https_status,
            "title": self.title,
            "server": self.server,
            "technologies": self.technologies,
        }


@dataclass
class EnumerationResult:
    """Complete enumeration result"""
    domain: str
    subdomains: List[SubdomainResult] = field(default_factory=list)
    total_found: int = 0
    alive_count: int = 0
    scan_time: datetime = field(default_factory=datetime.now)
    methods_used: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "domain": self.domain,
            "subdomains": [s.to_dict() for s in self.subdomains],
            "total_found": self.total_found,
            "alive_count": self.alive_count,
            "scan_time": self.scan_time.isoformat(),
            "methods_used": self.methods_used,
        }


class SubdomainEnumerator:
    """
    Subdomain enumeration using multiple techniques
    
    Methods:
    - DNS brute force
    - Certificate transparency logs
    - DNS zone transfer attempts
    - Common patterns
    """
    
    def __init__(
        self,
        wordlist: Optional[List[str]] = None,
        max_concurrent: int = 100
    ):
        self.settings = get_settings()
        self.wordlist = wordlist or DEFAULT_WORDLIST
        self.max_concurrent = min(max_concurrent, self.settings.subdomain.max_concurrent)
        self.resolvers = self.settings.subdomain.dns_resolvers
    
    async def enumerate(
        self,
        domain: str,
        bruteforce: bool = True,
        check_alive: bool = True,
        use_crt_sh: bool = True,
        custom_wordlist: Optional[List[str]] = None
    ) -> EnumerationResult:
        """
        Enumerate subdomains for a domain
        
        Args:
            domain: Target domain
            bruteforce: Use DNS bruteforce
            check_alive: Check if subdomains are alive
            use_crt_sh: Query certificate transparency logs
            custom_wordlist: Custom wordlist to use
            
        Returns:
            EnumerationResult with discovered subdomains
        """
        console.print(f"\n[bold cyan]═══ Subdomain Enumeration: {domain} ═══[/bold cyan]\n")
        
        discovered: Set[str] = set()
        methods_used = []
        
        # Certificate Transparency
        if use_crt_sh:
            console.print("[cyan]Querying Certificate Transparency logs...[/cyan]")
            crt_subdomains = await self._query_crt_sh(domain)
            discovered.update(crt_subdomains)
            methods_used.append("crt.sh")
            console.print(f"  [green]Found {len(crt_subdomains)} from CT logs[/green]")
        
        # DNS Bruteforce
        if bruteforce:
            console.print("[cyan]DNS Bruteforce...[/cyan]")
            wordlist = custom_wordlist or self.wordlist
            brute_subdomains = await self._dns_bruteforce(domain, wordlist)
            discovered.update(brute_subdomains)
            methods_used.append("dns_bruteforce")
            console.print(f"  [green]Found {len(brute_subdomains)} from bruteforce[/green]")
        
        # Zone Transfer
        console.print("[cyan]Attempting zone transfer...[/cyan]")
        zt_subdomains = await self._zone_transfer(domain)
        if zt_subdomains:
            discovered.update(zt_subdomains)
            methods_used.append("zone_transfer")
            console.print(f"  [green]Zone transfer successful! Found {len(zt_subdomains)}[/green]")
        else:
            console.print(f"  [dim]Zone transfer not allowed[/dim]")
        
        console.print(f"\n[cyan]Total unique subdomains: {len(discovered)}[/cyan]")
        
        # Check alive status
        results = []
        if check_alive and discovered:
            console.print("[cyan]Checking live subdomains...[/cyan]")
            results = await self._check_alive(list(discovered))
        else:
            results = [SubdomainResult(subdomain=s) for s in discovered]
        
        # Sort by subdomain name
        results.sort(key=lambda x: x.subdomain)
        
        alive_count = sum(1 for r in results if r.is_alive)
        
        result = EnumerationResult(
            domain=domain,
            subdomains=results,
            total_found=len(results),
            alive_count=alive_count,
            methods_used=methods_used,
        )
        
        # Display summary
        self._display_summary(result)
        
        return result
    
    async def _query_crt_sh(self, domain: str) -> Set[str]:
        """Query crt.sh for subdomains from CT logs"""
        subdomains = set()
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"https://crt.sh/?q=%.{domain}&output=json"
                )
                
                if response.status_code == 200:
                    data = response.json()
                    for entry in data:
                        name = entry.get("name_value", "")
                        # Handle wildcard and multi-line entries
                        for sub in name.split("\n"):
                            sub = sub.strip().lower()
                            if sub.startswith("*."):
                                sub = sub[2:]
                            if sub.endswith(f".{domain}") or sub == domain:
                                subdomains.add(sub)
        except Exception as e:
            console.print(f"  [yellow]crt.sh query failed: {str(e)}[/yellow]")
        
        return subdomains
    
    async def _dns_bruteforce(
        self,
        domain: str,
        wordlist: List[str]
    ) -> Set[str]:
        """Bruteforce subdomains using DNS resolution"""
        import dns.resolver
        
        discovered = set()
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def check_subdomain(word: str) -> Optional[str]:
            async with semaphore:
                subdomain = f"{word}.{domain}"
                try:
                    resolver = dns.resolver.Resolver()
                    resolver.timeout = self.settings.subdomain.timeout
                    resolver.lifetime = self.settings.subdomain.timeout
                    resolver.nameservers = self.resolvers
                    
                    # Run in executor to avoid blocking
                    loop = asyncio.get_event_loop()
                    await loop.run_in_executor(
                        None,
                        lambda: resolver.resolve(subdomain, 'A')
                    )
                    return subdomain
                except Exception:
                    return None
        
        with Progress() as progress:
            task = progress.add_task(
                "[cyan]Bruteforcing...",
                total=len(wordlist)
            )
            
            # Process in batches
            for i in range(0, len(wordlist), 100):
                batch = wordlist[i:i + 100]
                tasks = [check_subdomain(word) for word in batch]
                results = await asyncio.gather(*tasks)
                
                for result in results:
                    if result:
                        discovered.add(result)
                        console.print(f"  [green]✓[/green] {result}")
                
                progress.advance(task, len(batch))
        
        return discovered
    
    async def _zone_transfer(self, domain: str) -> Set[str]:
        """Attempt DNS zone transfer"""
        import dns.resolver
        import dns.zone
        import dns.query
        
        subdomains = set()
        
        try:
            # Get NS records
            resolver = dns.resolver.Resolver()
            ns_records = resolver.resolve(domain, 'NS')
            
            for ns in ns_records:
                ns_host = str(ns).rstrip('.')
                try:
                    # Attempt zone transfer
                    zone = dns.zone.from_xfr(
                        dns.query.xfr(ns_host, domain, timeout=10)
                    )
                    
                    for name, node in zone.nodes.items():
                        subdomain = str(name)
                        if subdomain != '@':
                            full_domain = f"{subdomain}.{domain}"
                            subdomains.add(full_domain)
                    
                    if subdomains:
                        break  # Found a vulnerable NS
                        
                except Exception:
                    continue
                    
        except Exception:
            pass
        
        return subdomains
    
    async def _check_alive(
        self,
        subdomains: List[str]
    ) -> List[SubdomainResult]:
        """Check if subdomains are alive and gather info"""
        results = []
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def check_subdomain(subdomain: str) -> SubdomainResult:
            async with semaphore:
                result = SubdomainResult(subdomain=subdomain)
                
                # Resolve IP
                try:
                    ips = socket.gethostbyname_ex(subdomain)[2]
                    result.ip_addresses = ips
                except Exception:
                    pass
                
                # Check HTTP/HTTPS
                async with httpx.AsyncClient(
                    timeout=10.0,
                    follow_redirects=True,
                    verify=False
                ) as client:
                    # Try HTTPS first
                    try:
                        response = await client.get(f"https://{subdomain}")
                        result.https_status = response.status_code
                        result.is_alive = True
                        result.server = response.headers.get("server", "")
                        
                        # Extract title
                        if "text/html" in response.headers.get("content-type", ""):
                            title_match = re.search(
                                r'<title[^>]*>([^<]+)</title>',
                                response.text,
                                re.IGNORECASE
                            )
                            if title_match:
                                result.title = title_match.group(1).strip()[:100]
                        
                        # Detect technologies
                        result.technologies = self._detect_technologies(
                            response.headers,
                            response.text[:5000]
                        )
                        
                    except Exception:
                        pass
                    
                    # Try HTTP if HTTPS failed
                    if not result.is_alive:
                        try:
                            response = await client.get(f"http://{subdomain}")
                            result.http_status = response.status_code
                            result.is_alive = True
                            result.server = response.headers.get("server", "")
                            
                            if "text/html" in response.headers.get("content-type", ""):
                                title_match = re.search(
                                    r'<title[^>]*>([^<]+)</title>',
                                    response.text,
                                    re.IGNORECASE
                                )
                                if title_match:
                                    result.title = title_match.group(1).strip()[:100]
                            
                            result.technologies = self._detect_technologies(
                                response.headers,
                                response.text[:5000]
                            )
                            
                        except Exception:
                            pass
                
                return result
        
        with Progress() as progress:
            task = progress.add_task(
                "[cyan]Checking live hosts...",
                total=len(subdomains)
            )
            
            for i in range(0, len(subdomains), 50):
                batch = subdomains[i:i + 50]
                tasks = [check_subdomain(s) for s in batch]
                batch_results = await asyncio.gather(*tasks)
                results.extend(batch_results)
                
                for r in batch_results:
                    if r.is_alive:
                        console.print(
                            f"  [green]✓[/green] {r.subdomain} "
                            f"[{r.https_status or r.http_status}] "
                            f"{r.title[:50] if r.title else ''}"
                        )
                
                progress.advance(task, len(batch))
        
        return results
    
    def _detect_technologies(
        self,
        headers: httpx.Headers,
        body: str
    ) -> List[str]:
        """Detect technologies from response"""
        technologies = []
        
        # Server header
        server = headers.get("server", "").lower()
        if "nginx" in server:
            technologies.append("Nginx")
        elif "apache" in server:
            technologies.append("Apache")
        elif "iis" in server:
            technologies.append("IIS")
        elif "cloudflare" in server:
            technologies.append("Cloudflare")
        
        # X-Powered-By
        powered_by = headers.get("x-powered-by", "").lower()
        if "php" in powered_by:
            technologies.append("PHP")
        elif "asp.net" in powered_by:
            technologies.append("ASP.NET")
        elif "express" in powered_by:
            technologies.append("Express.js")
        
        # Body analysis
        body_lower = body.lower()
        if "wp-content" in body_lower or "wordpress" in body_lower:
            technologies.append("WordPress")
        if "drupal" in body_lower:
            technologies.append("Drupal")
        if "joomla" in body_lower:
            technologies.append("Joomla")
        if "react" in body_lower or "_next" in body_lower:
            technologies.append("React/Next.js")
        if "vue" in body_lower or "__vue" in body_lower:
            technologies.append("Vue.js")
        if "angular" in body_lower:
            technologies.append("Angular")
        if "laravel" in body_lower:
            technologies.append("Laravel")
        if "django" in body_lower:
            technologies.append("Django")
        if "rails" in body_lower:
            technologies.append("Ruby on Rails")
        
        return list(set(technologies))
    
    def _display_summary(self, result: EnumerationResult):
        """Display enumeration summary"""
        from rich.table import Table
        
        console.print(f"\n[bold cyan]═══ Enumeration Summary ═══[/bold cyan]")
        
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="white")
        
        table.add_row("Domain", result.domain)
        table.add_row("Total Found", str(result.total_found))
        table.add_row("Alive", str(result.alive_count))
        table.add_row("Methods", ", ".join(result.methods_used))
        
        console.print(table)
        
        # Show alive subdomains
        alive = [s for s in result.subdomains if s.is_alive]
        if alive:
            console.print(f"\n[bold green]Live Subdomains:[/bold green]")
            for s in alive[:20]:  # Show first 20
                status = s.https_status or s.http_status
                console.print(f"  • {s.subdomain} [{status}] {s.title[:40]}")
            
            if len(alive) > 20:
                console.print(f"  ... and {len(alive) - 20} more")
