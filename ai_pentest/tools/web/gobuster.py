"""
Gobuster Scanner Wrapper
========================

Directory/file/DNS/vhost brute forcing tool.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class GobusterScanner(ToolWrapper):
    """
    Gobuster - Directory/file enumeration
    
    Features:
    - Directory brute forcing
    - DNS subdomain enumeration
    - Virtual host discovery
    - S3 bucket enumeration
    """
    
    TOOL_NAME = "Gobuster"
    BINARY_NAME = "gobuster"
    INSTALL_HINT = "Install with: apt install gobuster / go install github.com/OJ/gobuster/v3@latest"
    
    def build_command(
        self,
        target: str,
        mode: str = "dir",
        wordlist: str = "/usr/share/wordlists/dirb/common.txt",
        extensions: Optional[List[str]] = None,
        threads: int = 50,
        status_codes: str = "200,204,301,302,307,401,403",
        no_error: bool = True,
        follow_redirect: bool = False,
        timeout: int = 10,
        user_agent: Optional[str] = None,
        cookies: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME, mode]
        
        cmd.extend(["-u", target])
        cmd.extend(["-w", wordlist])
        cmd.extend(["-t", str(threads)])
        
        if mode == "dir":
            if extensions:
                cmd.extend(["-x", ",".join(extensions)])
            cmd.extend(["-s", status_codes])
            if follow_redirect:
                cmd.append("-r")
            cmd.extend(["--timeout", f"{timeout}s"])
        
        if no_error:
            cmd.append("--no-error")
        
        if user_agent:
            cmd.extend(["-a", user_agent])
        
        if cookies:
            cmd.extend(["-c", cookies])
        
        if headers:
            for key, value in headers.items():
                cmd.extend(["-H", f"{key}: {value}"])
        
        output_file = self.output_dir / f"gobuster_{target.replace('://', '_').replace('/', '_')}.txt"
        cmd.extend(["-o", str(output_file)])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"directories": [], "files": [], "subdomains": []}
        
        # Parse directory/file results
        dir_pattern = r"(/\S+)\s+\(Status:\s+(\d+)\)\s+\[Size:\s+(\d+)\]"
        for match in re.finditer(dir_pattern, output):
            entry = {
                "path": match.group(1),
                "status": int(match.group(2)),
                "size": int(match.group(3))
            }
            
            if "." in entry["path"].split("/")[-1]:
                raw_data["files"].append(entry)
            else:
                raw_data["directories"].append(entry)
            
            # Determine severity based on path
            severity = "info"
            interesting_paths = ["admin", "backup", "config", "db", "sql", "upload", "private", "secret", ".git", ".env"]
            for ipath in interesting_paths:
                if ipath in entry["path"].lower():
                    severity = "medium" if entry["status"] != 403 else "low"
                    break
            
            findings.append(self._create_finding(
                title=f"Discovered: {entry['path']}",
                severity=severity,
                description=f"Status: {entry['status']}, Size: {entry['size']}",
                url=entry["path"],
                status_code=entry["status"]
            ))
        
        # Parse DNS/vhost results
        dns_pattern = r"Found:\s+(\S+)"
        for match in re.finditer(dns_pattern, output):
            raw_data["subdomains"].append(match.group(1))
            findings.append(self._create_finding(
                title=f"Subdomain: {match.group(1)}",
                severity="info",
                description="Discovered via brute force",
                subdomain=match.group(1)
            ))
        
        return findings, raw_data
