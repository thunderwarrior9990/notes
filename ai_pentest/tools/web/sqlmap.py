"""
SQLMap Scanner Wrapper
======================

Automatic SQL injection tool.
"""

import json
import re
from pathlib import Path
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class SqlmapScanner(ToolWrapper):
    """
    SQLMap - SQL Injection Scanner
    
    Features:
    - Automatic SQL injection detection
    - Database fingerprinting
    - Data extraction
    - OS shell access
    """
    
    TOOL_NAME = "SQLMap"
    BINARY_NAME = "sqlmap"
    INSTALL_HINT = "Install with: pip install sqlmap / apt install sqlmap"
    
    def build_command(
        self,
        target: str,
        data: Optional[str] = None,
        param: Optional[str] = None,
        cookie: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None,
        level: int = 1,
        risk: int = 1,
        technique: Optional[str] = None,
        dbms: Optional[str] = None,
        dbs: bool = False,
        tables: bool = False,
        dump: bool = False,
        batch: bool = True,
        random_agent: bool = True,
        forms: bool = False,
        crawl: int = 0,
        threads: int = 1,
        time_sec: int = 5,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        cmd.extend(["-u", target])
        
        if data:
            cmd.extend(["--data", data])
        
        if param:
            cmd.extend(["-p", param])
        
        if cookie:
            cmd.extend(["--cookie", cookie])
        
        if headers:
            for key, value in headers.items():
                cmd.extend(["--header", f"{key}: {value}"])
        
        cmd.extend(["--level", str(level)])
        cmd.extend(["--risk", str(risk)])
        
        if technique:
            cmd.extend(["--technique", technique])
        
        if dbms:
            cmd.extend(["--dbms", dbms])
        
        if dbs:
            cmd.append("--dbs")
        
        if tables:
            cmd.append("--tables")
        
        if dump:
            cmd.append("--dump")
        
        if batch:
            cmd.append("--batch")
        
        if random_agent:
            cmd.append("--random-agent")
        
        if forms:
            cmd.append("--forms")
        
        if crawl > 0:
            cmd.extend(["--crawl", str(crawl)])
        
        cmd.extend(["--threads", str(threads)])
        cmd.extend(["--time-sec", str(time_sec)])
        
        output_dir = self.output_dir / f"sqlmap_{target.replace('://', '_').replace('/', '_').replace('?', '_')}"
        cmd.extend(["--output-dir", str(output_dir)])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {
            "injectable": False,
            "parameters": [],
            "dbms": "",
            "databases": [],
            "tables": [],
            "data": []
        }
        
        # Check for injection
        if "is vulnerable" in output.lower() or "injectable" in output.lower():
            raw_data["injectable"] = True
            
            findings.append(self._create_finding(
                title="SQL Injection Vulnerability Confirmed",
                severity="critical",
                description="SQLMap confirmed the target is vulnerable to SQL injection",
                evidence=output[:500],
                cwe_id="CWE-89",
                remediation="Use parameterized queries/prepared statements"
            ))
        
        # Parse injection type
        type_pattern = r"Type:\s+(.+)"
        for match in re.finditer(type_pattern, output):
            raw_data["parameters"].append({"type": match.group(1)})
        
        # Parse DBMS
        dbms_pattern = r"back-end DBMS:\s+(.+)"
        dbms_match = re.search(dbms_pattern, output)
        if dbms_match:
            raw_data["dbms"] = dbms_match.group(1)
            findings.append(self._create_finding(
                title=f"Database Identified: {raw_data['dbms']}",
                severity="info",
                description=f"Backend DBMS: {raw_data['dbms']}"
            ))
        
        # Parse databases
        db_pattern = r"\[\*\]\s+(\w+)"
        in_dbs = False
        for line in output.split("\n"):
            if "available databases" in line.lower():
                in_dbs = True
                continue
            if in_dbs:
                match = re.match(db_pattern, line.strip())
                if match:
                    raw_data["databases"].append(match.group(1))
                elif line.strip() and not line.startswith("["):
                    in_dbs = False
        
        if raw_data["databases"]:
            findings.append(self._create_finding(
                title=f"Databases Enumerated: {len(raw_data['databases'])}",
                severity="high",
                description=f"Databases: {', '.join(raw_data['databases'][:10])}",
                evidence=str(raw_data["databases"])
            ))
        
        # Check for data extraction
        if "dumped to" in output.lower():
            findings.append(self._create_finding(
                title="Database Data Extracted",
                severity="critical",
                description="SQLMap successfully extracted data from the database",
                evidence="Data dumped - check output directory"
            ))
        
        return findings, raw_data
