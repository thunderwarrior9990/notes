"""
DNSEnum Scanner Wrapper
=======================

DNS enumeration tool.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper, ToolResult, ToolStatus


def is_ip_address(target: str) -> bool:
    """Check if the target is an IP address"""
    ip_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    ipv6_pattern = r'^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'
    return bool(re.match(ip_pattern, target) or re.match(ipv6_pattern, target))


class DnsenumScanner(ToolWrapper):
    """
    DNSEnum - DNS Enumeration
    
    Features:
    - Host addresses
    - NS/MX records
    - Zone transfers
    - Google scraping
    
    Note: This tool only works with domain names, not IP addresses.
    """
    
    TOOL_NAME = "DNSEnum"
    BINARY_NAME = "dnsenum"
    INSTALL_HINT = "Install with: apt install dnsenum"
    
    def _validate_target(self, target: str) -> Tuple[bool, str]:
        """Validate that target is a domain name, not an IP address"""
        if is_ip_address(target):
            return False, "DNSEnum requires a domain name, not an IP address"
        if not target or '.' not in target:
            return False, "DNSEnum requires a valid domain name"
        return True, ""
    
    def build_command(
        self,
        target: str,
        threads: int = 5,
        scrape: bool = True,
        private: bool = False,
        subfile: Optional[str] = None,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        cmd.extend(["--threads", str(threads)])
        
        if scrape:
            cmd.append("--scrape")
        
        if not private:
            cmd.append("--noprivate")
        
        if subfile:
            cmd.extend(["-f", subfile])
        
        output_file = self.output_dir / f"dnsenum_{target.replace('.', '_')}.xml"
        cmd.extend(["-o", str(output_file)])
        
        cmd.append(target)
        
        return cmd
    
    async def run(self, target: str, **kwargs) -> ToolResult:
        """Override run to validate target before execution"""
        # Validate target is a domain name
        valid, error_msg = self._validate_target(target)
        if not valid:
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command="",
                status=ToolStatus.ERROR,
                error=error_msg
            )
        
        # Call parent implementation
        return await super().run(target, **kwargs)
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {
            "host_addresses": [],
            "nameservers": [],
            "mail_servers": [],
            "zone_transfers": [],
            "subdomains": []
        }
        
        # Parse host addresses
        host_pattern = r"Host's addresses:\s*\n((?:\s*\S+\s+\S+\s*\n)+)"
        host_match = re.search(host_pattern, output)
        if host_match:
            for line in host_match.group(1).strip().split("\n"):
                parts = line.split()
                if len(parts) >= 2:
                    raw_data["host_addresses"].append({"name": parts[0], "ip": parts[1]})
        
        # Parse nameservers
        ns_pattern = r"Name Servers:\s*\n((?:\s*\S+\s+\S+\s*\n)+)"
        ns_match = re.search(ns_pattern, output)
        if ns_match:
            for line in ns_match.group(1).strip().split("\n"):
                parts = line.split()
                if len(parts) >= 2:
                    raw_data["nameservers"].append({"name": parts[0], "ip": parts[1]})
        
        # Parse mail servers
        mx_pattern = r"Mail \(MX\) Servers:\s*\n((?:\s*\S+\s+\S+\s*\n)+)"
        mx_match = re.search(mx_pattern, output)
        if mx_match:
            for line in mx_match.group(1).strip().split("\n"):
                parts = line.split()
                if len(parts) >= 2:
                    raw_data["mail_servers"].append({"name": parts[0], "ip": parts[1]})
        
        # Check zone transfer
        if "Zone Transfer" in output and "failed" not in output.lower():
            findings.append(self._create_finding(
                title="DNS Zone Transfer Allowed",
                severity="high",
                description="Zone transfer was successful",
                remediation="Restrict zone transfers to trusted IPs only"
            ))
        
        # Create findings for discovered records
        for ns in raw_data["nameservers"]:
            findings.append(self._create_finding(
                title=f"Nameserver: {ns['name']}",
                severity="info",
                description=f"IP: {ns['ip']}"
            ))
        
        for mx in raw_data["mail_servers"]:
            findings.append(self._create_finding(
                title=f"Mail Server: {mx['name']}",
                severity="info",
                description=f"IP: {mx['ip']}"
            ))
        
        return findings, raw_data
