"""
Nmap Scanner Wrapper
====================

Network exploration and security auditing tool.
"""

import os
import re
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Tuple, Optional
from pathlib import Path

from ..base import ToolWrapper


def is_root() -> bool:
    """Check if running as root/administrator"""
    return os.geteuid() == 0


class NmapScanner(ToolWrapper):
    """
    Nmap - Network Mapper
    
    Features:
    - Port scanning
    - Service/version detection
    - OS detection
    - Script scanning (NSE)
    - Vulnerability detection
    """
    
    TOOL_NAME = "Nmap"
    BINARY_NAME = "nmap"
    INSTALL_HINT = "Install with: apt install nmap / brew install nmap"
    
    def build_command(
        self,
        target: str,
        ports: str = "-",
        scan_type: str = "default",
        scripts: Optional[List[str]] = None,
        os_detection: bool = False,
        version_detection: bool = True,
        aggressive: bool = False,
        output_format: str = "xml",
        **kwargs
    ) -> List[str]:
        """
        Build nmap command
        
        Args:
            target: Target IP/hostname/range
            ports: Port specification (-p)
            scan_type: Scan type (default, syn, connect, udp, comprehensive)
            scripts: NSE scripts to run
            os_detection: Enable OS detection
            version_detection: Enable version detection
            aggressive: Enable aggressive scan (-A)
            output_format: Output format (xml, normal, greppable)
        """
        cmd = [self.BINARY_NAME]
        
        # Check if we have root privileges
        has_root = is_root()
        
        # Scan type - adjust based on privileges
        if scan_type == "syn":
            if has_root:
                cmd.extend(["-sS"])
            else:
                # Fall back to TCP connect scan without root
                cmd.extend(["-sT"])
        elif scan_type == "connect":
            cmd.extend(["-sT"])
        elif scan_type == "udp":
            if has_root:
                cmd.extend(["-sU"])
            else:
                # UDP scan requires root, fall back to TCP connect
                cmd.extend(["-sT"])
        elif scan_type == "comprehensive":
            if has_root:
                cmd.extend(["-sS", "-sU", "-sV", "-O", "-A"])
            else:
                # Non-root comprehensive scan: TCP connect + version detection + scripts
                cmd.extend(["-sT", "-sV", "-sC", "--top-ports", "1000"])
        elif scan_type == "vuln":
            cmd.extend(["-sV", "--script", "vuln"])
        
        # Ports
        if ports != "-":
            cmd.extend(["-p", ports])
        
        # Version detection
        if version_detection and scan_type not in ["comprehensive"]:
            cmd.append("-sV")
        
        # OS detection (requires root)
        if os_detection and scan_type not in ["comprehensive"]:
            if has_root:
                cmd.append("-O")
            # Skip OS detection without root - it will fail
        
        # Aggressive (some features require root)
        if aggressive and scan_type not in ["comprehensive"]:
            if has_root:
                cmd.append("-A")
            else:
                # Non-root aggressive: version detection + default scripts
                cmd.extend(["-sV", "-sC"])
        
        # Scripts
        if scripts:
            cmd.extend(["--script", ",".join(scripts)])
        
        # Output
        output_file = self.output_dir / f"nmap_{target.replace('/', '_')}"
        if output_format == "xml":
            cmd.extend(["-oX", str(output_file) + ".xml"])
        elif output_format == "greppable":
            cmd.extend(["-oG", str(output_file) + ".gnmap"])
        else:
            cmd.extend(["-oN", str(output_file) + ".txt"])
        
        # Target
        cmd.append(target)
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """Parse nmap output"""
        findings = []
        raw_data = {
            "hosts": [],
            "open_ports": [],
            "services": [],
            "os_matches": [],
            "scripts": []
        }
        
        # Try to parse XML output file
        xml_files = list(self.output_dir.glob("nmap_*.xml"))
        if xml_files:
            try:
                tree = ET.parse(xml_files[-1])
                root = tree.getroot()
                
                for host in root.findall(".//host"):
                    host_data = self._parse_host(host)
                    raw_data["hosts"].append(host_data)
                    
                    # Create findings from open ports
                    for port in host_data.get("ports", []):
                        if port["state"] == "open":
                            raw_data["open_ports"].append(port)
                            
                            # Service finding
                            findings.append(self._create_finding(
                                title=f"Open Port: {port['port']}/{port['protocol']}",
                                severity="info",
                                description=f"Service: {port.get('service', 'unknown')} "
                                           f"Version: {port.get('version', 'unknown')}",
                                evidence=f"Port {port['port']} is open running {port.get('service', 'unknown')}",
                                port=port["port"],
                                protocol=port["protocol"],
                                service=port.get("service", ""),
                                version=port.get("version", "")
                            ))
                            
                            # Check for vulnerable services
                            self._check_service_vulnerabilities(port, findings)
                    
                    # Script results
                    for script in host_data.get("scripts", []):
                        raw_data["scripts"].append(script)
                        if "VULNERABLE" in script.get("output", "").upper():
                            findings.append(self._create_finding(
                                title=f"Vulnerability: {script['id']}",
                                severity="high",
                                description=script.get("output", "")[:500],
                                evidence=script.get("output", ""),
                                script_id=script["id"]
                            ))
                            
            except ET.ParseError:
                pass
        
        # Fallback to text parsing
        if not raw_data["hosts"]:
            raw_data = self._parse_text_output(output)
            for port_info in raw_data.get("open_ports", []):
                findings.append(self._create_finding(
                    title=f"Open Port: {port_info}",
                    severity="info",
                    description=f"Open port detected: {port_info}"
                ))
        
        return findings, raw_data
    
    def _parse_host(self, host_elem: ET.Element) -> Dict[str, Any]:
        """Parse a host element from nmap XML"""
        host_data = {
            "status": "",
            "addresses": [],
            "hostnames": [],
            "ports": [],
            "os_matches": [],
            "scripts": []
        }
        
        # Status
        status = host_elem.find("status")
        if status is not None:
            host_data["status"] = status.get("state", "")
        
        # Addresses
        for addr in host_elem.findall(".//address"):
            host_data["addresses"].append({
                "type": addr.get("addrtype", ""),
                "addr": addr.get("addr", "")
            })
        
        # Hostnames
        for hostname in host_elem.findall(".//hostname"):
            host_data["hostnames"].append(hostname.get("name", ""))
        
        # Ports
        for port in host_elem.findall(".//port"):
            port_data = {
                "port": int(port.get("portid", 0)),
                "protocol": port.get("protocol", ""),
                "state": "",
                "service": "",
                "version": "",
                "scripts": []
            }
            
            state = port.find("state")
            if state is not None:
                port_data["state"] = state.get("state", "")
            
            service = port.find("service")
            if service is not None:
                port_data["service"] = service.get("name", "")
                port_data["version"] = f"{service.get('product', '')} {service.get('version', '')}".strip()
            
            # Port scripts
            for script in port.findall(".//script"):
                port_data["scripts"].append({
                    "id": script.get("id", ""),
                    "output": script.get("output", "")
                })
            
            host_data["ports"].append(port_data)
        
        # OS matches
        for osmatch in host_elem.findall(".//osmatch"):
            host_data["os_matches"].append({
                "name": osmatch.get("name", ""),
                "accuracy": osmatch.get("accuracy", "")
            })
        
        # Host scripts
        for script in host_elem.findall("hostscript/script"):
            host_data["scripts"].append({
                "id": script.get("id", ""),
                "output": script.get("output", "")
            })
        
        return host_data
    
    def _parse_text_output(self, output: str) -> Dict[str, Any]:
        """Parse text output as fallback"""
        data = {"open_ports": [], "hosts": []}
        
        # Find open ports
        port_pattern = r"(\d+)/(tcp|udp)\s+open\s+(\S+)"
        for match in re.finditer(port_pattern, output):
            data["open_ports"].append({
                "port": int(match.group(1)),
                "protocol": match.group(2),
                "service": match.group(3)
            })
        
        return data
    
    def _check_service_vulnerabilities(self, port: Dict[str, Any], findings: List[Dict[str, Any]]):
        """Check for known vulnerable service versions"""
        service = port.get("service", "").lower()
        version = port.get("version", "").lower()
        
        # Common vulnerable services/versions
        vuln_patterns = [
            ("ssh", "openssh 7.2", "high", "OpenSSH 7.2 may be vulnerable to user enumeration (CVE-2016-6210)"),
            ("ftp", "vsftpd 2.3.4", "critical", "vsftpd 2.3.4 contains a backdoor (CVE-2011-2523)"),
            ("smb", "samba 3", "high", "Samba 3.x may be vulnerable to multiple CVEs"),
            ("http", "apache 2.4.49", "critical", "Apache 2.4.49 vulnerable to path traversal (CVE-2021-41773)"),
            ("http", "apache 2.4.50", "critical", "Apache 2.4.50 vulnerable to RCE (CVE-2021-42013)"),
            ("mysql", "5.5", "medium", "MySQL 5.5 is EOL and may have unpatched vulnerabilities"),
            ("telnet", "", "high", "Telnet transmits credentials in cleartext"),
            ("ftp", "", "medium", "FTP transmits credentials in cleartext"),
        ]
        
        for svc, ver, severity, desc in vuln_patterns:
            if svc in service and (not ver or ver in version):
                findings.append(self._create_finding(
                    title=f"Potentially Vulnerable Service: {port.get('service', '')}",
                    severity=severity,
                    description=desc,
                    evidence=f"Detected: {port.get('version', 'unknown version')}",
                    port=port["port"],
                    remediation="Update to the latest version or disable if not needed"
                ))
                break


class NmapVulnScanner(NmapScanner):
    """Nmap with vulnerability scanning scripts"""
    
    def build_command(self, target: str, **kwargs) -> List[str]:
        kwargs["scripts"] = kwargs.get("scripts", []) + ["vuln", "exploit"]
        kwargs["version_detection"] = True
        return super().build_command(target, **kwargs)
