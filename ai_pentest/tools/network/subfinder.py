"""
Subfinder Enumerator Wrapper
============================

Fast passive subdomain enumeration tool.
"""

import json
import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper, ToolResult, ToolStatus


def is_ip_address(target: str) -> bool:
    """Check if the target is an IP address"""
    ip_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    ipv6_pattern = r'^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'
    return bool(re.match(ip_pattern, target) or re.match(ipv6_pattern, target))


class SubfinderEnumerator(ToolWrapper):
    """
    Subfinder - Subdomain discovery tool
    
    Features:
    - Passive subdomain enumeration
    - Multiple data sources
    - Fast and efficient
    
    Note: This tool only works with domain names, not IP addresses.
    """
    
    TOOL_NAME = "Subfinder"
    BINARY_NAME = "subfinder"
    INSTALL_HINT = "Install with: go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"
    
    def _validate_target(self, target: str) -> Tuple[bool, str]:
        """Validate that target is a domain name, not an IP address"""
        if is_ip_address(target):
            return False, "Subfinder requires a domain name, not an IP address"
        if not target or '.' not in target:
            return False, "Subfinder requires a valid domain name"
        return True, ""
    
    async def run(self, target: str, **kwargs) -> ToolResult:
        """Override run to validate target before execution"""
        # Validate target is a domain name
        valid, error_msg = self._validate_target(target)
        if not valid:
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command="",
                status=ToolStatus.ERROR,
                error=error_msg
            )
        
        # Call parent implementation
        return await super().run(target, **kwargs)
    
    def build_command(
        self,
        target: str,
        recursive: bool = False,
        all_sources: bool = True,
        silent: bool = False,
        output_format: str = "json",
        **kwargs
    ) -> List[str]:
        """
        Build subfinder command
        
        Args:
            target: Target domain
            recursive: Enable recursive enumeration
            all_sources: Use all sources
            silent: Silent mode
            output_format: Output format
        """
        cmd = [self.BINARY_NAME]
        
        # Domain
        cmd.extend(["-d", target])
        
        # Options
        if recursive:
            cmd.append("-recursive")
        if all_sources:
            cmd.append("-all")
        if silent:
            cmd.append("-silent")
        
        # Output
        output_file = self.output_dir / f"subfinder_{target.replace('.', '_')}"
        if output_format == "json":
            cmd.extend(["-oJ", "-o", str(output_file) + ".json"])
        else:
            cmd.extend(["-o", str(output_file) + ".txt"])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """Parse subfinder output"""
        findings = []
        raw_data = {"subdomains": [], "sources": {}}
        
        # Try JSON output
        json_files = list(self.output_dir.glob("subfinder_*.json"))
        if json_files:
            try:
                with open(json_files[-1]) as f:
                    for line in f:
                        try:
                            entry = json.loads(line.strip())
                            subdomain = entry.get("host", "")
                            source = entry.get("source", "unknown")
                            
                            if subdomain and subdomain not in raw_data["subdomains"]:
                                raw_data["subdomains"].append(subdomain)
                                
                            if source not in raw_data["sources"]:
                                raw_data["sources"][source] = []
                            raw_data["sources"][source].append(subdomain)
                        except json.JSONDecodeError:
                            continue
            except Exception:
                pass
        
        # Fallback to text
        if not raw_data["subdomains"]:
            for line in output.split("\n"):
                line = line.strip()
                if line and "." in line:
                    raw_data["subdomains"].append(line)
        
        # Create findings
        for subdomain in raw_data["subdomains"]:
            findings.append(self._create_finding(
                title=f"Subdomain: {subdomain}",
                severity="info",
                description=f"Discovered via subfinder",
                subdomain=subdomain
            ))
        
        return findings, raw_data
