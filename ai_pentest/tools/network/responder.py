"""
Responder Tool Wrapper
======================

LLMNR, NBT-NS and MDNS poisoner.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class ResponderTool(ToolWrapper):
    """
    Responder - LLMNR/NBT-NS/MDNS Poisoner
    
    Features:
    - LLMNR poisoning
    - NBT-NS poisoning
    - MDNS poisoning
    - Credential capture
    
    WARNING: This tool should only be used on networks you own or have permission to test.
    """
    
    TOOL_NAME = "Responder"
    BINARY_NAME = "responder"
    INSTALL_HINT = "Install with: apt install responder / git clone https://github.com/lgandx/Responder"
    
    def build_command(
        self,
        target: str,  # Interface name (e.g., eth0)
        analyze: bool = True,
        wpad: bool = False,
        fingerprint: bool = False,
        force_wpad_auth: bool = False,
        basic_auth: bool = False,
        **kwargs
    ) -> List[str]:
        """
        Build responder command
        
        Args:
            target: Network interface (e.g., eth0)
            analyze: Analyze mode (passive, no poisoning)
            wpad: Start WPAD rogue proxy server
            fingerprint: Fingerprint hosts
            force_wpad_auth: Force NTLM auth on WPAD
            basic_auth: Use Basic auth instead of NTLM
        """
        cmd = [self.BINARY_NAME]
        
        cmd.extend(["-I", target])
        
        if analyze:
            cmd.append("-A")  # Analyze mode - passive
        
        if wpad:
            cmd.append("-w")
        
        if fingerprint:
            cmd.append("-f")
        
        if force_wpad_auth:
            cmd.append("-F")
        
        if basic_auth:
            cmd.append("-b")
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"hashes": [], "hosts_detected": [], "requests": []}
        
        # Parse captured hashes
        hash_patterns = [
            (r"\[SMB\]\s+NTLMv2-SSP\s+Client\s+:\s+(\S+)", "NTLMv2-SSP"),
            (r"\[SMB\]\s+NTLMv1\s+Hash\s+:\s+(\S+)", "NTLMv1"),
            (r"\[HTTP\]\s+NTLMv2\s+Client\s+:\s+(\S+)", "HTTP-NTLMv2"),
            (r"\[SMB\]\s+NTLMv2-SSP Hash\s+:\s+(.+)", "NTLMv2 Hash"),
        ]
        
        for pattern, hash_type in hash_patterns:
            for match in re.finditer(pattern, output):
                hash_data = {
                    "type": hash_type,
                    "client": match.group(1),
                    "hash": match.group(1) if "Hash" in hash_type else ""
                }
                raw_data["hashes"].append(hash_data)
                
                findings.append(self._create_finding(
                    title=f"Captured {hash_type} Hash",
                    severity="high",
                    description=f"Captured credential hash from {match.group(1)}",
                    evidence=match.group(0),
                    hash_type=hash_type,
                    remediation="Implement network signing and disable LLMNR/NBT-NS"
                ))
        
        # Parse host detections
        host_pattern = r"\[\*\]\s+\[(\w+)\]\s+(.+)"
        for match in re.finditer(host_pattern, output):
            protocol = match.group(1)
            details = match.group(2)
            raw_data["requests"].append({"protocol": protocol, "details": details})
        
        # Detect vulnerable clients
        if "Poisoned answer sent" in output:
            findings.append(self._create_finding(
                title="LLMNR/NBT-NS Poisoning Successful",
                severity="high",
                description="Clients are vulnerable to name resolution poisoning",
                remediation="Disable LLMNR and NBT-NS via Group Policy"
            ))
        
        return findings, raw_data
