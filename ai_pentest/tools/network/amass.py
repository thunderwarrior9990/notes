"""
Amass Enumerator Wrapper
========================

In-depth Attack Surface Mapping and Asset Discovery.
"""

import json
import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class AmassEnumerator(ToolWrapper):
    """
    Amass - Attack Surface Mapping
    
    Features:
    - Subdomain enumeration
    - DNS enumeration
    - ASN discovery
    - Network mapping
    """
    
    TOOL_NAME = "Amass"
    BINARY_NAME = "amass"
    INSTALL_HINT = "Install with: go install github.com/owasp-amass/amass/v4/...@master"
    
    def build_command(
        self,
        target: str,
        mode: str = "enum",
        passive: bool = False,
        active: bool = True,
        brute: bool = False,
        output_format: str = "json",
        timeout: int = 30,
        **kwargs
    ) -> List[str]:
        """
        Build amass command
        
        Args:
            target: Target domain
            mode: Operation mode (enum, intel, track, viz, db)
            passive: Passive mode only
            active: Active mode
            brute: Enable brute force
            output_format: Output format
            timeout: Timeout in minutes
        """
        cmd = [self.BINARY_NAME, mode]
        
        # Domain
        cmd.extend(["-d", target])
        
        # Mode options
        if passive:
            cmd.append("-passive")
        if active and not passive:
            cmd.append("-active")
        if brute:
            cmd.append("-brute")
        
        # Timeout
        cmd.extend(["-timeout", str(timeout)])
        
        # Output
        output_file = self.output_dir / f"amass_{target.replace('.', '_')}"
        if output_format == "json":
            cmd.extend(["-json", str(output_file) + ".json"])
        else:
            cmd.extend(["-o", str(output_file) + ".txt"])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """Parse amass output"""
        findings = []
        raw_data = {"subdomains": [], "ip_addresses": [], "asns": [], "dns_records": []}
        
        # Try to read JSON output
        json_files = list(self.output_dir.glob("amass_*.json"))
        if json_files:
            try:
                with open(json_files[-1]) as f:
                    for line in f:
                        try:
                            entry = json.loads(line.strip())
                            subdomain = entry.get("name", "")
                            if subdomain:
                                raw_data["subdomains"].append(subdomain)
                            
                            # IP addresses
                            for addr in entry.get("addresses", []):
                                ip = addr.get("ip", "")
                                if ip and ip not in raw_data["ip_addresses"]:
                                    raw_data["ip_addresses"].append(ip)
                                
                                asn = addr.get("asn", 0)
                                if asn and asn not in raw_data["asns"]:
                                    raw_data["asns"].append(asn)
                        except json.JSONDecodeError:
                            continue
            except Exception:
                pass
        
        # Fallback to text parsing
        if not raw_data["subdomains"]:
            # Parse text output
            for line in output.split("\n"):
                line = line.strip()
                if line and not line.startswith("[") and "." in line:
                    raw_data["subdomains"].append(line)
        
        # Create findings
        if raw_data["subdomains"]:
            # High-value subdomains
            high_value = ["admin", "dev", "staging", "test", "api", "internal", "vpn", "mail"]
            
            for subdomain in raw_data["subdomains"]:
                severity = "info"
                for hv in high_value:
                    if hv in subdomain.lower():
                        severity = "low"
                        break
                
                findings.append(self._create_finding(
                    title=f"Subdomain Discovered: {subdomain}",
                    severity=severity,
                    description=f"Subdomain enumerated via Amass",
                    subdomain=subdomain
                ))
        
        # Summary finding
        if len(raw_data["subdomains"]) > 0:
            findings.insert(0, self._create_finding(
                title=f"Amass Enumeration Summary",
                severity="info",
                description=f"Found {len(raw_data['subdomains'])} subdomains, "
                           f"{len(raw_data['ip_addresses'])} IP addresses",
                total_subdomains=len(raw_data["subdomains"]),
                total_ips=len(raw_data["ip_addresses"])
            ))
        
        return findings, raw_data
