"""
Enum4linux-ng Scanner Wrapper
=============================

Windows/Samba enumeration tool.
"""

import json
import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class Enum4linuxScanner(ToolWrapper):
    """
    Enum4linux-ng - Windows/Samba enumeration
    
    Features:
    - User enumeration
    - Share enumeration
    - Group enumeration
    - Password policy
    - OS detection
    """
    
    TOOL_NAME = "Enum4linux-ng"
    BINARY_NAME = "enum4linux-ng"
    INSTALL_HINT = "Install with: pip install enum4linux-ng"
    
    def build_command(
        self,
        target: str,
        username: Optional[str] = None,
        password: Optional[str] = None,
        all_enum: bool = True,
        users: bool = False,
        shares: bool = False,
        groups: bool = False,
        policies: bool = False,
        rid_brute: bool = False,
        rid_range: str = "500-550,1000-1050",
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        if username:
            cmd.extend(["-u", username])
        if password:
            cmd.extend(["-p", password])
        
        if all_enum:
            cmd.append("-A")
        else:
            if users:
                cmd.append("-U")
            if shares:
                cmd.append("-S")
            if groups:
                cmd.append("-G")
            if policies:
                cmd.append("-P")
        
        if rid_brute:
            cmd.extend(["-R", rid_range])
        
        output_file = self.output_dir / f"enum4linux_{target.replace('.', '_')}"
        cmd.extend(["-oJ", str(output_file)])
        
        cmd.append(target)
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {
            "users": [],
            "shares": [],
            "groups": [],
            "password_policy": {},
            "os_info": {},
            "domain_info": {}
        }
        
        # Try JSON output
        json_files = list(self.output_dir.glob("enum4linux_*.json"))
        if json_files:
            try:
                with open(json_files[-1]) as f:
                    data = json.load(f)
                    raw_data["users"] = data.get("users", [])
                    raw_data["shares"] = data.get("shares", [])
                    raw_data["groups"] = data.get("groups", [])
                    raw_data["password_policy"] = data.get("password_policy", {})
                    raw_data["os_info"] = data.get("os_info", {})
            except Exception:
                pass
        
        # Fallback to text parsing
        if not raw_data["users"]:
            # Parse users
            user_pattern = r"user:\[([^\]]+)\]\s+rid:\[([^\]]+)\]"
            for match in re.finditer(user_pattern, output):
                raw_data["users"].append({
                    "username": match.group(1),
                    "rid": match.group(2)
                })
        
        if not raw_data["shares"]:
            # Parse shares
            share_pattern = r"(\w+)\s+Disk\s+(.*)"
            for match in re.finditer(share_pattern, output):
                raw_data["shares"].append({
                    "name": match.group(1),
                    "comment": match.group(2).strip()
                })
        
        # Parse password policy
        policy_patterns = {
            "min_length": r"Minimum password length:\s*(\d+)",
            "lockout_threshold": r"Account lockout threshold:\s*(\d+)",
            "password_history": r"Password history length:\s*(\d+)",
            "max_age": r"Maximum password age:\s*(\d+)",
        }
        
        for key, pattern in policy_patterns.items():
            match = re.search(pattern, output)
            if match:
                raw_data["password_policy"][key] = match.group(1)
        
        # Create findings
        if raw_data["users"]:
            findings.append(self._create_finding(
                title=f"Enumerated {len(raw_data['users'])} Users",
                severity="medium",
                description=f"Users: {', '.join([u['username'] for u in raw_data['users'][:10]])}",
                user_count=len(raw_data["users"])
            ))
            
            # Check for common admin accounts
            for user in raw_data["users"]:
                if user["username"].lower() in ["administrator", "admin", "root", "guest"]:
                    findings.append(self._create_finding(
                        title=f"Default Account Found: {user['username']}",
                        severity="low",
                        description=f"RID: {user['rid']}",
                        username=user["username"]
                    ))
        
        if raw_data["shares"]:
            findings.append(self._create_finding(
                title=f"Enumerated {len(raw_data['shares'])} Shares",
                severity="info",
                description=f"Shares: {', '.join([s['name'] for s in raw_data['shares']])}",
                share_count=len(raw_data["shares"])
            ))
            
            # Check for interesting shares
            interesting = ["admin$", "c$", "ipc$", "backup", "it", "hr", "finance"]
            for share in raw_data["shares"]:
                if share["name"].lower() in interesting:
                    findings.append(self._create_finding(
                        title=f"Interesting Share: {share['name']}",
                        severity="low",
                        description=share.get("comment", ""),
                        share=share["name"]
                    ))
        
        # Password policy findings
        if raw_data["password_policy"]:
            min_len = int(raw_data["password_policy"].get("min_length", 0))
            if min_len < 8:
                findings.append(self._create_finding(
                    title="Weak Password Policy",
                    severity="medium",
                    description=f"Minimum password length is only {min_len}",
                    remediation="Set minimum password length to at least 12 characters"
                ))
            
            lockout = int(raw_data["password_policy"].get("lockout_threshold", 0))
            if lockout == 0:
                findings.append(self._create_finding(
                    title="No Account Lockout",
                    severity="medium",
                    description="Accounts are not locked after failed attempts",
                    remediation="Enable account lockout after 5 failed attempts"
                ))
        
        # Null session
        if "Successfully" in output and "anonymous" in output.lower():
            findings.append(self._create_finding(
                title="Null Session Allowed",
                severity="high",
                description="Anonymous/null session enumeration is possible",
                remediation="Disable null sessions via registry or Group Policy"
            ))
        
        return findings, raw_data
