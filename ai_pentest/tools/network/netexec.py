"""
NetExec Scanner Wrapper
=======================

Network execution tool (formerly CrackMapExec).
"""

import json
import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class NetexecScanner(ToolWrapper):
    """
    NetExec (nxc) - Network Execution Tool
    
    Features:
    - SMB enumeration
    - WinRM execution
    - LDAP queries
    - MSSQL interaction
    - Credential spraying
    """
    
    TOOL_NAME = "NetExec"
    BINARY_NAME = "nxc"
    INSTALL_HINT = "Install with: pip install netexec"
    
    def build_command(
        self,
        target: str,
        protocol: str = "smb",
        username: Optional[str] = None,
        password: Optional[str] = None,
        domain: Optional[str] = None,
        local_auth: bool = False,
        shares: bool = False,
        sessions: bool = False,
        users: bool = False,
        groups: bool = False,
        loggedon_users: bool = False,
        pass_pol: bool = False,
        sam: bool = False,
        lsa: bool = False,
        exec_method: Optional[str] = None,
        command: Optional[str] = None,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME, protocol]
        
        cmd.append(target)
        
        if username:
            cmd.extend(["-u", username])
        if password:
            cmd.extend(["-p", password])
        if domain:
            cmd.extend(["-d", domain])
        if local_auth:
            cmd.append("--local-auth")
        
        # Enumeration options
        if shares:
            cmd.append("--shares")
        if sessions:
            cmd.append("--sessions")
        if users:
            cmd.append("--users")
        if groups:
            cmd.append("--groups")
        if loggedon_users:
            cmd.append("--loggedon-users")
        if pass_pol:
            cmd.append("--pass-pol")
        
        # Credential dumping
        if sam:
            cmd.append("--sam")
        if lsa:
            cmd.append("--lsa")
        
        # Execution
        if exec_method:
            cmd.extend(["--exec-method", exec_method])
        if command:
            cmd.extend(["-x", command])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {
            "hosts": [],
            "shares": [],
            "users": [],
            "groups": [],
            "credentials": [],
            "sessions": []
        }
        
        # Parse SMB results
        smb_pattern = r"SMB\s+(\S+)\s+(\d+)\s+(\S+)\s+(.+)"
        for match in re.finditer(smb_pattern, output):
            host_data = {
                "ip": match.group(1),
                "port": match.group(2),
                "hostname": match.group(3),
                "info": match.group(4)
            }
            raw_data["hosts"].append(host_data)
            
            # Check for successful auth
            if "[+]" in match.group(0):
                findings.append(self._create_finding(
                    title=f"Valid Credentials on {host_data['ip']}",
                    severity="high",
                    description=f"Successful authentication to {host_data['hostname']}",
                    evidence=match.group(0),
                    ip=host_data["ip"]
                ))
        
        # Parse shares
        share_pattern = r"(\S+)\s+(READ|WRITE|READ,WRITE)\s+(.+)"
        for match in re.finditer(share_pattern, output):
            share_data = {
                "name": match.group(1),
                "access": match.group(2),
                "description": match.group(3)
            }
            raw_data["shares"].append(share_data)
            
            if "WRITE" in share_data["access"]:
                findings.append(self._create_finding(
                    title=f"Writable Share: {share_data['name']}",
                    severity="medium",
                    description=f"Share has write access: {share_data['description']}",
                    share=share_data["name"]
                ))
        
        # Parse credentials
        cred_patterns = [
            r"(\S+):(\d+):([a-fA-F0-9]+:[a-fA-F0-9]+):::",  # SAM dump
            r"(\S+):(\S+):(\S+:\S+)",  # LSA secrets
        ]
        for pattern in cred_patterns:
            for match in re.finditer(pattern, output):
                cred = {
                    "username": match.group(1),
                    "hash": match.group(3)
                }
                raw_data["credentials"].append(cred)
                
                findings.append(self._create_finding(
                    title=f"Credential Dump: {cred['username']}",
                    severity="critical",
                    description="Captured credential hash",
                    evidence=f"{cred['username']}:{cred['hash'][:20]}...",
                    username=cred["username"]
                ))
        
        # Check for Pwn3d
        if "Pwn3d!" in output:
            findings.append(self._create_finding(
                title="Admin Access Confirmed",
                severity="critical",
                description="Administrative access achieved on target",
                evidence="Pwn3d! indicator detected"
            ))
        
        return findings, raw_data
