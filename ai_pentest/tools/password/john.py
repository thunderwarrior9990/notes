"""
John the Ripper Wrapper
=======================

Password cracker.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class JohnCracker(ToolWrapper):
    """
    John the Ripper - Password Cracker
    
    Features:
    - Multiple hash types
    - Wordlist attacks
    - Rule-based attacks
    - Incremental mode
    """
    
    TOOL_NAME = "John the Ripper"
    BINARY_NAME = "john"
    INSTALL_HINT = "Install with: apt install john"
    
    def build_command(
        self,
        target: str,  # Hash file
        wordlist: Optional[str] = None,
        format: Optional[str] = None,
        rules: Optional[str] = None,
        incremental: bool = False,
        show: bool = False,
        single: bool = False,
        session: Optional[str] = None,
        fork: int = 0,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        if show:
            cmd.append("--show")
            cmd.append(target)
            return cmd
        
        if wordlist:
            cmd.extend([f"--wordlist={wordlist}"])
        
        if format:
            cmd.extend([f"--format={format}"])
        
        if rules:
            cmd.extend([f"--rules={rules}"])
        
        if incremental:
            cmd.append("--incremental")
        
        if single:
            cmd.append("--single")
        
        if session:
            cmd.extend([f"--session={session}"])
        
        if fork > 1:
            cmd.extend([f"--fork={fork}"])
        
        cmd.append(target)
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"cracked": [], "hashes_loaded": 0, "time_taken": ""}
        
        # Parse cracked passwords
        cracked_pattern = r"(\S+):(\S+)"
        for line in output.split("\n"):
            if ":" in line and not line.startswith("Loaded"):
                match = re.match(cracked_pattern, line.strip())
                if match:
                    cred = {
                        "user": match.group(1),
                        "password": match.group(2)
                    }
                    raw_data["cracked"].append(cred)
                    
                    findings.append(self._create_finding(
                        title=f"Password Cracked: {cred['user']}",
                        severity="critical",
                        description=f"Password: {cred['password']}",
                        evidence=line.strip(),
                        username=cred["user"],
                        remediation="Use stronger passwords with complexity requirements"
                    ))
        
        # Parse loaded hashes
        loaded_match = re.search(r"Loaded\s+(\d+)\s+password", output)
        if loaded_match:
            raw_data["hashes_loaded"] = int(loaded_match.group(1))
        
        # Parse timing
        time_match = re.search(r"(\d+:\d+:\d+)", output)
        if time_match:
            raw_data["time_taken"] = time_match.group(1)
        
        return findings, raw_data
