"""
CrackMapExec Scanner Wrapper
============================

Windows/Active Directory Swiss army knife.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class CrackmapexecScanner(ToolWrapper):
    """
    CrackMapExec - AD Swiss Army Knife
    
    Features:
    - SMB authentication
    - Password spraying
    - Credential dumping
    - Command execution
    """
    
    TOOL_NAME = "CrackMapExec"
    BINARY_NAME = "crackmapexec"
    INSTALL_HINT = "Install with: pip install crackmapexec"
    
    def build_command(
        self,
        target: str,
        protocol: str = "smb",
        username: Optional[str] = None,
        password: Optional[str] = None,
        domain: Optional[str] = None,
        user_file: Optional[str] = None,
        pass_file: Optional[str] = None,
        hash: Optional[str] = None,
        local_auth: bool = False,
        shares: bool = False,
        sessions: bool = False,
        sam: bool = False,
        lsa: bool = False,
        exec_method: Optional[str] = None,
        command: Optional[str] = None,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME, protocol, target]
        
        if user_file:
            cmd.extend(["-u", user_file])
        elif username:
            cmd.extend(["-u", username])
        
        if pass_file:
            cmd.extend(["-p", pass_file])
        elif password:
            cmd.extend(["-p", password])
        elif hash:
            cmd.extend(["-H", hash])
        
        if domain:
            cmd.extend(["-d", domain])
        
        if local_auth:
            cmd.append("--local-auth")
        
        if shares:
            cmd.append("--shares")
        
        if sessions:
            cmd.append("--sessions")
        
        if sam:
            cmd.append("--sam")
        
        if lsa:
            cmd.append("--lsa")
        
        if exec_method:
            cmd.extend(["--exec-method", exec_method])
        
        if command:
            cmd.extend(["-x", command])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"hosts": [], "credentials": [], "shares": []}
        
        # Parse successful authentications
        auth_pattern = r"(\d+\.\d+\.\d+\.\d+)\s+\d+\s+(\S+)\s+\[\+\]\s+(.+)"
        for match in re.finditer(auth_pattern, output):
            host_data = {
                "ip": match.group(1),
                "hostname": match.group(2),
                "result": match.group(3)
            }
            raw_data["hosts"].append(host_data)
            
            if "Pwn3d!" in host_data["result"]:
                findings.append(self._create_finding(
                    title=f"Admin Access: {host_data['ip']}",
                    severity="critical",
                    description=f"Admin credentials valid on {host_data['hostname']}",
                    evidence=host_data["result"],
                    ip=host_data["ip"]
                ))
            else:
                findings.append(self._create_finding(
                    title=f"Valid Credentials: {host_data['ip']}",
                    severity="high",
                    description=host_data["result"],
                    ip=host_data["ip"]
                ))
        
        # Parse credentials
        cred_pattern = r"(\S+):(\d+):([a-fA-F0-9]+:[a-fA-F0-9]+)"
        for match in re.finditer(cred_pattern, output):
            cred = {
                "username": match.group(1),
                "rid": match.group(2),
                "hash": match.group(3)
            }
            raw_data["credentials"].append(cred)
            
            findings.append(self._create_finding(
                title=f"Credential Extracted: {cred['username']}",
                severity="critical",
                description=f"Hash captured for {cred['username']}",
                username=cred["username"]
            ))
        
        return findings, raw_data
