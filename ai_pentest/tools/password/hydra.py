"""
Hydra Attacker Wrapper
======================

Fast network authentication cracker.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class HydraAttacker(ToolWrapper):
    """
    Hydra - Network Authentication Cracker
    
    Features:
    - Multiple protocol support
    - Parallel connections
    - Username/password lists
    - Resume capability
    """
    
    TOOL_NAME = "Hydra"
    BINARY_NAME = "hydra"
    INSTALL_HINT = "Install with: apt install hydra"
    
    INSTALL_COMMANDS = {
        "apt": "sudo apt-get install -y hydra",
        "brew": "brew install hydra",
        "dnf": "sudo dnf install -y hydra",
        "pacman": "sudo pacman -S --noconfirm hydra",
    }
    
    REQUIRES_NETWORK = True
    OFFLINE_CAPABLE = False
    
    def build_command(
        self,
        target: str,
        service: str = "ssh",
        username: Optional[str] = None,
        password: Optional[str] = None,
        user_list: Optional[str] = None,
        pass_list: Optional[str] = None,
        port: Optional[int] = None,
        threads: int = 16,
        timeout: int = 30,
        verbose: bool = False,
        exit_on_success: bool = True,
        form_params: Optional[str] = None,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        # Users
        if user_list:
            cmd.extend(["-L", user_list])
        elif username:
            cmd.extend(["-l", username])
        
        # Passwords
        if pass_list:
            cmd.extend(["-P", pass_list])
        elif password:
            cmd.extend(["-p", password])
        
        # Options
        cmd.extend(["-t", str(threads)])
        cmd.extend(["-w", str(timeout)])
        
        if verbose:
            cmd.append("-V")
        
        if exit_on_success:
            cmd.append("-f")
        
        # Service-specific
        if port:
            cmd.extend(["-s", str(port)])
        
        # Target and service
        if service == "http-post-form" and form_params:
            cmd.extend([target, f"{service}:{form_params}"])
        else:
            cmd.extend([f"{service}://{target}"])
        
        output_file = self.output_dir / f"hydra_{target.replace('.', '_')}_{service}.txt"
        cmd.extend(["-o", str(output_file)])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"credentials": [], "attempts": 0, "success": False}
        
        # Parse successful logins
        cred_pattern = r"\[(\d+)\]\[([^\]]+)\]\s+host:\s+(\S+)\s+login:\s+(\S+)\s+password:\s+(\S+)"
        for match in re.finditer(cred_pattern, output):
            cred = {
                "port": match.group(1),
                "service": match.group(2),
                "host": match.group(3),
                "username": match.group(4),
                "password": match.group(5)
            }
            raw_data["credentials"].append(cred)
            raw_data["success"] = True
            
            findings.append(self._create_finding(
                title=f"Valid Credentials: {cred['username']}:{cred['password']}",
                severity="critical",
                description=f"Service: {cred['service']} on {cred['host']}:{cred['port']}",
                evidence=f"Username: {cred['username']}, Password: {cred['password']}",
                username=cred["username"],
                remediation="Change password immediately, implement account lockout"
            ))
        
        # Parse attempts count
        attempts_match = re.search(r"(\d+)\s+valid", output)
        if attempts_match:
            raw_data["attempts"] = int(attempts_match.group(1))
        
        return findings, raw_data
