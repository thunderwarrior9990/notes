"""
Medusa Attacker Wrapper
=======================

Parallel network authentication cracker.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class MedusaAttacker(ToolWrapper):
    TOOL_NAME = "Medusa"
    BINARY_NAME = "medusa"
    INSTALL_HINT = "Install with: apt install medusa"
    
    def build_command(
        self,
        target: str,
        module: str = "ssh",
        username: Optional[str] = None,
        password: Optional[str] = None,
        user_file: Optional[str] = None,
        pass_file: Optional[str] = None,
        combo_file: Optional[str] = None,
        port: Optional[int] = None,
        threads: int = 16,
        timeout: int = 10,
        verbose: int = 0,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        cmd.extend(["-h", target])
        cmd.extend(["-M", module])
        
        if user_file:
            cmd.extend(["-U", user_file])
        elif username:
            cmd.extend(["-u", username])
        
        if pass_file:
            cmd.extend(["-P", pass_file])
        elif password:
            cmd.extend(["-p", password])
        
        if combo_file:
            cmd.extend(["-C", combo_file])
        
        if port:
            cmd.extend(["-n", str(port)])
        
        cmd.extend(["-t", str(threads)])
        cmd.extend(["-T", str(timeout)])
        
        if verbose > 0:
            cmd.append("-" + "v" * verbose)
        
        output_file = self.output_dir / f"medusa_{target}_{module}.txt"
        cmd.extend(["-O", str(output_file)])
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"credentials": [], "success": False}
        
        success_pattern = r"ACCOUNT FOUND:\s+\[([^\]]+)\]\s+Host:\s+(\S+)\s+User:\s+(\S+)\s+Password:\s+(\S+)"
        for match in re.finditer(success_pattern, output):
            cred = {
                "service": match.group(1),
                "host": match.group(2),
                "username": match.group(3),
                "password": match.group(4)
            }
            raw_data["credentials"].append(cred)
            raw_data["success"] = True
            
            findings.append(self._create_finding(
                title=f"Valid Credentials: {cred['username']}",
                severity="critical",
                description=f"Service: {cred['service']}",
                evidence=f"Password: {cred['password']}",
                username=cred["username"]
            ))
        
        return findings, raw_data
