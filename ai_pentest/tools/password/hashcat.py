"""
Hashcat Wrapper
===============

Advanced password recovery tool.
"""

import re
from typing import Dict, List, Any, Tuple, Optional

from ..base import ToolWrapper


class HashcatCracker(ToolWrapper):
    """
    Hashcat - Advanced Password Recovery
    
    Features:
    - GPU acceleration
    - Multiple attack modes
    - Extensive hash support
    - Rule engine
    """
    
    TOOL_NAME = "Hashcat"
    BINARY_NAME = "hashcat"
    INSTALL_HINT = "Install with: apt install hashcat"
    
    INSTALL_COMMANDS = {
        "apt": "sudo apt-get install -y hashcat",
        "brew": "brew install hashcat",
        "dnf": "sudo dnf install -y hashcat",
        "pacman": "sudo pacman -S --noconfirm hashcat",
    }
    
    # Password cracking is local compute
    REQUIRES_NETWORK = False
    OFFLINE_CAPABLE = True
    
    # Common hash modes
    HASH_MODES = {
        "md5": 0,
        "sha1": 100,
        "sha256": 1400,
        "sha512": 1700,
        "ntlm": 1000,
        "netntlmv1": 5500,
        "netntlmv2": 5600,
        "wpa": 22000,
        "bcrypt": 3200,
        "mysql": 300,
        "mssql": 131,
    }
    
    def build_command(
        self,
        target: str,  # Hash file or single hash
        wordlist: Optional[str] = None,
        hash_type: Optional[int] = None,
        attack_mode: int = 0,  # 0=dict, 3=brute, 6=hybrid
        rules: Optional[str] = None,
        mask: Optional[str] = None,
        outfile: Optional[str] = None,
        show: bool = False,
        force: bool = False,
        potfile_disable: bool = False,
        workload: int = 2,
        **kwargs
    ) -> List[str]:
        cmd = [self.BINARY_NAME]
        
        if show:
            cmd.append("--show")
            if hash_type:
                cmd.extend(["-m", str(hash_type)])
            cmd.append(target)
            return cmd
        
        if hash_type is not None:
            cmd.extend(["-m", str(hash_type)])
        
        cmd.extend(["-a", str(attack_mode)])
        
        if rules:
            cmd.extend(["-r", rules])
        
        if force:
            cmd.append("--force")
        
        if potfile_disable:
            cmd.append("--potfile-disable")
        
        cmd.extend(["-w", str(workload)])
        
        if outfile:
            cmd.extend(["-o", outfile])
        else:
            output_file = self.output_dir / f"hashcat_cracked.txt"
            cmd.extend(["-o", str(output_file)])
        
        cmd.append(target)
        
        if attack_mode == 0 and wordlist:
            cmd.append(wordlist)
        
        if attack_mode == 3 and mask:
            cmd.append(mask)
        
        return cmd
    
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        findings = []
        raw_data = {"cracked": [], "status": "", "speed": "", "progress": ""}
        
        # Check outfile for cracked passwords
        output_files = list(self.output_dir.glob("hashcat_cracked*.txt"))
        if output_files:
            try:
                with open(output_files[-1]) as f:
                    for line in f:
                        if ":" in line:
                            parts = line.strip().split(":")
                            if len(parts) >= 2:
                                cred = {
                                    "hash": parts[0],
                                    "password": parts[-1]
                                }
                                raw_data["cracked"].append(cred)
                                
                                findings.append(self._create_finding(
                                    title=f"Hash Cracked",
                                    severity="critical",
                                    description=f"Password: {cred['password']}",
                                    evidence=f"Hash: {cred['hash'][:20]}...",
                                    remediation="Use stronger passwords"
                                ))
            except Exception:
                pass
        
        # Parse status from output
        status_match = re.search(r"Status\.+:\s+(\w+)", output)
        if status_match:
            raw_data["status"] = status_match.group(1)
        
        speed_match = re.search(r"Speed\.+:\s+(.+)", output)
        if speed_match:
            raw_data["speed"] = speed_match.group(1)
        
        progress_match = re.search(r"Progress\.+:\s+(.+)", output)
        if progress_match:
            raw_data["progress"] = progress_match.group(1)
        
        return findings, raw_data
