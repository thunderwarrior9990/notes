"""
Base Tool Wrapper
=================

Base class for wrapping external security tools.
"""

import asyncio
import shutil
import subprocess
import os
import json
import tempfile
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from rich.console import Console

console = Console()


class ToolStatus(Enum):
    """Tool execution status"""
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    NOT_INSTALLED = "not_installed"
    ERROR = "error"
    OFFLINE_SKIPPED = "offline_skipped"


@dataclass
class ToolResult:
    """Result from tool execution"""
    tool_name: str
    command: str
    status: ToolStatus
    output: str = ""
    error: str = ""
    execution_time: float = 0.0
    findings: List[Dict[str, Any]] = field(default_factory=list)
    raw_data: Dict[str, Any] = field(default_factory=dict)
    exit_code: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "tool_name": self.tool_name,
            "command": self.command,
            "status": self.status.value,
            "output": self.output[:10000] if self.output else "",  # Limit output size
            "error": self.error,
            "execution_time": self.execution_time,
            "findings": self.findings,
            "raw_data": self.raw_data,
            "exit_code": self.exit_code,
            "timestamp": self.timestamp.isoformat(),
        }
    
    @property
    def is_success(self) -> bool:
        return self.status == ToolStatus.SUCCESS


class ToolLogger:
    """Logger for tool execution with file output"""
    
    def __init__(self, output_dir: Path, tool_name: str):
        self.output_dir = output_dir
        self.tool_name = tool_name
        self.log_dir = output_dir / "logs"
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Create log file for this tool
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.log_dir / f"{tool_name.lower()}_{timestamp}.log"
        
        # Setup file logger
        self.logger = logging.getLogger(f"tool.{tool_name}")
        self.logger.setLevel(logging.DEBUG)
        
        # File handler
        fh = logging.FileHandler(self.log_file)
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s | %(levelname)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        fh.setFormatter(formatter)
        
        # Remove existing handlers to avoid duplicates
        self.logger.handlers = []
        self.logger.addHandler(fh)
    
    def log_command(self, command: str):
        """Log the command being executed"""
        self.logger.info(f"COMMAND: {command}")
        self._write_separator()
    
    def log_output(self, output: str):
        """Log tool stdout"""
        if output:
            self.logger.info(f"STDOUT:\n{output}")
            self._write_separator()
    
    def log_error(self, error: str):
        """Log tool stderr"""
        if error:
            self.logger.warning(f"STDERR:\n{error}")
            self._write_separator()
    
    def log_result(self, result: 'ToolResult'):
        """Log the final result summary"""
        self.logger.info(f"STATUS: {result.status.value}")
        self.logger.info(f"EXIT CODE: {result.exit_code}")
        self.logger.info(f"EXECUTION TIME: {result.execution_time:.2f}s")
        self.logger.info(f"FINDINGS COUNT: {len(result.findings)}")
        if result.findings:
            self.logger.info(f"FINDINGS:\n{json.dumps(result.findings, indent=2, default=str)}")
    
    def log_info(self, message: str):
        """Log general info"""
        self.logger.info(message)
    
    def log_warning(self, message: str):
        """Log warning"""
        self.logger.warning(message)
    
    def log_debug(self, message: str):
        """Log debug info"""
        self.logger.debug(message)
    
    def _write_separator(self):
        """Write a visual separator"""
        self.logger.debug("-" * 80)
    
    def get_log_path(self) -> Path:
        """Get the path to the log file"""
        return self.log_file


class ToolWrapper(ABC):
    """
    Base class for wrapping external security tools
    
    Provides:
    - Tool availability checking
    - Auto-installation support
    - Async command execution
    - Offline mode support
    - Verbose logging to output folder
    - Output parsing
    - Finding extraction
    """
    
    # Override in subclasses
    TOOL_NAME: str = ""
    BINARY_NAME: str = ""
    INSTALL_HINT: str = ""
    
    # Installation commands for different package managers
    # Format: {"apt": "command", "brew": "command", "pip": "command", "go": "command"}
    INSTALL_COMMANDS: Dict[str, str] = {}
    
    # Whether this tool requires network access
    REQUIRES_NETWORK: bool = True
    
    # Offline-capable alternative command builder (override if tool has offline mode)
    OFFLINE_CAPABLE: bool = False
    
    def __init__(
        self,
        timeout: int = 300,
        output_dir: Optional[str] = None,
        verbose: bool = False,
        offline_mode: bool = False,
        auto_install: bool = False
    ):
        self.timeout = timeout
        self.output_dir = Path(output_dir) if output_dir else Path(tempfile.gettempdir()) / "ai_pentest"
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.verbose = verbose
        self.offline_mode = offline_mode
        self.auto_install = auto_install
        self._binary_path: Optional[str] = None
        self._logger: Optional[ToolLogger] = None
    
    def _get_logger(self) -> ToolLogger:
        """Get or create logger for this tool"""
        if self._logger is None:
            self._logger = ToolLogger(self.output_dir, self.TOOL_NAME)
        return self._logger
    
    @property
    def is_installed(self) -> bool:
        """Check if the tool is installed"""
        return self.get_binary_path() is not None
    
    def get_binary_path(self) -> Optional[str]:
        """Get the path to the tool binary"""
        if self._binary_path:
            return self._binary_path
        
        self._binary_path = shutil.which(self.BINARY_NAME)
        return self._binary_path
    
    def check_installation(self) -> Tuple[bool, str]:
        """Check if tool is installed and return status message"""
        if self.is_installed:
            return True, f"{self.TOOL_NAME} found at {self.get_binary_path()}"
        return False, f"{self.TOOL_NAME} not found. {self.INSTALL_HINT}"
    
    def _detect_package_manager(self) -> Optional[str]:
        """Detect which package manager is available"""
        # Check for common package managers in order of preference
        if shutil.which("apt-get") or shutil.which("apt"):
            return "apt"
        elif shutil.which("brew"):
            return "brew"
        elif shutil.which("dnf"):
            return "dnf"
        elif shutil.which("yum"):
            return "yum"
        elif shutil.which("pacman"):
            return "pacman"
        elif shutil.which("pip3") or shutil.which("pip"):
            return "pip"
        return None
    
    def get_install_command(self) -> Optional[str]:
        """Get the installation command for the current system"""
        pkg_manager = self._detect_package_manager()
        
        if not pkg_manager:
            return None
        
        # Check tool-specific install commands first
        if pkg_manager in self.INSTALL_COMMANDS:
            return self.INSTALL_COMMANDS[pkg_manager]
        
        # Default install commands by package manager
        default_commands = {
            "apt": f"sudo apt-get install -y {self.BINARY_NAME}",
            "brew": f"brew install {self.BINARY_NAME}",
            "dnf": f"sudo dnf install -y {self.BINARY_NAME}",
            "yum": f"sudo yum install -y {self.BINARY_NAME}",
            "pacman": f"sudo pacman -S --noconfirm {self.BINARY_NAME}",
        }
        
        return default_commands.get(pkg_manager)
    
    def install(self) -> Tuple[bool, str]:
        """
        Attempt to install the tool
        
        Returns:
            Tuple of (success, message)
        """
        if self.is_installed:
            return True, f"{self.TOOL_NAME} is already installed"
        
        install_cmd = self.get_install_command()
        
        if not install_cmd:
            return False, f"No installation method found for {self.TOOL_NAME}. {self.INSTALL_HINT}"
        
        logger = self._get_logger()
        logger.log_info(f"Attempting to install {self.TOOL_NAME}")
        logger.log_command(install_cmd)
        
        console.print(f"[yellow]Installing {self.TOOL_NAME}...[/yellow]")
        console.print(f"[dim]Running: {install_cmd}[/dim]")
        
        try:
            # Run installation command
            result = subprocess.run(
                install_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout for installation
            )
            
            logger.log_output(result.stdout)
            if result.stderr:
                logger.log_error(result.stderr)
            
            if result.returncode == 0:
                # Clear cached binary path and recheck
                self._binary_path = None
                if self.is_installed:
                    msg = f"Successfully installed {self.TOOL_NAME}"
                    logger.log_info(msg)
                    console.print(f"[green]✓ {msg}[/green]")
                    return True, msg
                else:
                    msg = f"Installation completed but {self.TOOL_NAME} not found in PATH"
                    logger.log_warning(msg)
                    return False, msg
            else:
                msg = f"Installation failed: {result.stderr or result.stdout}"
                logger.log_error(msg)
                console.print(f"[red]✗ {msg}[/red]")
                return False, msg
                
        except subprocess.TimeoutExpired:
            msg = f"Installation timed out for {self.TOOL_NAME}"
            logger.log_error(msg)
            return False, msg
        except Exception as e:
            msg = f"Installation error: {str(e)}"
            logger.log_error(msg)
            return False, msg
    
    @abstractmethod
    def build_command(self, target: str, **kwargs) -> List[str]:
        """Build the command to execute"""
        pass
    
    def build_offline_command(self, target: str, **kwargs) -> Optional[List[str]]:
        """
        Build command for offline mode (override in subclasses)
        
        Returns None if tool cannot run offline
        """
        if self.OFFLINE_CAPABLE:
            return self.build_command(target, **kwargs)
        return None
    
    @abstractmethod
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Parse tool output into findings and raw data
        
        Returns:
            Tuple of (findings list, raw data dict)
        """
        pass
    
    async def run(
        self,
        target: str,
        **kwargs
    ) -> ToolResult:
        """
        Execute the tool asynchronously
        
        Args:
            target: Target to scan
            **kwargs: Tool-specific arguments
            
        Returns:
            ToolResult with findings
        """
        logger = self._get_logger()
        logger.log_info(f"Starting {self.TOOL_NAME} against target: {target}")
        logger.log_info(f"Options: {kwargs}")
        logger.log_info(f"Offline mode: {self.offline_mode}")
        
        # Check offline mode
        if self.offline_mode and self.REQUIRES_NETWORK and not self.OFFLINE_CAPABLE:
            msg = f"{self.TOOL_NAME} requires network access and cannot run in offline mode"
            logger.log_warning(msg)
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command="",
                status=ToolStatus.OFFLINE_SKIPPED,
                error=msg
            )
        
        # Check if installed, attempt installation if auto_install is enabled
        if not self.is_installed:
            if self.auto_install:
                logger.log_info(f"Tool not installed, attempting auto-installation")
                success, msg = self.install()
                if not success:
                    return ToolResult(
                        tool_name=self.TOOL_NAME,
                        command="",
                        status=ToolStatus.NOT_INSTALLED,
                        error=f"{self.TOOL_NAME} is not installed and auto-installation failed. {msg}"
                    )
            else:
                return ToolResult(
                    tool_name=self.TOOL_NAME,
                    command="",
                    status=ToolStatus.NOT_INSTALLED,
                    error=f"{self.TOOL_NAME} is not installed. {self.INSTALL_HINT}"
                )
        
        # Build command (use offline variant if applicable)
        if self.offline_mode and self.OFFLINE_CAPABLE:
            cmd = self.build_offline_command(target, **kwargs)
            if cmd is None:
                return ToolResult(
                    tool_name=self.TOOL_NAME,
                    command="",
                    status=ToolStatus.OFFLINE_SKIPPED,
                    error=f"{self.TOOL_NAME} cannot build offline command"
                )
        else:
            cmd = self.build_command(target, **kwargs)
        
        cmd_str = " ".join(cmd)
        
        # Log command
        logger.log_command(cmd_str)
        
        if self.verbose:
            console.print(f"[dim]Executing: {cmd_str}[/dim]")
        
        start_time = datetime.now()
        
        try:
            # Execute command
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(self.output_dir)
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=self.timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                result = ToolResult(
                    tool_name=self.TOOL_NAME,
                    command=cmd_str,
                    status=ToolStatus.TIMEOUT,
                    error=f"Command timed out after {self.timeout} seconds",
                    execution_time=(datetime.now() - start_time).total_seconds()
                )
                logger.log_error(f"Timeout after {self.timeout}s")
                logger.log_result(result)
                return result
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            output = stdout.decode("utf-8", errors="ignore")
            error = stderr.decode("utf-8", errors="ignore")
            
            # Log output
            logger.log_output(output)
            if error:
                logger.log_error(error)
            
            # Parse output
            findings, raw_data = self.parse_output(output, error)
            
            # Determine status
            if process.returncode == 0:
                status = ToolStatus.SUCCESS
            else:
                status = ToolStatus.ERROR if error else ToolStatus.SUCCESS
            
            result = ToolResult(
                tool_name=self.TOOL_NAME,
                command=cmd_str,
                status=status,
                output=output,
                error=error,
                execution_time=execution_time,
                findings=findings,
                raw_data=raw_data,
                exit_code=process.returncode
            )
            
            # Log result
            logger.log_result(result)
            
            # Save full output to dedicated file
            self._save_tool_output(target, result)
            
            return result
            
        except Exception as e:
            error_msg = str(e)
            logger.log_error(f"Exception: {error_msg}")
            result = ToolResult(
                tool_name=self.TOOL_NAME,
                command=cmd_str,
                status=ToolStatus.ERROR,
                error=error_msg,
                execution_time=(datetime.now() - start_time).total_seconds()
            )
            logger.log_result(result)
            return result
    
    def _save_tool_output(self, target: str, result: ToolResult):
        """Save tool output to a dedicated file"""
        output_subdir = self.output_dir / "tool_outputs"
        output_subdir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_target = target.replace("/", "_").replace(":", "_").replace(".", "_")
        output_file = output_subdir / f"{self.TOOL_NAME.lower()}_{safe_target}_{timestamp}.json"
        
        try:
            with open(output_file, "w") as f:
                json.dump(result.to_dict(), f, indent=2, default=str)
        except Exception as e:
            if self.verbose:
                console.print(f"[yellow]Warning: Could not save output file: {e}[/yellow]")
    
    def run_sync(self, target: str, **kwargs) -> ToolResult:
        """Synchronous wrapper for run()"""
        return asyncio.run(self.run(target, **kwargs))
    
    def _extract_json_output(self, output: str) -> Optional[Dict[str, Any]]:
        """Try to extract JSON from output"""
        try:
            return json.loads(output)
        except json.JSONDecodeError:
            # Try to find JSON in output
            import re
            json_match = re.search(r'\{.*\}', output, re.DOTALL)
            if json_match:
                try:
                    return json.loads(json_match.group())
                except json.JSONDecodeError:
                    pass
            
            # Try JSON array
            json_match = re.search(r'\[.*\]', output, re.DOTALL)
            if json_match:
                try:
                    return {"items": json.loads(json_match.group())}
                except json.JSONDecodeError:
                    pass
        
        return None
    
    def _severity_from_cvss(self, cvss: float) -> str:
        """Convert CVSS score to severity level"""
        if cvss >= 9.0:
            return "critical"
        elif cvss >= 7.0:
            return "high"
        elif cvss >= 4.0:
            return "medium"
        elif cvss >= 0.1:
            return "low"
        return "info"
    
    def _create_finding(
        self,
        title: str,
        severity: str = "info",
        description: str = "",
        evidence: str = "",
        remediation: str = "",
        **kwargs
    ) -> Dict[str, Any]:
        """Create a standardized finding dict"""
        return {
            "title": title,
            "severity": severity,
            "description": description,
            "evidence": evidence,
            "remediation": remediation,
            "tool": self.TOOL_NAME,
            "timestamp": datetime.now().isoformat(),
            **kwargs
        }
