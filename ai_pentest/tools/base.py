"""
Base Tool Wrapper
=================

Base class for wrapping external security tools.
"""

import asyncio
import shutil
import subprocess
import os
import json
import tempfile
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from rich.console import Console

console = Console()


class ToolStatus(Enum):
    """Tool execution status"""
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    NOT_INSTALLED = "not_installed"
    ERROR = "error"


@dataclass
class ToolResult:
    """Result from tool execution"""
    tool_name: str
    command: str
    status: ToolStatus
    output: str = ""
    error: str = ""
    execution_time: float = 0.0
    findings: List[Dict[str, Any]] = field(default_factory=list)
    raw_data: Dict[str, Any] = field(default_factory=dict)
    exit_code: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "tool_name": self.tool_name,
            "command": self.command,
            "status": self.status.value,
            "output": self.output[:10000] if self.output else "",  # Limit output size
            "error": self.error,
            "execution_time": self.execution_time,
            "findings": self.findings,
            "raw_data": self.raw_data,
            "exit_code": self.exit_code,
            "timestamp": self.timestamp.isoformat(),
        }
    
    @property
    def is_success(self) -> bool:
        return self.status == ToolStatus.SUCCESS


class ToolWrapper(ABC):
    """
    Base class for wrapping external security tools
    
    Provides:
    - Tool availability checking
    - Async command execution
    - Output parsing
    - Finding extraction
    """
    
    # Override in subclasses
    TOOL_NAME: str = ""
    BINARY_NAME: str = ""
    INSTALL_HINT: str = ""
    
    def __init__(
        self,
        timeout: int = 300,
        output_dir: Optional[str] = None,
        verbose: bool = False
    ):
        self.timeout = timeout
        self.output_dir = Path(output_dir) if output_dir else Path(tempfile.gettempdir()) / "ai_pentest"
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.verbose = verbose
        self._binary_path: Optional[str] = None
    
    @property
    def is_installed(self) -> bool:
        """Check if the tool is installed"""
        return self.get_binary_path() is not None
    
    def get_binary_path(self) -> Optional[str]:
        """Get the path to the tool binary"""
        if self._binary_path:
            return self._binary_path
        
        self._binary_path = shutil.which(self.BINARY_NAME)
        return self._binary_path
    
    def check_installation(self) -> Tuple[bool, str]:
        """Check if tool is installed and return status message"""
        if self.is_installed:
            return True, f"{self.TOOL_NAME} found at {self.get_binary_path()}"
        return False, f"{self.TOOL_NAME} not found. {self.INSTALL_HINT}"
    
    @abstractmethod
    def build_command(self, target: str, **kwargs) -> List[str]:
        """Build the command to execute"""
        pass
    
    @abstractmethod
    def parse_output(self, output: str, error: str) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Parse tool output into findings and raw data
        
        Returns:
            Tuple of (findings list, raw data dict)
        """
        pass
    
    async def run(
        self,
        target: str,
        **kwargs
    ) -> ToolResult:
        """
        Execute the tool asynchronously
        
        Args:
            target: Target to scan
            **kwargs: Tool-specific arguments
            
        Returns:
            ToolResult with findings
        """
        # Check if installed
        if not self.is_installed:
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command="",
                status=ToolStatus.NOT_INSTALLED,
                error=f"{self.TOOL_NAME} is not installed. {self.INSTALL_HINT}"
            )
        
        # Build command
        cmd = self.build_command(target, **kwargs)
        cmd_str = " ".join(cmd)
        
        if self.verbose:
            console.print(f"[dim]Executing: {cmd_str}[/dim]")
        
        start_time = datetime.now()
        
        try:
            # Execute command
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(self.output_dir)
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=self.timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                return ToolResult(
                    tool_name=self.TOOL_NAME,
                    command=cmd_str,
                    status=ToolStatus.TIMEOUT,
                    error=f"Command timed out after {self.timeout} seconds",
                    execution_time=(datetime.now() - start_time).total_seconds()
                )
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            output = stdout.decode("utf-8", errors="ignore")
            error = stderr.decode("utf-8", errors="ignore")
            
            # Parse output
            findings, raw_data = self.parse_output(output, error)
            
            # Determine status
            if process.returncode == 0:
                status = ToolStatus.SUCCESS
            else:
                status = ToolStatus.ERROR if error else ToolStatus.SUCCESS
            
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command=cmd_str,
                status=status,
                output=output,
                error=error,
                execution_time=execution_time,
                findings=findings,
                raw_data=raw_data,
                exit_code=process.returncode
            )
            
        except Exception as e:
            return ToolResult(
                tool_name=self.TOOL_NAME,
                command=cmd_str,
                status=ToolStatus.ERROR,
                error=str(e),
                execution_time=(datetime.now() - start_time).total_seconds()
            )
    
    def run_sync(self, target: str, **kwargs) -> ToolResult:
        """Synchronous wrapper for run()"""
        return asyncio.run(self.run(target, **kwargs))
    
    def _extract_json_output(self, output: str) -> Optional[Dict[str, Any]]:
        """Try to extract JSON from output"""
        try:
            return json.loads(output)
        except json.JSONDecodeError:
            # Try to find JSON in output
            import re
            json_match = re.search(r'\{.*\}', output, re.DOTALL)
            if json_match:
                try:
                    return json.loads(json_match.group())
                except json.JSONDecodeError:
                    pass
            
            # Try JSON array
            json_match = re.search(r'\[.*\]', output, re.DOTALL)
            if json_match:
                try:
                    return {"items": json.loads(json_match.group())}
                except json.JSONDecodeError:
                    pass
        
        return None
    
    def _severity_from_cvss(self, cvss: float) -> str:
        """Convert CVSS score to severity level"""
        if cvss >= 9.0:
            return "critical"
        elif cvss >= 7.0:
            return "high"
        elif cvss >= 4.0:
            return "medium"
        elif cvss >= 0.1:
            return "low"
        return "info"
    
    def _create_finding(
        self,
        title: str,
        severity: str = "info",
        description: str = "",
        evidence: str = "",
        remediation: str = "",
        **kwargs
    ) -> Dict[str, Any]:
        """Create a standardized finding dict"""
        return {
            "title": title,
            "severity": severity,
            "description": description,
            "evidence": evidence,
            "remediation": remediation,
            "tool": self.TOOL_NAME,
            "timestamp": datetime.now().isoformat(),
            **kwargs
        }
