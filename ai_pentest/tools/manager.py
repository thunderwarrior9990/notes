"""
Tool Manager
============

Orchestrates all security tools with AI-enhanced analysis.
"""

import asyncio
import json
from typing import Dict, List, Optional, Any, Type
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn

from .base import ToolWrapper, ToolResult, ToolStatus
from ..ai.cursor_client import CursorAIClient
from ..reports.generator import Finding


console = Console()


@dataclass
class ToolCategory:
    """Category of tools"""
    name: str
    description: str
    tools: List[Type[ToolWrapper]]


@dataclass
class ToolScanResult:
    """Result from running multiple tools"""
    target: str
    start_time: datetime
    end_time: Optional[datetime] = None
    tool_results: List[ToolResult] = field(default_factory=list)
    findings: List[Finding] = field(default_factory=list)
    ai_analysis: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "tool_results": [r.to_dict() for r in self.tool_results],
            "findings": [f.to_dict() for f in self.findings],
            "ai_analysis": self.ai_analysis,
            "summary": {
                "total_tools": len(self.tool_results),
                "successful": sum(1 for r in self.tool_results if r.is_success),
                "total_findings": len(self.findings)
            }
        }


class ToolManager:
    """
    Tool Manager - Orchestrate security tools
    
    Features:
    - Tool availability checking
    - Auto-installation of missing tools
    - Parallel tool execution
    - Offline mode support
    - Verbose logging to output folder
    - Result aggregation
    - AI-enhanced analysis
    - Finding consolidation
    """
    
    # Tool categories with their tools
    NETWORK_TOOLS = [
        "NmapScanner", "MasscanScanner", "RustscanScanner",
        "AmassEnumerator", "SubfinderEnumerator", "NucleiScanner",
        "FierceScanner", "DnsenumScanner", "AutoreconScanner",
        "TheHarvesterScanner", "ResponderTool", "NetexecScanner",
        "Enum4linuxScanner"
    ]
    
    WEB_TOOLS = [
        "GobusterScanner", "FeroxbusterScanner", "DirsearchScanner",
        "FfufScanner", "DirbScanner", "HttpxScanner", "KatanaCrawler",
        "NiktoScanner", "SqlmapScanner", "WpscanScanner",
        "ArjunScanner", "ParamspiderScanner", "DalfoxScanner",
        "Wafw00fScanner"
    ]
    
    PASSWORD_TOOLS = [
        "HydraAttacker", "JohnCracker", "HashcatCracker",
        "MedusaAttacker", "PatatorAttacker", "CrackmapexecScanner",
        "EvilWinrmShell", "HashIdentifier"
    ]
    
    BINARY_TOOLS = [
        "GdbAnalyzer", "Radare2Analyzer", "BinwalkAnalyzer",
        "ChecksecAnalyzer", "StringsExtractor", "ObjdumpAnalyzer",
        "Volatility3Analyzer", "ForemostCarver", "SteghideExtractor",
        "ExiftoolAnalyzer"
    ]
    
    CLOUD_TOOLS = [
        "ProwlerScanner", "ScoutSuiteScanner", "TrivyScanner",
        "KubeHunterScanner", "KubeBenchScanner", "DockerBenchScanner"
    ]
    
    def __init__(
        self,
        output_dir: Optional[str] = None,
        use_ai: bool = True,
        verbose: bool = False,
        offline_mode: bool = False,
        auto_install: bool = False
    ):
        self.output_dir = Path(output_dir) if output_dir else Path("./tool_output")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.use_ai = use_ai
        self.verbose = verbose
        self.offline_mode = offline_mode
        self.auto_install = auto_install
        self._tools: Dict[str, ToolWrapper] = {}
        self._ai_client: Optional[CursorAIClient] = None
        
        # Setup manager log
        self._setup_manager_log()
    
    def _setup_manager_log(self):
        """Setup the manager log file"""
        self.log_dir = self.output_dir / "logs"
        self.log_dir.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.manager_log = self.log_dir / f"manager_{timestamp}.log"
    
    def _log(self, message: str, level: str = "INFO"):
        """Write to manager log"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_line = f"{timestamp} | {level} | {message}\n"
        try:
            with open(self.manager_log, "a") as f:
                f.write(log_line)
        except Exception:
            pass  # Don't fail on logging errors
    
    def _get_tool_class(self, tool_name: str) -> Optional[Type[ToolWrapper]]:
        """Get tool class by name"""
        # Import all tools dynamically
        try:
            if tool_name in self.NETWORK_TOOLS:
                from . import network
                return getattr(network, tool_name, None)
            elif tool_name in self.WEB_TOOLS:
                from . import web
                return getattr(web, tool_name, None)
            elif tool_name in self.PASSWORD_TOOLS:
                from . import password
                return getattr(password, tool_name, None)
            elif tool_name in self.BINARY_TOOLS:
                from . import binary
                return getattr(binary, tool_name, None)
            elif tool_name in self.CLOUD_TOOLS:
                from . import cloud
                return getattr(cloud, tool_name, None)
        except (ImportError, AttributeError):
            pass
        return None
    
    def get_tool(self, tool_name: str) -> Optional[ToolWrapper]:
        """Get or create a tool instance"""
        if tool_name not in self._tools:
            tool_class = self._get_tool_class(tool_name)
            if tool_class:
                self._tools[tool_name] = tool_class(
                    output_dir=str(self.output_dir),
                    verbose=self.verbose,
                    offline_mode=self.offline_mode,
                    auto_install=self.auto_install
                )
        return self._tools.get(tool_name)
    
    def check_installed_tools(self, attempt_install: bool = None) -> Dict[str, Dict[str, Any]]:
        """
        Check which tools are installed and optionally install missing ones
        
        Args:
            attempt_install: Whether to attempt installing missing tools (uses self.auto_install if None)
        """
        if attempt_install is None:
            attempt_install = self.auto_install
        
        all_tools = (
            self.NETWORK_TOOLS + self.WEB_TOOLS + 
            self.PASSWORD_TOOLS + self.BINARY_TOOLS + 
            self.CLOUD_TOOLS
        )
        
        results = {}
        installed_count = 0
        install_attempted = 0
        install_success = 0
        
        console.print("\n[bold cyan]Checking installed tools...[/bold cyan]\n")
        self._log("Starting tool availability check")
        
        for tool_name in all_tools:
            tool = self.get_tool(tool_name)
            if tool:
                installed, message = tool.check_installation()
                
                # Attempt installation if not installed and auto_install is enabled
                if not installed and attempt_install:
                    install_attempted += 1
                    self._log(f"Attempting to install {tool_name}")
                    success, install_msg = tool.install()
                    if success:
                        installed = True
                        install_success += 1
                        message = f"Installed: {install_msg}"
                    else:
                        message = f"Installation failed: {install_msg}"
                
                if installed:
                    installed_count += 1
                
                results[tool_name] = {
                    "installed": installed,
                    "message": message,
                    "binary": tool.BINARY_NAME,
                    "requires_network": tool.REQUIRES_NETWORK,
                    "offline_capable": tool.OFFLINE_CAPABLE
                }
                
                self._log(f"{tool_name}: {'installed' if installed else 'missing'}")
        
        # Display results
        table = Table(title="Tool Availability")
        table.add_column("Tool", style="cyan")
        table.add_column("Binary", style="white")
        table.add_column("Status", style="white")
        table.add_column("Network", style="white")
        
        for name, info in sorted(results.items()):
            status = "[green]✓ Installed[/green]" if info["installed"] else "[red]✗ Missing[/red]"
            network = "[yellow]Required[/yellow]" if info["requires_network"] else "[green]Offline OK[/green]"
            if info["offline_capable"]:
                network = "[green]Offline Capable[/green]"
            table.add_row(name, info["binary"], status, network)
        
        console.print(table)
        console.print(f"\n[bold]Installed: {installed_count}/{len(results)}[/bold]")
        
        if install_attempted > 0:
            console.print(f"[bold]Auto-installed: {install_success}/{install_attempted}[/bold]")
        
        # Log summary
        self._log(f"Tool check complete: {installed_count}/{len(results)} installed")
        if install_attempted > 0:
            self._log(f"Auto-installation: {install_success}/{install_attempted} successful")
        
        # Save results to file
        self._save_tool_status(results)
        
        return results
    
    def _save_tool_status(self, results: Dict[str, Dict[str, Any]]):
        """Save tool status to a JSON file"""
        status_file = self.output_dir / "tool_status.json"
        try:
            with open(status_file, "w") as f:
                json.dump({
                    "timestamp": datetime.now().isoformat(),
                    "offline_mode": self.offline_mode,
                    "auto_install": self.auto_install,
                    "tools": results
                }, f, indent=2)
        except Exception as e:
            self._log(f"Failed to save tool status: {e}", "ERROR")
    
    async def run_tool(
        self,
        tool_name: str,
        target: str,
        **kwargs
    ) -> Optional[ToolResult]:
        """Run a single tool"""
        tool = self.get_tool(tool_name)
        if not tool:
            console.print(f"[red]Tool not found: {tool_name}[/red]")
            self._log(f"Tool not found: {tool_name}", "ERROR")
            return None
        
        self._log(f"Running {tool.TOOL_NAME} against {target}")
        console.print(f"[cyan]Running {tool.TOOL_NAME}...[/cyan]")
        
        result = await tool.run(target, **kwargs)
        
        if result.is_success:
            console.print(f"[green]✓[/green] {tool.TOOL_NAME} completed - {len(result.findings)} findings")
            self._log(f"{tool.TOOL_NAME} completed: {len(result.findings)} findings")
        elif result.status == ToolStatus.OFFLINE_SKIPPED:
            console.print(f"[yellow]⊘[/yellow] {tool.TOOL_NAME}: Skipped (offline mode)")
            self._log(f"{tool.TOOL_NAME} skipped: offline mode")
        elif result.status == ToolStatus.NOT_INSTALLED:
            console.print(f"[red]✗[/red] {tool.TOOL_NAME}: Not installed")
            self._log(f"{tool.TOOL_NAME} not installed", "WARNING")
        else:
            console.print(f"[yellow]⚠[/yellow] {tool.TOOL_NAME}: {result.status.value}")
            self._log(f"{tool.TOOL_NAME}: {result.status.value}", "WARNING")
        
        return result
    
    async def run_category(
        self,
        category: str,
        target: str,
        parallel: bool = True,
        **kwargs
    ) -> ToolScanResult:
        """Run all tools in a category"""
        category_tools = {
            "network": self.NETWORK_TOOLS,
            "web": self.WEB_TOOLS,
            "password": self.PASSWORD_TOOLS,
            "binary": self.BINARY_TOOLS,
            "cloud": self.CLOUD_TOOLS,
        }
        
        tools = category_tools.get(category.lower(), [])
        if not tools:
            console.print(f"[red]Unknown category: {category}[/red]")
            self._log(f"Unknown category: {category}", "ERROR")
            return ToolScanResult(target=target, start_time=datetime.now())
        
        console.print(f"\n[bold cyan]Running {category.upper()} tools against {target}[/bold cyan]\n")
        self._log(f"Starting {category} category scan on {target}")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        if parallel:
            # Run tools in parallel
            tasks = []
            for tool_name in tools:
                tool = self.get_tool(tool_name)
                if tool:
                    # Check if tool can run (installed or will auto-install, and not blocked by offline mode)
                    can_run = tool.is_installed or self.auto_install
                    if self.offline_mode and tool.REQUIRES_NETWORK and not tool.OFFLINE_CAPABLE:
                        can_run = False
                    if can_run:
                        tasks.append(self.run_tool(tool_name, target, **kwargs))
            
            if tasks:
                results = await asyncio.gather(*tasks, return_exceptions=True)
                for result in results:
                    if isinstance(result, ToolResult):
                        scan_result.tool_results.append(result)
                        scan_result.findings.extend(
                            self._convert_to_findings(result)
                        )
        else:
            # Run sequentially
            for tool_name in tools:
                tool = self.get_tool(tool_name)
                if tool:
                    can_run = tool.is_installed or self.auto_install
                    if self.offline_mode and tool.REQUIRES_NETWORK and not tool.OFFLINE_CAPABLE:
                        can_run = False
                    if can_run:
                        result = await self.run_tool(tool_name, target, **kwargs)
                        if result:
                            scan_result.tool_results.append(result)
                            scan_result.findings.extend(
                                self._convert_to_findings(result)
                            )
        
        scan_result.end_time = datetime.now()
        
        # Log summary
        self._log(f"Category {category} complete: {len(scan_result.tool_results)} tools, {len(scan_result.findings)} findings")
        
        # AI analysis
        if self.use_ai and scan_result.findings:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        # Save scan result
        self._save_scan_result(category, scan_result)
        
        return scan_result
    
    def _save_scan_result(self, category: str, scan_result: ToolScanResult):
        """Save scan result to a JSON file"""
        results_dir = self.output_dir / "scan_results"
        results_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_target = scan_result.target.replace("/", "_").replace(":", "_").replace(".", "_")
        result_file = results_dir / f"{category}_{safe_target}_{timestamp}.json"
        
        try:
            with open(result_file, "w") as f:
                json.dump(scan_result.to_dict(), f, indent=2, default=str)
            self._log(f"Saved scan result to {result_file}")
        except Exception as e:
            self._log(f"Failed to save scan result: {e}", "ERROR")
    
    async def run_recon(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        **kwargs
    ) -> ToolScanResult:
        """Run reconnaissance tools"""
        if tools is None:
            tools = ["NmapScanner", "SubfinderEnumerator", "HttpxScanner", "NucleiScanner"]
        
        console.print(f"\n[bold cyan]═══ Reconnaissance: {target} ═══[/bold cyan]\n")
        self._log(f"Starting reconnaissance on {target}")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        for tool_name in tools:
            result = await self.run_tool(tool_name, target, **kwargs)
            if result:
                scan_result.tool_results.append(result)
                scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai and scan_result.findings:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        self._save_scan_result("recon", scan_result)
        
        return scan_result
    
    async def run_web_scan(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        **kwargs
    ) -> ToolScanResult:
        """Run web application scanning tools"""
        if tools is None:
            tools = ["HttpxScanner", "NiktoScanner", "GobusterScanner", "NucleiScanner", "Wafw00fScanner"]
        
        console.print(f"\n[bold cyan]═══ Web Scan: {target} ═══[/bold cyan]\n")
        self._log(f"Starting web scan on {target}")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        for tool_name in tools:
            result = await self.run_tool(tool_name, target, **kwargs)
            if result:
                scan_result.tool_results.append(result)
                scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        self._save_scan_result("web", scan_result)
        
        return scan_result
    
    async def run_vuln_scan(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        **kwargs
    ) -> ToolScanResult:
        """Run vulnerability scanning tools"""
        if tools is None:
            tools = ["NucleiScanner", "NiktoScanner", "SqlmapScanner", "DalfoxScanner"]
        
        console.print(f"\n[bold cyan]═══ Vulnerability Scan: {target} ═══[/bold cyan]\n")
        self._log(f"Starting vulnerability scan on {target}")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        for tool_name in tools:
            result = await self.run_tool(tool_name, target, **kwargs)
            if result:
                scan_result.tool_results.append(result)
                scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        self._save_scan_result("vuln", scan_result)
        
        return scan_result
    
    def _convert_to_findings(self, result: ToolResult) -> List[Finding]:
        """Convert tool findings to report findings"""
        findings = []
        
        for i, f in enumerate(result.findings):
            findings.append(Finding(
                id=f"{result.tool_name.upper()[:3]}-{i+1:03d}",
                title=f.get("title", "Unknown Finding"),
                severity=f.get("severity", "info"),
                category=result.tool_name,
                description=f.get("description", ""),
                impact=self._get_impact(f.get("severity", "info")),
                remediation=f.get("remediation", ""),
                evidence=f.get("evidence", ""),
                url=f.get("url", ""),
                parameter=f.get("parameter", ""),
                cwe_id=f.get("cwe_id", ""),
                cvss_score=f.get("cvss_score", 0.0),
            ))
        
        return findings
    
    def _get_impact(self, severity: str) -> str:
        """Get impact description based on severity"""
        impacts = {
            "critical": "Complete system compromise possible",
            "high": "Significant security risk requiring immediate attention",
            "medium": "Moderate security risk that should be addressed",
            "low": "Minor security concern",
            "info": "Informational finding",
        }
        return impacts.get(severity.lower(), impacts["info"])
    
    async def _analyze_results(self, scan_result: ToolScanResult) -> str:
        """Analyze results with AI"""
        if not self._ai_client:
            self._ai_client = CursorAIClient()
            await self._ai_client._init_client()
        
        console.print("\n[cyan]Analyzing results with AI...[/cyan]")
        self._log("Starting AI analysis")
        
        # Prepare summary for AI
        summary = {
            "target": scan_result.target,
            "tools_run": len(scan_result.tool_results),
            "total_findings": len(scan_result.findings),
            "findings_by_severity": {},
            "top_findings": []
        }
        
        for finding in scan_result.findings:
            sev = finding.severity
            summary["findings_by_severity"][sev] = summary["findings_by_severity"].get(sev, 0) + 1
        
        # Get top findings
        critical_high = [f for f in scan_result.findings if f.severity in ["critical", "high"]]
        summary["top_findings"] = [
            {"title": f.title, "severity": f.severity, "description": f.description[:200]}
            for f in critical_high[:5]
        ]
        
        response = await self._ai_client.analyze(
            prompt="Analyze these penetration test results and provide a summary with key findings and recommendations.",
            context=summary
        )
        
        self._log("AI analysis complete")
        
        return response.content
    
    async def close(self):
        """Close resources"""
        if self._ai_client:
            await self._ai_client.close()
        self._log("Tool manager closed")
