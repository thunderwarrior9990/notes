"""
Tool Manager
============

Orchestrates all security tools with AI-enhanced analysis.
"""

import asyncio
from typing import Dict, List, Optional, Any, Type
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn

from .base import ToolWrapper, ToolResult, ToolStatus
from ..ai.cursor_client import CursorAIClient
from ..reports.generator import Finding


console = Console()


@dataclass
class ToolCategory:
    """Category of tools"""
    name: str
    description: str
    tools: List[Type[ToolWrapper]]


@dataclass
class ToolScanResult:
    """Result from running multiple tools"""
    target: str
    start_time: datetime
    end_time: Optional[datetime] = None
    tool_results: List[ToolResult] = field(default_factory=list)
    findings: List[Finding] = field(default_factory=list)
    ai_analysis: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "tool_results": [r.to_dict() for r in self.tool_results],
            "findings": [f.to_dict() for f in self.findings],
            "ai_analysis": self.ai_analysis,
            "summary": {
                "total_tools": len(self.tool_results),
                "successful": sum(1 for r in self.tool_results if r.is_success),
                "total_findings": len(self.findings)
            }
        }


class ToolManager:
    """
    Tool Manager - Orchestrate security tools
    
    Features:
    - Tool availability checking
    - Parallel tool execution
    - Result aggregation
    - AI-enhanced analysis
    - Finding consolidation
    """
    
    # Tool categories with their tools
    NETWORK_TOOLS = [
        "NmapScanner", "MasscanScanner", "RustscanScanner",
        "AmassEnumerator", "SubfinderEnumerator", "NucleiScanner",
        "FierceScanner", "DnsenumScanner", "AutoreconScanner",
        "TheHarvesterScanner", "ResponderTool", "NetexecScanner",
        "Enum4linuxScanner"
    ]
    
    WEB_TOOLS = [
        "GobusterScanner", "FeroxbusterScanner", "DirsearchScanner",
        "FfufScanner", "DirbScanner", "HttpxScanner", "KatanaCrawler",
        "NiktoScanner", "SqlmapScanner", "WpscanScanner",
        "ArjunScanner", "ParamspiderScanner", "DalfoxScanner",
        "Wafw00fScanner"
    ]
    
    PASSWORD_TOOLS = [
        "HydraAttacker", "JohnCracker", "HashcatCracker",
        "MedusaAttacker", "PatatorAttacker", "CrackmapexecScanner",
        "EvilWinrmShell", "HashIdentifier"
    ]
    
    BINARY_TOOLS = [
        "GdbAnalyzer", "Radare2Analyzer", "BinwalkAnalyzer",
        "ChecksecAnalyzer", "StringsExtractor", "ObjdumpAnalyzer",
        "Volatility3Analyzer", "ForemostCarver", "SteghideExtractor",
        "ExiftoolAnalyzer"
    ]
    
    CLOUD_TOOLS = [
        "ProwlerScanner", "ScoutSuiteScanner", "TrivyScanner",
        "KubeHunterScanner", "KubeBenchScanner", "DockerBenchScanner"
    ]
    
    def __init__(
        self,
        output_dir: Optional[str] = None,
        use_ai: bool = True,
        verbose: bool = False
    ):
        self.output_dir = Path(output_dir) if output_dir else Path("./tool_output")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.use_ai = use_ai
        self.verbose = verbose
        self._tools: Dict[str, ToolWrapper] = {}
        self._ai_client: Optional[CursorAIClient] = None
    
    def _get_tool_class(self, tool_name: str) -> Optional[Type[ToolWrapper]]:
        """Get tool class by name"""
        # Import all tools dynamically
        try:
            if tool_name in self.NETWORK_TOOLS:
                from . import network
                return getattr(network, tool_name, None)
            elif tool_name in self.WEB_TOOLS:
                from . import web
                return getattr(web, tool_name, None)
            elif tool_name in self.PASSWORD_TOOLS:
                from . import password
                return getattr(password, tool_name, None)
            elif tool_name in self.BINARY_TOOLS:
                from . import binary
                return getattr(binary, tool_name, None)
            elif tool_name in self.CLOUD_TOOLS:
                from . import cloud
                return getattr(cloud, tool_name, None)
        except (ImportError, AttributeError):
            pass
        return None
    
    def get_tool(self, tool_name: str) -> Optional[ToolWrapper]:
        """Get or create a tool instance"""
        if tool_name not in self._tools:
            tool_class = self._get_tool_class(tool_name)
            if tool_class:
                self._tools[tool_name] = tool_class(
                    output_dir=str(self.output_dir),
                    verbose=self.verbose
                )
        return self._tools.get(tool_name)
    
    def check_installed_tools(self) -> Dict[str, Dict[str, Any]]:
        """Check which tools are installed"""
        all_tools = (
            self.NETWORK_TOOLS + self.WEB_TOOLS + 
            self.PASSWORD_TOOLS + self.BINARY_TOOLS + 
            self.CLOUD_TOOLS
        )
        
        results = {}
        
        console.print("\n[bold cyan]Checking installed tools...[/bold cyan]\n")
        
        for tool_name in all_tools:
            tool = self.get_tool(tool_name)
            if tool:
                installed, message = tool.check_installation()
                results[tool_name] = {
                    "installed": installed,
                    "message": message,
                    "binary": tool.BINARY_NAME
                }
        
        # Display results
        table = Table(title="Tool Availability")
        table.add_column("Tool", style="cyan")
        table.add_column("Binary", style="white")
        table.add_column("Status", style="white")
        
        installed_count = 0
        for name, info in sorted(results.items()):
            status = "[green]✓ Installed[/green]" if info["installed"] else "[red]✗ Missing[/red]"
            if info["installed"]:
                installed_count += 1
            table.add_row(name, info["binary"], status)
        
        console.print(table)
        console.print(f"\n[bold]Installed: {installed_count}/{len(results)}[/bold]")
        
        return results
    
    async def run_tool(
        self,
        tool_name: str,
        target: str,
        **kwargs
    ) -> Optional[ToolResult]:
        """Run a single tool"""
        tool = self.get_tool(tool_name)
        if not tool:
            console.print(f"[red]Tool not found: {tool_name}[/red]")
            return None
        
        console.print(f"[cyan]Running {tool.TOOL_NAME}...[/cyan]")
        result = await tool.run(target, **kwargs)
        
        if result.is_success:
            console.print(f"[green]✓[/green] {tool.TOOL_NAME} completed - {len(result.findings)} findings")
        else:
            # Display actual error message for better debugging
            error_msg = result.error if result.error else result.status.value
            console.print(f"[yellow]⚠[/yellow] {tool.TOOL_NAME}: {error_msg}")
            if self.verbose and result.output:
                console.print(f"[dim]Output: {result.output[:500]}[/dim]")
        
        return result
    
    async def run_category(
        self,
        category: str,
        target: str,
        parallel: bool = True,
        **kwargs
    ) -> ToolScanResult:
        """Run all tools in a category"""
        category_tools = {
            "network": self.NETWORK_TOOLS,
            "web": self.WEB_TOOLS,
            "password": self.PASSWORD_TOOLS,
            "binary": self.BINARY_TOOLS,
            "cloud": self.CLOUD_TOOLS,
        }
        
        tools = category_tools.get(category.lower(), [])
        if not tools:
            console.print(f"[red]Unknown category: {category}[/red]")
            return ToolScanResult(target=target, start_time=datetime.now())
        
        console.print(f"\n[bold cyan]Running {category.upper()} tools against {target}[/bold cyan]\n")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        if parallel:
            # Run tools in parallel
            tasks = []
            for tool_name in tools:
                tool = self.get_tool(tool_name)
                if tool and tool.is_installed:
                    tasks.append(self.run_tool(tool_name, target, **kwargs))
            
            if tasks:
                results = await asyncio.gather(*tasks, return_exceptions=True)
                for result in results:
                    if isinstance(result, ToolResult):
                        scan_result.tool_results.append(result)
                        scan_result.findings.extend(
                            self._convert_to_findings(result)
                        )
        else:
            # Run sequentially
            for tool_name in tools:
                tool = self.get_tool(tool_name)
                if tool and tool.is_installed:
                    result = await self.run_tool(tool_name, target, **kwargs)
                    if result:
                        scan_result.tool_results.append(result)
                        scan_result.findings.extend(
                            self._convert_to_findings(result)
                        )
        
        scan_result.end_time = datetime.now()
        
        # AI analysis
        if self.use_ai and scan_result.findings:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        return scan_result
    
    async def run_recon(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        parallel: bool = True,
        max_concurrent: int = 4,
        **kwargs
    ) -> ToolScanResult:
        """Run reconnaissance tools (parallel by default)"""
        if tools is None:
            tools = ["NmapScanner", "SubfinderEnumerator", "HttpxScanner", "NucleiScanner"]
        
        console.print(f"\n[bold cyan]═══ Reconnaissance: {target} ═══[/bold cyan]\n")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        if parallel:
            # Run tools in parallel with concurrency limit
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def run_with_limit(tool_name: str) -> Optional[ToolResult]:
                async with semaphore:
                    return await self.run_tool(tool_name, target, **kwargs)
            
            console.print(f"[dim]Running {len(tools)} tools in parallel (max {max_concurrent} concurrent)[/dim]")
            tasks = [run_with_limit(tool_name) for tool_name in tools]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, ToolResult):
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        else:
            # Sequential execution
            for tool_name in tools:
                result = await self.run_tool(tool_name, target, **kwargs)
                if result:
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai and scan_result.findings:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        return scan_result
    
    async def run_web_scan(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        parallel: bool = True,
        max_concurrent: int = 4,
        **kwargs
    ) -> ToolScanResult:
        """Run web application scanning tools (parallel by default)"""
        if tools is None:
            tools = ["HttpxScanner", "NiktoScanner", "GobusterScanner", "NucleiScanner", "Wafw00fScanner"]
        
        console.print(f"\n[bold cyan]═══ Web Scan: {target} ═══[/bold cyan]\n")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        if parallel:
            # Run tools in parallel with concurrency limit
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def run_with_limit(tool_name: str) -> Optional[ToolResult]:
                async with semaphore:
                    return await self.run_tool(tool_name, target, **kwargs)
            
            console.print(f"[dim]Running {len(tools)} tools in parallel (max {max_concurrent} concurrent)[/dim]")
            tasks = [run_with_limit(tool_name) for tool_name in tools]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, ToolResult):
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        else:
            # Sequential execution
            for tool_name in tools:
                result = await self.run_tool(tool_name, target, **kwargs)
                if result:
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        return scan_result
    
    async def run_vuln_scan(
        self,
        target: str,
        tools: Optional[List[str]] = None,
        parallel: bool = True,
        max_concurrent: int = 3,
        **kwargs
    ) -> ToolScanResult:
        """Run vulnerability scanning tools (parallel by default)"""
        if tools is None:
            tools = ["NucleiScanner", "NiktoScanner", "SqlmapScanner", "DalfoxScanner"]
        
        console.print(f"\n[bold cyan]═══ Vulnerability Scan: {target} ═══[/bold cyan]\n")
        
        scan_result = ToolScanResult(target=target, start_time=datetime.now())
        
        if parallel:
            # Run tools in parallel with concurrency limit
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def run_with_limit(tool_name: str) -> Optional[ToolResult]:
                async with semaphore:
                    return await self.run_tool(tool_name, target, **kwargs)
            
            console.print(f"[dim]Running {len(tools)} tools in parallel (max {max_concurrent} concurrent)[/dim]")
            tasks = [run_with_limit(tool_name) for tool_name in tools]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, ToolResult):
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        else:
            # Sequential execution
            for tool_name in tools:
                result = await self.run_tool(tool_name, target, **kwargs)
                if result:
                    scan_result.tool_results.append(result)
                    scan_result.findings.extend(self._convert_to_findings(result))
        
        scan_result.end_time = datetime.now()
        
        if self.use_ai:
            scan_result.ai_analysis = await self._analyze_results(scan_result)
        
        return scan_result
    
    def _convert_to_findings(self, result: ToolResult) -> List[Finding]:
        """Convert tool findings to report findings"""
        findings = []
        
        for i, f in enumerate(result.findings):
            findings.append(Finding(
                id=f"{result.tool_name.upper()[:3]}-{i+1:03d}",
                title=f.get("title", "Unknown Finding"),
                severity=f.get("severity", "info"),
                category=result.tool_name,
                description=f.get("description", ""),
                impact=self._get_impact(f.get("severity", "info")),
                remediation=f.get("remediation", ""),
                evidence=f.get("evidence", ""),
                url=f.get("url", ""),
                parameter=f.get("parameter", ""),
                cwe_id=f.get("cwe_id", ""),
                cvss_score=f.get("cvss_score", 0.0),
            ))
        
        return findings
    
    def _get_impact(self, severity: str) -> str:
        """Get impact description based on severity"""
        impacts = {
            "critical": "Complete system compromise possible",
            "high": "Significant security risk requiring immediate attention",
            "medium": "Moderate security risk that should be addressed",
            "low": "Minor security concern",
            "info": "Informational finding",
        }
        return impacts.get(severity.lower(), impacts["info"])
    
    async def _analyze_results(self, scan_result: ToolScanResult) -> str:
        """Analyze results with AI"""
        if not self._ai_client:
            self._ai_client = CursorAIClient()
            await self._ai_client._init_client()
        
        console.print("\n[cyan]Analyzing results with AI...[/cyan]")
        
        # Prepare summary for AI
        summary = {
            "target": scan_result.target,
            "tools_run": len(scan_result.tool_results),
            "total_findings": len(scan_result.findings),
            "findings_by_severity": {},
            "top_findings": []
        }
        
        for finding in scan_result.findings:
            sev = finding.severity
            summary["findings_by_severity"][sev] = summary["findings_by_severity"].get(sev, 0) + 1
        
        # Get top findings
        critical_high = [f for f in scan_result.findings if f.severity in ["critical", "high"]]
        summary["top_findings"] = [
            {"title": f.title, "severity": f.severity, "description": f.description[:200]}
            for f in critical_high[:5]
        ]
        
        response = await self._ai_client.analyze(
            prompt="Analyze these penetration test results and provide a summary with key findings and recommendations.",
            context=summary
        )
        
        return response.content
    
    async def close(self):
        """Close resources"""
        if self._ai_client:
            await self._ai_client.close()
