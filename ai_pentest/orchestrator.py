"""
Pentest Orchestrator
====================

Coordinates the entire penetration testing workflow.
"""

import asyncio
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum

from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich.panel import Panel
from rich.table import Table

from .config import get_settings
from .ai.cursor_client import CursorAIClient
from .ai.prompts import PentestPrompts
from .scanners.network import NetworkScanner, NetworkScanResult
from .scanners.web import WebScanner, WebScanResult
from .scanners.subdomain import SubdomainEnumerator, EnumerationResult
from .scanners.ssl_scanner import SSLScanner, SSLScanResult
from .scanners.ports import PortScanner
from .reports.generator import ReportGenerator, PentestReport, Finding


console = Console()


class ScanPhase(Enum):
    """Penetration test phases"""
    RECONNAISSANCE = "reconnaissance"
    ENUMERATION = "enumeration"
    VULNERABILITY_SCAN = "vulnerability_scan"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"


@dataclass
class PentestContext:
    """Context for the penetration test"""
    target: str
    scope: List[str] = field(default_factory=list)
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    current_phase: ScanPhase = ScanPhase.RECONNAISSANCE
    
    # Results from each phase
    network_results: Optional[NetworkScanResult] = None
    web_results: Optional[WebScanResult] = None
    subdomain_results: Optional[EnumerationResult] = None
    ssl_results: Optional[SSLScanResult] = None
    
    # AI analysis
    ai_insights: List[Dict[str, Any]] = field(default_factory=list)
    
    # Collected findings
    findings: List[Finding] = field(default_factory=list)
    
    def get_duration(self) -> float:
        """Get test duration in seconds"""
        end = self.end_time or datetime.now()
        return (end - self.start_time).total_seconds()


class PentestOrchestrator:
    """
    Orchestrates the complete penetration testing workflow
    
    Phases:
    1. Reconnaissance - Initial information gathering
    2. Enumeration - Detailed service/subdomain enumeration
    3. Vulnerability Scanning - Automated vulnerability detection
    4. Exploitation - (Advisory) Proof of concept guidance
    5. Reporting - Comprehensive report generation
    """
    
    def __init__(
        self,
        use_ai: bool = True,
        verbose: bool = False
    ):
        self.settings = get_settings()
        self.use_ai = use_ai
        self.verbose = verbose
        
        # Initialize scanners
        self.network_scanner = NetworkScanner()
        self.web_scanner = WebScanner()
        self.subdomain_enum = SubdomainEnumerator()
        self.ssl_scanner = SSLScanner()
        self.port_scanner = PortScanner()
        
        # Initialize AI client
        self.ai_client: Optional[CursorAIClient] = None
        
        # Report generator
        self.report_generator = ReportGenerator()
    
    async def run(
        self,
        target: str,
        scope: Optional[List[str]] = None,
        phases: Optional[List[ScanPhase]] = None,
        report_format: str = "html"
    ) -> str:
        """
        Run complete penetration test
        
        Args:
            target: Primary target
            scope: Additional targets in scope
            phases: Specific phases to run (default: all)
            report_format: Output format for report
            
        Returns:
            Path to generated report
        """
        # Initialize context
        ctx = PentestContext(
            target=target,
            scope=scope or [target]
        )
        
        # Show banner
        self._show_banner(ctx)
        
        # Determine phases to run
        if phases is None:
            phases = [
                ScanPhase.RECONNAISSANCE,
                ScanPhase.ENUMERATION,
                ScanPhase.VULNERABILITY_SCAN,
                ScanPhase.REPORTING
            ]
        
        try:
            # Initialize AI client if enabled
            if self.use_ai:
                self.ai_client = CursorAIClient()
                await self.ai_client._init_client()
            
            # Run phases
            for phase in phases:
                ctx.current_phase = phase
                console.print(f"\n[bold cyan]â”â”â” Phase: {phase.value.upper()} â”â”â”[/bold cyan]\n")
                
                if phase == ScanPhase.RECONNAISSANCE:
                    await self._run_reconnaissance(ctx)
                elif phase == ScanPhase.ENUMERATION:
                    await self._run_enumeration(ctx)
                elif phase == ScanPhase.VULNERABILITY_SCAN:
                    await self._run_vulnerability_scan(ctx)
                elif phase == ScanPhase.REPORTING:
                    pass  # Handled below
            
            # Generate report
            ctx.end_time = datetime.now()
            report_path = await self._generate_report(ctx, report_format)
            
            # Show summary
            self._show_summary(ctx, report_path)
            
            return report_path
            
        finally:
            if self.ai_client:
                await self.ai_client.close()
    
    def _show_banner(self, ctx: PentestContext):
        """Display test banner"""
        console.print(Panel(
            f"""
[bold]AI-Assisted Penetration Test[/bold]

Target: {ctx.target}
Scope: {', '.join(ctx.scope)}
Started: {ctx.start_time.strftime('%Y-%m-%d %H:%M:%S')}
AI Enabled: {'Yes' if self.use_ai else 'No'}
            """,
            title="ðŸ”’ Pentest Session",
            style="cyan"
        ))
    
    async def _run_reconnaissance(self, ctx: PentestContext):
        """Run reconnaissance phase"""
        console.print("[bold]1. Network Reconnaissance[/bold]")
        
        # DNS and basic network info
        ctx.network_results = await self.network_scanner.scan(
            target=ctx.target,
            port_scan=True,
            port_range="quick",
            dns_enum=True,
            whois=True
        )
        
        # Convert to findings
        if ctx.network_results and ctx.network_results.port_scan:
            for port in ctx.network_results.port_scan.ports:
                ctx.findings.append(Finding(
                    id=f"RECON-{len(ctx.findings)+1:03d}",
                    title=f"Open Port Detected: {port.port}/{port.service}",
                    severity="info",
                    category="Reconnaissance",
                    description=f"Port {port.port} is open and running {port.service}",
                    impact="Open ports increase attack surface",
                    remediation="Review if this port needs to be exposed publicly",
                    evidence=port.banner or "",
                ))
        
        # AI Analysis
        if self.use_ai and self.ai_client and ctx.network_results:
            console.print("\n[cyan]AI analyzing reconnaissance results...[/cyan]")
            
            analysis = await self.ai_client.analyze(
                prompt=PentestPrompts.network_analysis(
                    open_ports=[
                        {"port": p.port, "service": p.service, "banner": p.banner}
                        for p in ctx.network_results.port_scan.ports
                    ] if ctx.network_results.port_scan else [],
                    target=ctx.target
                ),
                system_prompt=PentestPrompts.RECON_ANALYST_SYSTEM
            )
            
            ctx.ai_insights.append({
                "phase": "reconnaissance",
                "analysis": analysis.content
            })
            
            console.print(Panel(
                analysis.content[:1500] + "..." if len(analysis.content) > 1500 else analysis.content,
                title="AI Reconnaissance Analysis",
                style="dim"
            ))
    
    async def _run_enumeration(self, ctx: PentestContext):
        """Run enumeration phase"""
        # Extract domain from target
        domain = ctx.target.replace("https://", "").replace("http://", "").split("/")[0]
        
        # Subdomain enumeration
        console.print("[bold]2. Subdomain Enumeration[/bold]")
        ctx.subdomain_results = await self.subdomain_enum.enumerate(
            domain=domain,
            check_alive=True
        )
        
        # SSL/TLS Analysis
        console.print("\n[bold]3. SSL/TLS Analysis[/bold]")
        ctx.ssl_results = await self.ssl_scanner.scan(target=domain)
        
        # Convert SSL findings
        if ctx.ssl_results:
            for vuln in ctx.ssl_results.vulnerabilities:
                ctx.findings.append(Finding(
                    id=f"SSL-{len(ctx.findings)+1:03d}",
                    title=vuln.name,
                    severity=vuln.severity,
                    category="SSL/TLS",
                    description=vuln.description,
                    impact="SSL/TLS issues can lead to data interception or downgrade attacks",
                    remediation=vuln.remediation,
                    cwe_id=vuln.cve or "",
                ))
        
        # AI Analysis
        if self.use_ai and self.ai_client and ctx.subdomain_results:
            console.print("\n[cyan]AI analyzing enumeration results...[/cyan]")
            
            analysis = await self.ai_client.analyze(
                prompt=PentestPrompts.subdomain_analysis(
                    subdomains=[s.subdomain for s in ctx.subdomain_results.subdomains if s.is_alive],
                    domain=domain
                ),
                system_prompt=PentestPrompts.RECON_ANALYST_SYSTEM
            )
            
            ctx.ai_insights.append({
                "phase": "enumeration",
                "analysis": analysis.content
            })
    
    async def _run_vulnerability_scan(self, ctx: PentestContext):
        """Run vulnerability scanning phase"""
        console.print("[bold]4. Web Application Scanning[/bold]")
        
        # Full web scan
        ctx.web_results = await self.web_scanner.scan(
            target=ctx.target,
            depth=2,
            check_xss=True,
            check_sqli=True,
            check_lfi=True,
            check_headers=True,
            check_sensitive=True
        )
        
        # Convert web findings
        if ctx.web_results:
            for vuln in ctx.web_results.vulnerabilities:
                ctx.findings.append(Finding(
                    id=f"WEB-{len(ctx.findings)+1:03d}",
                    title=vuln.vuln_type.value,
                    severity=vuln.severity.value,
                    category="Web Application",
                    description=vuln.description,
                    impact="Web vulnerabilities can lead to data theft, defacement, or full compromise",
                    remediation=vuln.remediation,
                    evidence=vuln.evidence,
                    url=vuln.url,
                    parameter=vuln.parameter,
                    cwe_id=vuln.cwe_id,
                    cvss_score=vuln.cvss_score,
                ))
        
        # AI Analysis of critical findings
        if self.use_ai and self.ai_client:
            critical_findings = [f for f in ctx.findings if f.severity in ["critical", "high"]]
            
            if critical_findings:
                console.print("\n[cyan]AI analyzing critical findings...[/cyan]")
                
                for finding in critical_findings[:3]:  # Analyze top 3
                    analysis = await self.ai_client.analyze_vulnerability(
                        vulnerability_type=finding.category,
                        evidence={"description": finding.description, "evidence": finding.evidence},
                        target=finding.url or ctx.target
                    )
                    
                    # Enhance finding with AI analysis
                    finding.description = f"{finding.description}\n\n**AI Analysis:**\n{analysis.content[:500]}"
                    
                    ctx.ai_insights.append({
                        "phase": "vulnerability_scan",
                        "finding_id": finding.id,
                        "analysis": analysis.content
                    })
    
    async def _generate_report(self, ctx: PentestContext, format: str) -> str:
        """Generate the final report"""
        console.print("\n[bold cyan]â”â”â” Generating Report â”â”â”[/bold cyan]\n")
        
        # Create report object
        report = PentestReport(
            title=f"Penetration Test Report - {ctx.target}",
            target=ctx.target,
            findings=ctx.findings,
            start_date=ctx.start_time,
            end_date=ctx.end_time,
            scope=", ".join(ctx.scope),
        )
        
        # Add scan results
        if ctx.network_results:
            report.network_findings = ctx.network_results.to_dict()
        if ctx.web_results:
            report.web_findings = ctx.web_results.to_dict()
        if ctx.ssl_results:
            report.ssl_findings = ctx.ssl_results.to_dict()
        if ctx.subdomain_results:
            report.subdomain_findings = ctx.subdomain_results.to_dict()
        
        # Generate report
        report_path = await self.report_generator.generate(
            report=report,
            format=format,
            use_ai=self.use_ai
        )
        
        return report_path
    
    def _show_summary(self, ctx: PentestContext, report_path: str):
        """Display test summary"""
        summary = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for finding in ctx.findings:
            severity = finding.severity.lower()
            if severity in summary:
                summary[severity] += 1
        
        duration = ctx.get_duration()
        
        console.print("\n")
        console.print(Panel(
            f"""
[bold green]âœ“ Penetration Test Complete![/bold green]

[bold]Target:[/bold] {ctx.target}
[bold]Duration:[/bold] {duration:.1f} seconds
[bold]Total Findings:[/bold] {len(ctx.findings)}

[bold]Severity Breakdown:[/bold]
  [red]â— Critical: {summary['critical']}[/red]
  [orange1]â— High: {summary['high']}[/orange1]
  [yellow]â— Medium: {summary['medium']}[/yellow]
  [green]â— Low: {summary['low']}[/green]
  [blue]â— Info: {summary['info']}[/blue]

[bold]Report:[/bold] {report_path}
            """,
            title="Summary",
            style="green"
        ))
        
        # Show critical findings
        critical = [f for f in ctx.findings if f.severity == "critical"]
        if critical:
            console.print("\n[bold red]Critical Findings Requiring Immediate Attention:[/bold red]")
            for finding in critical:
                console.print(f"  â€¢ {finding.id}: {finding.title}")


async def run_pentest(
    target: str,
    scope: Optional[List[str]] = None,
    use_ai: bool = True,
    report_format: str = "html",
    verbose: bool = False
) -> str:
    """
    Convenience function to run a complete penetration test
    
    Args:
        target: Target URL/domain/IP
        scope: Additional targets in scope
        use_ai: Enable AI-powered analysis
        report_format: Report format (html, pdf, json)
        verbose: Enable verbose output
        
    Returns:
        Path to generated report
    """
    orchestrator = PentestOrchestrator(
        use_ai=use_ai,
        verbose=verbose
    )
    
    return await orchestrator.run(
        target=target,
        scope=scope,
        report_format=report_format
    )
