"""
Helper utilities for AI Pentest Tool
"""

import re
import socket
from typing import Optional
from urllib.parse import urlparse
from datetime import timedelta


def normalize_url(url: str) -> str:
    """Normalize URL with proper scheme"""
    if not url:
        return ""
    
    url = url.strip()
    
    if not url.startswith(("http://", "https://")):
        url = f"https://{url}"
    
    # Remove trailing slash
    return url.rstrip("/")


def extract_domain(url: str) -> str:
    """Extract domain from URL"""
    try:
        if not url.startswith(("http://", "https://")):
            url = f"https://{url}"
        
        parsed = urlparse(url)
        return parsed.netloc or parsed.path.split("/")[0]
    except Exception:
        return url


def is_valid_ip(ip: str) -> bool:
    """Check if string is a valid IP address"""
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        pass
    
    try:
        socket.inet_pton(socket.AF_INET6, ip)
        return True
    except socket.error:
        return False


def is_valid_domain(domain: str) -> bool:
    """Check if string is a valid domain name"""
    if not domain or len(domain) > 253:
        return False
    
    # Remove trailing dot if present
    if domain.endswith("."):
        domain = domain[:-1]
    
    # Check each label
    labels = domain.split(".")
    if len(labels) < 2:
        return False
    
    # Valid label pattern
    pattern = re.compile(r"^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$")
    
    for label in labels:
        if not pattern.match(label):
            return False
    
    return True


def sanitize_filename(filename: str) -> str:
    """Sanitize filename for safe filesystem use"""
    # Remove or replace unsafe characters
    unsafe_chars = '<>:"/\\|?*'
    for char in unsafe_chars:
        filename = filename.replace(char, "_")
    
    # Limit length
    if len(filename) > 200:
        filename = filename[:200]
    
    return filename.strip()


def format_bytes(size: int) -> str:
    """Format bytes to human readable string"""
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if abs(size) < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} PB"


def format_duration(seconds: float) -> str:
    """Format seconds to human readable duration"""
    if seconds < 60:
        return f"{seconds:.1f}s"
    
    td = timedelta(seconds=int(seconds))
    parts = []
    
    hours, remainder = divmod(td.seconds, 3600)
    minutes, secs = divmod(remainder, 60)
    
    if td.days:
        parts.append(f"{td.days}d")
    if hours:
        parts.append(f"{hours}h")
    if minutes:
        parts.append(f"{minutes}m")
    if secs or not parts:
        parts.append(f"{secs}s")
    
    return " ".join(parts)


def truncate_string(s: str, max_length: int = 100, suffix: str = "...") -> str:
    """Truncate string to max length"""
    if len(s) <= max_length:
        return s
    return s[:max_length - len(suffix)] + suffix


def parse_target_list(targets: str) -> list:
    """Parse comma or newline separated target list"""
    result = []
    
    # Split by comma or newline
    for target in re.split(r"[,\n]", targets):
        target = target.strip()
        if target:
            result.append(target)
    
    return result


def get_severity_color(severity: str) -> str:
    """Get color for severity level"""
    colors = {
        "critical": "#dc3545",
        "high": "#fd7e14",
        "medium": "#ffc107",
        "low": "#28a745",
        "info": "#17a2b8",
    }
    return colors.get(severity.lower(), "#6c757d")


def get_severity_score(severity: str) -> int:
    """Get numeric score for severity"""
    scores = {
        "critical": 5,
        "high": 4,
        "medium": 3,
        "low": 2,
        "info": 1,
    }
    return scores.get(severity.lower(), 0)
