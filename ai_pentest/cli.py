#!/usr/bin/env python3
"""
AI Pentest Tool - Command Line Interface
=========================================

Main CLI for the AI-assisted penetration testing tool.
"""

import asyncio
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, List

import typer
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich import print as rprint

from .config import get_settings, Settings
from .ai.cursor_client import CursorAIClient, AIProvider
from .scanners.network import NetworkScanner
from .scanners.web import WebScanner, Vulnerability
from .scanners.subdomain import SubdomainEnumerator
from .scanners.ssl_scanner import SSLScanner
from .scanners.ports import PortScanner
from .reports.generator import ReportGenerator, PentestReport, Finding


console = Console()
app = typer.Typer(
    name="ai-pentest",
    help="ğŸ”’ AI-Assisted Penetration Testing Tool",
    add_completion=False,
)


def show_banner():
    """Display tool banner"""
    banner = """
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                              â•‘
    â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—       â•‘
    â•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•       â•‘
    â•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘          â•‘
    â•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘          â•‘
    â•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘          â•‘
    â•‘    â•šâ•â•  â•šâ•â•â•šâ•â•    â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•          â•‘
    â•‘                                                              â•‘
    â•‘         AI-Assisted Penetration Testing Tool v1.0            â•‘
    â•‘                                                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """
    console.print(banner, style="bold cyan")


@app.command()
def scan(
    target: str = typer.Argument(..., help="Target URL, domain, or IP address"),
    scan_type: str = typer.Option(
        "full",
        "--type", "-t",
        help="Scan type: full, web, network, recon, ssl"
    ),
    ports: str = typer.Option(
        "quick",
        "--ports", "-p",
        help="Port range: quick, common, full, or custom (e.g., 80,443,8080)"
    ),
    output: Optional[str] = typer.Option(
        None,
        "--output", "-o",
        help="Output directory for reports"
    ),
    report_format: str = typer.Option(
        "html",
        "--format", "-f",
        help="Report format: html, pdf, json"
    ),
    no_ai: bool = typer.Option(
        False,
        "--no-ai",
        help="Disable AI-enhanced analysis"
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose", "-v",
        help="Enable verbose output"
    ),
):
    """
    ğŸ” Perform a comprehensive security scan
    
    Examples:
        ai-pentest scan example.com
        ai-pentest scan https://example.com --type web
        ai-pentest scan 192.168.1.1 --type network --ports full
    """
    show_banner()
    
    console.print(f"\n[bold]Target:[/bold] {target}")
    console.print(f"[bold]Scan Type:[/bold] {scan_type}")
    console.print(f"[bold]AI Enhanced:[/bold] {'No' if no_ai else 'Yes'}\n")
    
    try:
        asyncio.run(_run_scan(
            target=target,
            scan_type=scan_type,
            ports=ports,
            output=output,
            report_format=report_format,
            use_ai=not no_ai,
            verbose=verbose
        ))
    except KeyboardInterrupt:
        console.print("\n[yellow]Scan interrupted by user[/yellow]")
        sys.exit(1)
    except Exception as e:
        console.print(f"\n[red]Error: {str(e)}[/red]")
        if verbose:
            console.print_exception()
        sys.exit(1)


async def _run_scan(
    target: str,
    scan_type: str,
    ports: str,
    output: Optional[str],
    report_format: str,
    use_ai: bool,
    verbose: bool
):
    """Execute the scan"""
    start_time = datetime.now()
    findings: List[Finding] = []
    
    # Initialize report
    report = PentestReport(
        title=f"Penetration Test Report - {target}",
        target=target,
        start_date=start_time,
    )
    
    # Run appropriate scan
    if scan_type in ["full", "network"]:
        console.print(Panel("[bold]Network Reconnaissance[/bold]", style="cyan"))
        network_scanner = NetworkScanner()
        network_result = await network_scanner.scan(
            target=target,
            port_scan=True,
            port_range=ports
        )
        report.network_findings = network_result.to_dict()
        
        # Convert to findings
        if network_result.port_scan:
            for port in network_result.port_scan.ports:
                findings.append(Finding(
                    id=f"NET-{len(findings)+1:03d}",
                    title=f"Open Port: {port.port}/{port.service}",
                    severity="info",
                    category="Network",
                    description=f"Port {port.port} is open running {port.service}",
                    impact="Open ports expose services that may be vulnerable",
                    remediation="Ensure only necessary ports are exposed and services are hardened",
                    evidence=port.banner if port.banner else "",
                ))
    
    if scan_type in ["full", "recon"]:
        console.print(Panel("[bold]Subdomain Enumeration[/bold]", style="cyan"))
        subdomain_enum = SubdomainEnumerator()
        subdomain_result = await subdomain_enum.enumerate(
            domain=target.replace("https://", "").replace("http://", "").split("/")[0],
            check_alive=True
        )
        report.subdomain_findings = subdomain_result.to_dict()
    
    if scan_type in ["full", "ssl"]:
        console.print(Panel("[bold]SSL/TLS Analysis[/bold]", style="cyan"))
        ssl_scanner = SSLScanner()
        ssl_result = await ssl_scanner.scan(
            target=target.replace("https://", "").replace("http://", "").split("/")[0]
        )
        report.ssl_findings = ssl_result.to_dict()
        
        # Convert to findings
        for vuln in ssl_result.vulnerabilities:
            findings.append(Finding(
                id=f"SSL-{len(findings)+1:03d}",
                title=vuln.name,
                severity=vuln.severity,
                category="SSL/TLS",
                description=vuln.description,
                impact="SSL/TLS vulnerabilities can lead to data interception",
                remediation=vuln.remediation,
                cwe_id=vuln.cve if vuln.cve else "",
            ))
    
    if scan_type in ["full", "web"]:
        console.print(Panel("[bold]Web Application Scanning[/bold]", style="cyan"))
        web_scanner = WebScanner()
        web_result = await web_scanner.scan(
            target=target,
            depth=2,
            check_xss=True,
            check_sqli=True,
            check_lfi=True
        )
        report.web_findings = web_result.to_dict()
        
        # Convert to findings
        for vuln in web_result.vulnerabilities:
            findings.append(Finding(
                id=f"WEB-{len(findings)+1:03d}",
                title=vuln.vuln_type.value,
                severity=vuln.severity.value,
                category="Web Application",
                description=vuln.description,
                impact="Web vulnerabilities can lead to data theft or system compromise",
                remediation=vuln.remediation,
                evidence=vuln.evidence,
                url=vuln.url,
                parameter=vuln.parameter,
                cwe_id=vuln.cwe_id,
                cvss_score=vuln.cvss_score,
            ))
    
    # Add findings to report
    report.findings = findings
    report.end_date = datetime.now()
    
    # AI Analysis
    if use_ai and findings:
        console.print(Panel("[bold]AI-Powered Analysis[/bold]", style="cyan"))
        
        async with CursorAIClient() as ai:
            # Analyze findings
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=console,
            ) as progress:
                task = progress.add_task("Analyzing findings...", total=None)
                
                analysis = await ai.analyze(
                    prompt="Analyze these security findings and provide a risk assessment",
                    context={"findings": [f.to_dict() for f in findings[:10]]},  # Limit for API
                    system_prompt=ai.settings.cursor.model
                )
                
                progress.update(task, completed=True)
            
            if analysis.content:
                console.print("\n[bold]AI Analysis:[/bold]")
                console.print(Panel(analysis.content[:2000], style="dim"))
    
    # Generate Report
    console.print(Panel("[bold]Generating Report[/bold]", style="cyan"))
    
    generator = ReportGenerator(output_dir=output)
    report_path = await generator.generate(
        report=report,
        format=report_format,
        use_ai=use_ai
    )
    
    # Summary
    duration = (datetime.now() - start_time).total_seconds()
    summary = report.get_summary()
    
    console.print("\n")
    console.print(Panel(
        f"""
[bold]Scan Complete![/bold]

Target: {target}
Duration: {duration:.1f} seconds
Total Findings: {len(findings)}

[red]Critical: {summary['critical']}[/red]
[orange1]High: {summary['high']}[/orange1]
[yellow]Medium: {summary['medium']}[/yellow]
[green]Low: {summary['low']}[/green]
[blue]Info: {summary['info']}[/blue]

Report: {report_path}
        """,
        title="Summary",
        style="green"
    ))


@app.command()
def web(
    target: str = typer.Argument(..., help="Target URL"),
    depth: int = typer.Option(2, "--depth", "-d", help="Crawl depth"),
    no_xss: bool = typer.Option(False, "--no-xss", help="Skip XSS tests"),
    no_sqli: bool = typer.Option(False, "--no-sqli", help="Skip SQL injection tests"),
):
    """
    ğŸŒ Web application security scan
    """
    show_banner()
    
    async def run():
        scanner = WebScanner()
        result = await scanner.scan(
            target=target,
            depth=depth,
            check_xss=not no_xss,
            check_sqli=not no_sqli
        )
        
        console.print("\n[bold green]Web scan complete![/bold green]")
        console.print(f"Vulnerabilities found: {len(result.vulnerabilities)}")
    
    asyncio.run(run())


@app.command()
def network(
    target: str = typer.Argument(..., help="Target IP or hostname"),
    ports: str = typer.Option("quick", "--ports", "-p", help="Port range"),
):
    """
    ğŸ”Œ Network reconnaissance scan
    """
    show_banner()
    
    async def run():
        scanner = NetworkScanner()
        result = await scanner.scan(target=target, port_range=ports)
        
        console.print("\n[bold green]Network scan complete![/bold green]")
    
    asyncio.run(run())


@app.command()
def subdomains(
    domain: str = typer.Argument(..., help="Target domain"),
    wordlist: Optional[str] = typer.Option(None, "--wordlist", "-w", help="Custom wordlist file"),
    no_bruteforce: bool = typer.Option(False, "--no-bruteforce", help="Skip DNS bruteforce"),
):
    """
    ğŸ” Subdomain enumeration
    """
    show_banner()
    
    async def run():
        custom_wordlist = None
        if wordlist:
            with open(wordlist) as f:
                custom_wordlist = [line.strip() for line in f if line.strip()]
        
        enumerator = SubdomainEnumerator()
        result = await enumerator.enumerate(
            domain=domain,
            bruteforce=not no_bruteforce,
            custom_wordlist=custom_wordlist
        )
        
        console.print(f"\n[bold green]Found {result.total_found} subdomains![/bold green]")
        console.print(f"Alive: {result.alive_count}")
    
    asyncio.run(run())


@app.command()
def ssl(
    target: str = typer.Argument(..., help="Target hostname"),
    port: int = typer.Option(443, "--port", "-p", help="Port number"),
):
    """
    ğŸ” SSL/TLS security analysis
    """
    show_banner()
    
    async def run():
        scanner = SSLScanner()
        result = await scanner.scan(target=target, port=port)
        
        console.print(f"\n[bold]SSL Grade: {result.grade.value}[/bold]")
    
    asyncio.run(run())


@app.command()
def analyze(
    finding: str = typer.Argument(..., help="Finding description or file"),
    target: str = typer.Option("", "--target", "-t", help="Target context"),
):
    """
    ğŸ¤– AI-powered vulnerability analysis
    """
    show_banner()
    
    async def run():
        # Check if it's a file
        if Path(finding).exists():
            with open(finding) as f:
                content = f.read()
        else:
            content = finding
        
        async with CursorAIClient() as ai:
            console.print("[cyan]Analyzing with AI...[/cyan]\n")
            
            response = await ai.analyze(
                prompt=f"Analyze this security finding and provide detailed recommendations:\n\n{content}",
                context={"target": target} if target else None
            )
            
            console.print(Panel(response.content, title="AI Analysis", style="green"))
    
    asyncio.run(run())


@app.command()
def report(
    input_file: str = typer.Argument(..., help="JSON scan results file"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output directory"),
    format: str = typer.Option("html", "--format", "-f", help="Output format: html, pdf, json"),
):
    """
    ğŸ“„ Generate report from scan results
    """
    show_banner()
    
    import json
    
    async def run():
        with open(input_file) as f:
            data = json.load(f)
        
        # Create report from data
        report = PentestReport(
            title=data.get("title", "Penetration Test Report"),
            target=data.get("target", "Unknown"),
            findings=[
                Finding(**f) for f in data.get("findings", [])
            ]
        )
        
        generator = ReportGenerator(output_dir=output)
        report_path = await generator.generate(report, format=format)
        
        console.print(f"[green]Report generated: {report_path}[/green]")
    
    asyncio.run(run())


@app.command()
def config(
    show: bool = typer.Option(False, "--show", "-s", help="Show current configuration"),
    api_key: Optional[str] = typer.Option(None, "--api-key", help="Set API key"),
):
    """
    âš™ï¸  Configuration management
    """
    if show:
        settings = get_settings()
        
        table = Table(title="Current Configuration")
        table.add_column("Setting", style="cyan")
        table.add_column("Value", style="white")
        
        table.add_row("API Key", "***" + settings.cursor.api_key[-4:] if settings.cursor.api_key else "Not set")
        table.add_row("Model", settings.cursor.model)
        table.add_row("Max Tokens", str(settings.cursor.max_tokens))
        table.add_row("Report Format", settings.report.format)
        table.add_row("Output Dir", settings.report.output_dir)
        
        console.print(table)
    
    if api_key:
        import os
        os.environ["CURSOR_API_KEY"] = api_key
        console.print("[green]API key set for this session[/green]")
        console.print("[dim]For permanent configuration, set CURSOR_API_KEY environment variable[/dim]")


@app.command()
def tools(
    check: bool = typer.Option(False, "--check", "-c", help="Check installed tools"),
    category: Optional[str] = typer.Option(None, "--category", help="Filter by category"),
):
    """
    ğŸ”§ List and check available security tools
    """
    from .tools import ToolManager
    
    show_banner()
    manager = ToolManager()
    
    if check:
        manager.check_installed_tools()
    else:
        console.print("\n[bold]Available Tool Categories:[/bold]")
        console.print("  â€¢ network  - Nmap, Masscan, Rustscan, Amass, Subfinder, Nuclei, etc.")
        console.print("  â€¢ web      - Gobuster, Feroxbuster, Nikto, SQLMap, WPScan, Dalfox, etc.")
        console.print("  â€¢ password - Hydra, John, Hashcat, Medusa, CrackMapExec, etc.")
        console.print("  â€¢ binary   - Binwalk, Checksec, Strings, Radare2, Volatility, etc.")
        console.print("  â€¢ cloud    - Prowler, Scout Suite, Trivy, Kube-hunter, etc.")
        console.print("\n[dim]Use --check to see which tools are installed[/dim]")


@app.command()
def run_tool(
    tool_name: str = typer.Argument(..., help="Tool name (e.g., NmapScanner, NucleiScanner)"),
    target: str = typer.Argument(..., help="Target to scan"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output directory"),
):
    """
    ğŸ”¨ Run a specific security tool
    """
    from .tools import ToolManager
    
    show_banner()
    
    async def run():
        manager = ToolManager(output_dir=output)
        result = await manager.run_tool(tool_name, target)
        
        if result:
            console.print(f"\n[bold]Results:[/bold]")
            console.print(f"  Status: {result.status.value}")
            console.print(f"  Findings: {len(result.findings)}")
            console.print(f"  Time: {result.execution_time:.2f}s")
            
            if result.findings:
                console.print("\n[bold]Findings:[/bold]")
                for f in result.findings[:10]:
                    console.print(f"  â€¢ [{f.get('severity', 'info').upper()}] {f.get('title', '')}")
    
    asyncio.run(run())


@app.command()
def recon(
    target: str = typer.Argument(..., help="Target domain or IP"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output directory"),
    no_ai: bool = typer.Option(False, "--no-ai", help="Disable AI analysis"),
):
    """
    ğŸ” Run reconnaissance tools (Nmap, Subfinder, Httpx, Nuclei)
    """
    from .tools import ToolManager
    
    show_banner()
    
    async def run():
        manager = ToolManager(output_dir=output, use_ai=not no_ai)
        result = await manager.run_recon(target)
        
        console.print(f"\n[bold green]Reconnaissance Complete![/bold green]")
        console.print(f"  Tools Run: {len(result.tool_results)}")
        console.print(f"  Findings: {len(result.findings)}")
        
        if result.ai_analysis:
            console.print("\n[bold]AI Analysis:[/bold]")
            console.print(result.ai_analysis[:2000])
        
        await manager.close()
    
    asyncio.run(run())


@app.command()
def vuln_scan(
    target: str = typer.Argument(..., help="Target URL"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output directory"),
    no_ai: bool = typer.Option(False, "--no-ai", help="Disable AI analysis"),
):
    """
    ğŸ¯ Run vulnerability scanning tools (Nuclei, Nikto, SQLMap, Dalfox)
    """
    from .tools import ToolManager
    
    show_banner()
    
    async def run():
        manager = ToolManager(output_dir=output, use_ai=not no_ai)
        result = await manager.run_vuln_scan(target)
        
        console.print(f"\n[bold green]Vulnerability Scan Complete![/bold green]")
        console.print(f"  Tools Run: {len(result.tool_results)}")
        console.print(f"  Findings: {len(result.findings)}")
        
        # Show critical/high findings
        critical = [f for f in result.findings if f.severity in ["critical", "high"]]
        if critical:
            console.print(f"\n[bold red]Critical/High Findings ({len(critical)}):[/bold red]")
            for f in critical[:10]:
                console.print(f"  â€¢ [{f.severity.upper()}] {f.title}")
        
        await manager.close()
    
    asyncio.run(run())


@app.command()
def agents(
    list_all: bool = typer.Option(True, "--list", "-l", help="List all available agents"),
    info: Optional[str] = typer.Option(None, "--info", "-i", help="Show details for specific agent"),
):
    """
    ğŸ¤– List available AI agent personas
    
    Agents provide specialized AI behavior for different security testing scenarios.
    """
    from .agents import get_agent, list_agents as list_all_agents, get_all_agents
    
    show_banner()
    
    if info:
        agent = get_agent(info)
        if agent:
            console.print(f"\n[bold cyan]{agent.name}[/bold cyan]")
            console.print(f"Type: {agent.agent_type.value}")
            console.print(f"Description: {agent.description}\n")
            console.print("[bold]Capabilities:[/bold]")
            for cap in agent.capabilities:
                console.print(f"  â€¢ {cap}")
            console.print("\n[bold]Recommended Tools:[/bold]")
            for tool in agent.recommended_tools[:10]:
                console.print(f"  â€¢ {tool}")
            console.print("\n[bold]Focus Areas:[/bold]")
            for area in agent.focus_areas:
                console.print(f"  â€¢ {area}")
            console.print(f"\n[bold]Workflow:[/bold] {agent.workflow}")
        else:
            console.print(f"[red]Agent '{info}' not found[/red]")
    else:
        agents_list = list_all_agents()
        
        table = Table(title="Available AI Agents", show_header=True)
        table.add_column("Name", style="cyan")
        table.add_column("Type", style="yellow")
        table.add_column("Description", style="white")
        
        for agent in agents_list:
            table.add_row(agent["name"], agent["type"], agent["description"][:50] + "...")
        
        console.print(table)
        console.print("\n[dim]Use --info <agent_type> for details (e.g., --info red_team)[/dim]")


@app.command()
def pentest(
    target: str = typer.Argument(..., help="Target domain or IP address"),
    output: str = typer.Option("./pentest_output", "--output", "-o", help="Output directory"),
    phases: Optional[str] = typer.Option(
        None, "--phases", "-p",
        help="Phases to run (comma-separated): reconnaissance,enumeration,vulnerability,exploitation,reporting"
    ),
    agent: Optional[str] = typer.Option(
        None, "--agent", "-a",
        help="Agent persona to use (red_team, bug_bounty, web_pentester, network_pentester, ctf_player, etc.)"
    ),
    no_ai: bool = typer.Option(False, "--no-ai", help="Disable AI-driven decisions"),
    auto: bool = typer.Option(True, "--auto/--manual", help="Auto mode (AI makes decisions) or manual mode"),
    max_iterations: int = typer.Option(10, "--max-iter", help="Max iterations per phase"),
    safe: bool = typer.Option(True, "--safe/--aggressive", help="Safe mode (avoid aggressive scans)"),
    scope: Optional[str] = typer.Option(None, "--scope", "-s", help="Additional in-scope targets (comma-separated)"),
    api_key: Optional[str] = typer.Option(None, "--api-key", help="API key for AI services"),
):
    """
    ğŸš€ Run full AI-driven penetration test
    
    This command runs a comprehensive penetration test following the methodology:
    1. Reconnaissance - Discover assets, subdomains, services
    2. Enumeration - Deep dive into discovered services
    3. Vulnerability - Identify security issues
    4. Exploitation - Validate and exploit vulnerabilities
    5. Reporting - Generate comprehensive report
    
    The AI brain analyzes tool outputs and makes decisions about next steps.
    
    Available agents: red_team, blue_team, bug_bounty, ctf_player, 
    network_pentester, web_pentester, api_security, cloud_security, 
    exploit_developer, reverse_engineer, dfir, osint
    
    Examples:
        ai-pentest pentest example.com
        ai-pentest pentest example.com --agent bug_bounty
        ai-pentest pentest example.com --phases reconnaissance,enumeration,vulnerability
        ai-pentest pentest 10.10.10.1 --output ./results --agent red_team
    """
    from .engine import PentestEngine
    from .engine.core import EngineConfig
    
    show_banner()
    
    # Show agent info
    if agent:
        console.print(f"[cyan]ğŸ¤– Using agent: {agent}[/cyan]")
    
    # Parse phases
    phase_list = None
    if phases:
        phase_list = [p.strip() for p in phases.split(",")]
    
    # Parse scope
    scope_list = []
    if scope:
        scope_list = [s.strip() for s in scope.split(",")]
    
    async def run():
        config = EngineConfig(
            target=target,
            scope=scope_list,
            output_dir=output,
            phases_to_run=phase_list or ["reconnaissance", "enumeration", "vulnerability", "reporting"],
            ai_enabled=not no_ai,
            api_key=api_key,
            auto_mode=auto,
            max_iterations_per_phase=max_iterations,
            safe_mode=safe
        )
        
        engine = PentestEngine(config)
        
        # Set agent if specified
        if agent and engine.ai_brain:
            engine.ai_brain.set_agent(agent)
        
        try:
            result = await engine.run()
            
            # Final message
            if result.success:
                console.print("\n[bold green]âœ“ Penetration test completed successfully![/bold green]")
            else:
                console.print("\n[bold yellow]âš  Penetration test completed with errors[/bold yellow]")
                
        except KeyboardInterrupt:
            engine.stop()
            console.print("\n[yellow]Pentest interrupted. Partial results saved.[/yellow]")
    
    asyncio.run(run())


@app.command()
def attack_plan(
    target: str = typer.Argument(..., help="Target domain or IP"),
    surface_file: Optional[str] = typer.Option(None, "--surface", "-s", help="Attack surface JSON file"),
    output: str = typer.Option("./attack_plan", "--output", "-o", help="Output directory"),
):
    """
    ğŸ“‹ Generate an AI attack plan based on discovered attack surface
    
    This command analyzes the current attack surface and generates
    prioritized attack paths with step-by-step exploitation guides.
    """
    from .engine import AttackSurface, AIBrain, AttackPlanner
    import json
    
    show_banner()
    
    async def run():
        # Load or create attack surface
        if surface_file:
            with open(surface_file) as f:
                data = json.load(f)
            attack_surface = AttackSurface(target)
            # Populate from data (simplified)
            console.print(f"[cyan]Loaded attack surface from {surface_file}[/cyan]")
        else:
            attack_surface = AttackSurface(target)
            console.print("[yellow]No attack surface provided. Run 'pentest' first for best results.[/yellow]")
        
        ai_brain = AIBrain()
        planner = AttackPlanner(ai_brain)
        
        try:
            plan = await planner.generate_plan(attack_surface)
            planner.display_plan(plan)
            
            # Save plan
            Path(output).mkdir(parents=True, exist_ok=True)
            plan_path = Path(output) / "attack_plan.json"
            with open(plan_path, "w") as f:
                json.dump(plan.to_dict(), f, indent=2, default=str)
            
            console.print(f"\n[green]Attack plan saved: {plan_path}[/green]")
            
        finally:
            await ai_brain.close()
    
    asyncio.run(run())


@app.command()
def interactive(
    target: str = typer.Argument(..., help="Target domain or IP"),
    output: str = typer.Option("./pentest_output", "--output", "-o", help="Output directory"),
):
    """
    ğŸ® Interactive penetration testing mode
    
    Start an interactive session where you can:
    - Run tools manually
    - Get AI recommendations
    - View attack surface
    - Generate reports on demand
    """
    from .engine import PentestEngine, AttackSurface, AIBrain
    from .engine.core import EngineConfig
    from .tools import ToolManager
    from prompt_toolkit import prompt
    from prompt_toolkit.history import InMemoryHistory
    
    show_banner()
    console.print(f"\n[bold]Interactive Pentest Mode[/bold]")
    console.print(f"Target: {target}")
    console.print("\nType 'help' for available commands, 'quit' to exit.\n")
    
    async def run_interactive():
        # Initialize components
        attack_surface = AttackSurface(target)
        tool_manager = ToolManager(output_dir=output)
        ai_brain = AIBrain()
        
        history = InMemoryHistory()
        
        commands = {
            "help": "Show this help message",
            "status": "Show current attack surface status",
            "tools": "List available tools",
            "run <tool> <target>": "Run a specific tool",
            "scan <type>": "Run scan type (recon/web/vuln)",
            "analyze": "Get AI recommendations for next steps",
            "vulns": "Show discovered vulnerabilities",
            "assets": "Show discovered assets",
            "plan": "Generate attack plan",
            "report": "Generate report",
            "quit": "Exit interactive mode"
        }
        
        while True:
            try:
                user_input = prompt("pentest> ", history=history)
                parts = user_input.strip().split()
                
                if not parts:
                    continue
                
                cmd = parts[0].lower()
                
                if cmd == "quit" or cmd == "exit":
                    break
                
                elif cmd == "help":
                    console.print("\n[bold]Available Commands:[/bold]")
                    for c, desc in commands.items():
                        console.print(f"  {c:25} - {desc}")
                    console.print()
                
                elif cmd == "status":
                    summary = attack_surface.get_summary()
                    console.print(Panel(
                        f"Target: {attack_surface.primary_target}\n"
                        f"Assets: {summary['total_assets']}\n"
                        f"Subdomains: {summary['total_subdomains']}\n"
                        f"Vulnerabilities: {summary['total_vulnerabilities']}\n"
                        f"  Critical: {summary['vulnerabilities_by_severity']['critical']}\n"
                        f"  High: {summary['vulnerabilities_by_severity']['high']}",
                        title="Attack Surface Status"
                    ))
                
                elif cmd == "tools":
                    installed = tool_manager.check_installed_tools()
                    available = sum(1 for v in installed.values() if v.get("installed", False))
                    console.print(f"\n[green]{available}[/green] tools available out of {len(installed)}")
                
                elif cmd == "run" and len(parts) >= 3:
                    tool_name = parts[1]
                    tool_target = parts[2]
                    console.print(f"[cyan]Running {tool_name} on {tool_target}...[/cyan]")
                    result = await tool_manager.run_tool(tool_name, tool_target)
                    if result:
                        console.print(f"[green]Found {len(result.findings)} findings[/green]")
                
                elif cmd == "analyze":
                    console.print("[cyan]Getting AI recommendations...[/cyan]")
                    await ai_brain.initialize()
                    decisions = await ai_brain.decide_next_steps(
                        attack_surface=attack_surface,
                        current_phase="interactive"
                    )
                    console.print("\n[bold]AI Recommendations:[/bold]")
                    for d in decisions[:5]:
                        console.print(f"  â€¢ [{d.priority}] {d.tool or d.decision_type.value}: {d.reasoning}")
                
                elif cmd == "vulns":
                    vulns = attack_surface.all_vulnerabilities
                    if vulns:
                        console.print(f"\n[bold]Vulnerabilities ({len(vulns)}):[/bold]")
                        for v in vulns[:20]:
                            console.print(f"  [{v.severity.value.upper()}] {v.title}")
                    else:
                        console.print("[dim]No vulnerabilities discovered yet[/dim]")
                
                elif cmd == "assets":
                    assets = list(attack_surface.assets.values())
                    if assets:
                        console.print(f"\n[bold]Assets ({len(assets)}):[/bold]")
                        for a in assets[:20]:
                            console.print(f"  â€¢ {a.name} ({a.asset_type.value})")
                    else:
                        console.print("[dim]No assets discovered yet[/dim]")
                
                elif cmd == "report":
                    console.print("[cyan]Generating report...[/cyan]")
                    # Would generate report here
                    console.print("[green]Report generation would happen here[/green]")
                
                else:
                    console.print(f"[yellow]Unknown command: {cmd}. Type 'help' for available commands.[/yellow]")
                    
            except KeyboardInterrupt:
                continue
            except EOFError:
                break
            except Exception as e:
                console.print(f"[red]Error: {e}[/red]")
        
        await ai_brain.close()
        console.print("\n[dim]Goodbye![/dim]")
    
    try:
        asyncio.run(run_interactive())
    except ImportError:
        console.print("[yellow]Interactive mode requires 'prompt_toolkit'. Install with: pip install prompt_toolkit[/yellow]")
        console.print("[dim]Falling back to basic mode...[/dim]")


@app.command()
def version():
    """
    ğŸ“Œ Show version information
    """
    from . import __version__
    console.print(f"AI Pentest Tool v{__version__}")


def main():
    """Main entry point"""
    app()


if __name__ == "__main__":
    main()
