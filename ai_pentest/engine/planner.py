"""
Attack Planner
==============

Strategic planning for penetration tests using AI.
"""

import json
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum

from rich.console import Console
from rich.table import Table
from rich.tree import Tree

from .attack_surface import (
    AttackSurface, Asset, Vulnerability, Credential,
    VulnSeverity, ServiceType, AssetType
)
from .brain import AIBrain


console = Console()


class AttackVector(Enum):
    """Types of attack vectors"""
    WEB_EXPLOIT = "web_exploit"
    CREDENTIAL_ATTACK = "credential_attack"
    NETWORK_EXPLOIT = "network_exploit"
    SOCIAL_ENGINEERING = "social_engineering"
    PHYSICAL = "physical"
    SUPPLY_CHAIN = "supply_chain"


@dataclass
class AttackStep:
    """A single step in an attack path"""
    order: int
    action: str
    target: str
    tool: str = ""
    technique: str = ""
    prerequisites: List[str] = field(default_factory=list)
    expected_outcome: str = ""
    risk_level: str = "medium"  # low, medium, high
    detection_risk: str = "medium"
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "order": self.order,
            "action": self.action,
            "target": self.target,
            "tool": self.tool,
            "technique": self.technique,
            "prerequisites": self.prerequisites,
            "expected_outcome": self.expected_outcome,
            "risk_level": self.risk_level,
            "detection_risk": self.detection_risk,
            "notes": self.notes
        }


@dataclass
class AttackPath:
    """A complete attack path"""
    id: str
    name: str
    description: str
    vector: AttackVector
    steps: List[AttackStep]
    entry_point: str
    target_asset: str
    objective: str
    success_probability: float = 0.5
    impact_level: str = "high"
    complexity: str = "medium"
    stealth_rating: float = 0.5  # 0 = noisy, 1 = stealthy
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "vector": self.vector.value,
            "steps": [s.to_dict() for s in self.steps],
            "entry_point": self.entry_point,
            "target_asset": self.target_asset,
            "objective": self.objective,
            "success_probability": self.success_probability,
            "impact_level": self.impact_level,
            "complexity": self.complexity,
            "stealth_rating": self.stealth_rating
        }


@dataclass
class AttackPlan:
    """Complete attack plan"""
    id: str
    target: str
    created_at: datetime
    paths: List[AttackPath]
    recommended_path: Optional[str] = None
    executive_summary: str = ""
    risk_assessment: str = ""
    timeline_estimate: str = ""
    resources_needed: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "target": self.target,
            "created_at": self.created_at.isoformat(),
            "paths": [p.to_dict() for p in self.paths],
            "recommended_path": self.recommended_path,
            "executive_summary": self.executive_summary,
            "risk_assessment": self.risk_assessment,
            "timeline_estimate": self.timeline_estimate,
            "resources_needed": self.resources_needed
        }


class AttackPlanner:
    """
    Attack Planner
    
    Analyzes the attack surface and generates strategic attack plans
    using AI and heuristic analysis.
    """
    
    # Known attack patterns
    ATTACK_PATTERNS = {
        "web_sqli": {
            "name": "SQL Injection Attack",
            "vector": AttackVector.WEB_EXPLOIT,
            "conditions": ["sql_injection_vuln"],
            "steps": [
                "Identify injection point",
                "Determine database type",
                "Extract database schema",
                "Dump sensitive data",
                "Attempt privilege escalation"
            ],
            "tools": ["sqlmap", "burp", "manual"]
        },
        "web_auth_bypass": {
            "name": "Authentication Bypass",
            "vector": AttackVector.WEB_EXPLOIT,
            "conditions": ["auth_vuln", "weak_session"],
            "steps": [
                "Analyze authentication mechanism",
                "Identify bypass method",
                "Exploit authentication flaw",
                "Access privileged functionality"
            ]
        },
        "credential_spray": {
            "name": "Password Spraying",
            "vector": AttackVector.CREDENTIAL_ATTACK,
            "conditions": ["known_usernames", "login_service"],
            "steps": [
                "Compile username list",
                "Identify common passwords",
                "Execute spray attack",
                "Validate credentials",
                "Access target systems"
            ],
            "tools": ["hydra", "crackmapexec", "spray"]
        },
        "smb_relay": {
            "name": "SMB Relay Attack",
            "vector": AttackVector.NETWORK_EXPLOIT,
            "conditions": ["smb_signing_disabled", "multiple_hosts"],
            "steps": [
                "Configure relay tool",
                "Capture authentication",
                "Relay to target",
                "Execute commands"
            ],
            "tools": ["responder", "impacket", "ntlmrelayx"]
        },
        "kerberoast": {
            "name": "Kerberoasting",
            "vector": AttackVector.CREDENTIAL_ATTACK,
            "conditions": ["domain_access", "spn_accounts"],
            "steps": [
                "Enumerate SPNs",
                "Request service tickets",
                "Extract ticket hashes",
                "Crack passwords offline",
                "Use recovered credentials"
            ],
            "tools": ["impacket", "rubeus", "hashcat"]
        }
    }
    
    def __init__(self, ai_brain: Optional[AIBrain] = None):
        self.ai_brain = ai_brain
        self.generated_plans: List[AttackPlan] = []
    
    async def generate_plan(
        self,
        attack_surface: AttackSurface,
        objectives: Optional[List[str]] = None
    ) -> AttackPlan:
        """
        Generate a comprehensive attack plan
        
        Args:
            attack_surface: Current attack surface
            objectives: Specific objectives (e.g., "gain domain admin", "access database")
            
        Returns:
            AttackPlan with prioritized attack paths
        """
        objectives = objectives or ["demonstrate significant access", "identify critical data exposure"]
        
        console.print("[cyan]üéØ Generating Attack Plan...[/cyan]")
        
        # Analyze attack surface
        analysis = self._analyze_attack_surface(attack_surface)
        
        # Generate attack paths
        paths = []
        
        # Web-based paths
        paths.extend(self._generate_web_paths(attack_surface, analysis))
        
        # Network-based paths
        paths.extend(self._generate_network_paths(attack_surface, analysis))
        
        # Credential-based paths
        paths.extend(self._generate_credential_paths(attack_surface, analysis))
        
        # AI-enhanced path generation
        if self.ai_brain:
            ai_paths = await self._ai_generate_paths(attack_surface, objectives)
            paths.extend(ai_paths)
        
        # Prioritize paths
        paths = self._prioritize_paths(paths)
        
        # Create plan
        plan = AttackPlan(
            id=f"PLAN-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            target=attack_surface.primary_target,
            created_at=datetime.now(),
            paths=paths,
            recommended_path=paths[0].id if paths else None,
            executive_summary=self._generate_summary(attack_surface, paths),
            risk_assessment=self._assess_risks(paths),
            timeline_estimate=self._estimate_timeline(paths),
            resources_needed=self._list_resources(paths)
        )
        
        self.generated_plans.append(plan)
        
        return plan
    
    def _analyze_attack_surface(self, attack_surface: AttackSurface) -> Dict[str, Any]:
        """Analyze attack surface for attack opportunities"""
        analysis = {
            "has_web_apps": False,
            "has_windows_hosts": False,
            "has_linux_hosts": False,
            "has_databases": False,
            "has_cloud": False,
            "known_usernames": [],
            "valid_credentials": [],
            "critical_vulns": [],
            "high_vulns": [],
            "services_by_type": {},
            "attack_opportunities": []
        }
        
        # Analyze assets
        for asset in attack_surface.assets.values():
            if asset.has_web_service():
                analysis["has_web_apps"] = True
            
            for service in asset.services:
                # Track services
                svc_type = service.service_type.value
                if svc_type not in analysis["services_by_type"]:
                    analysis["services_by_type"][svc_type] = []
                analysis["services_by_type"][svc_type].append(asset.name)
                
                # Identify OS
                if service.service_type in [ServiceType.SMB, ServiceType.RDP, ServiceType.WINRM]:
                    analysis["has_windows_hosts"] = True
                elif service.service_type == ServiceType.SSH:
                    analysis["has_linux_hosts"] = True
                elif service.service_type in [ServiceType.MYSQL, ServiceType.POSTGRES, ServiceType.MSSQL]:
                    analysis["has_databases"] = True
        
        # Analyze vulnerabilities
        for vuln in attack_surface.all_vulnerabilities:
            if vuln.severity == VulnSeverity.CRITICAL:
                analysis["critical_vulns"].append(vuln)
                analysis["attack_opportunities"].append({
                    "type": "vulnerability",
                    "target": vuln.affected_asset,
                    "description": vuln.title,
                    "exploitable": vuln.exploitable
                })
            elif vuln.severity == VulnSeverity.HIGH:
                analysis["high_vulns"].append(vuln)
        
        # Analyze credentials
        for cred in attack_surface.all_credentials:
            analysis["known_usernames"].append(cred.username)
            if cred.valid:
                analysis["valid_credentials"].append(cred)
                analysis["attack_opportunities"].append({
                    "type": "credential",
                    "username": cred.username,
                    "services": cred.services
                })
        
        return analysis
    
    def _generate_web_paths(
        self,
        attack_surface: AttackSurface,
        analysis: Dict[str, Any]
    ) -> List[AttackPath]:
        """Generate web-based attack paths"""
        paths = []
        
        # SQL Injection paths
        sqli_vulns = [v for v in analysis["critical_vulns"] + analysis["high_vulns"]
                      if "sql" in v.title.lower()]
        
        for vuln in sqli_vulns[:2]:  # Top 2
            path = AttackPath(
                id=f"PATH-SQLI-{len(paths)+1}",
                name=f"SQL Injection on {vuln.affected_asset}",
                description="Exploit SQL injection to extract data and potentially gain system access",
                vector=AttackVector.WEB_EXPLOIT,
                entry_point=vuln.affected_asset,
                target_asset=vuln.affected_asset,
                objective="Database access and data extraction",
                success_probability=0.8 if vuln.exploitable else 0.5,
                impact_level="critical",
                complexity="low",
                stealth_rating=0.3,
                steps=[
                    AttackStep(1, "Confirm injection", vuln.affected_asset, "sqlmap", "Union/Error-based injection"),
                    AttackStep(2, "Enumerate databases", vuln.affected_asset, "sqlmap", "--dbs"),
                    AttackStep(3, "Extract sensitive data", vuln.affected_asset, "sqlmap", "--dump"),
                    AttackStep(4, "Attempt OS command execution", vuln.affected_asset, "sqlmap", "--os-shell")
                ]
            )
            paths.append(path)
        
        # XSS paths
        xss_vulns = [v for v in analysis["critical_vulns"] + analysis["high_vulns"]
                     if "xss" in v.title.lower()]
        
        for vuln in xss_vulns[:1]:
            path = AttackPath(
                id=f"PATH-XSS-{len(paths)+1}",
                name=f"XSS Attack on {vuln.affected_asset}",
                description="Exploit XSS to steal sessions or perform actions as users",
                vector=AttackVector.WEB_EXPLOIT,
                entry_point=vuln.affected_asset,
                target_asset=vuln.affected_asset,
                objective="Session hijacking and user impersonation",
                success_probability=0.7,
                impact_level="high",
                complexity="medium",
                stealth_rating=0.6,
                steps=[
                    AttackStep(1, "Confirm XSS", vuln.affected_asset, "dalfox", "Payload testing"),
                    AttackStep(2, "Craft payload", vuln.affected_asset, "manual", "Session stealing payload"),
                    AttackStep(3, "Deploy payload", vuln.affected_asset, "manual", "Social engineering"),
                    AttackStep(4, "Capture session", "", "netcat", "Cookie receiver")
                ]
            )
            paths.append(path)
        
        return paths
    
    def _generate_network_paths(
        self,
        attack_surface: AttackSurface,
        analysis: Dict[str, Any]
    ) -> List[AttackPath]:
        """Generate network-based attack paths"""
        paths = []
        
        # SMB-based attacks for Windows environments
        if analysis["has_windows_hosts"] and "smb" in analysis["services_by_type"]:
            smb_hosts = analysis["services_by_type"]["smb"]
            
            if len(smb_hosts) > 1:
                path = AttackPath(
                    id=f"PATH-SMB-{len(paths)+1}",
                    name="SMB Relay Attack",
                    description="Relay NTLM authentication between Windows hosts",
                    vector=AttackVector.NETWORK_EXPLOIT,
                    entry_point="Network (MITM position)",
                    target_asset=smb_hosts[0],
                    objective="Gain access to Windows hosts",
                    success_probability=0.6,
                    impact_level="high",
                    complexity="medium",
                    stealth_rating=0.4,
                    steps=[
                        AttackStep(1, "Check SMB signing", smb_hosts[0], "crackmapexec", "smb signing check"),
                        AttackStep(2, "Start responder", "network", "responder", "Capture mode"),
                        AttackStep(3, "Relay authentication", smb_hosts[0], "ntlmrelayx", "Relay to target"),
                        AttackStep(4, "Execute commands", smb_hosts[0], "ntlmrelayx", "-c flag")
                    ]
                )
                paths.append(path)
        
        # SSH brute force if we have usernames
        if analysis["known_usernames"] and "ssh" in analysis["services_by_type"]:
            ssh_hosts = analysis["services_by_type"]["ssh"]
            
            path = AttackPath(
                id=f"PATH-SSH-{len(paths)+1}",
                name="SSH Credential Attack",
                description="Attempt SSH access with known usernames",
                vector=AttackVector.CREDENTIAL_ATTACK,
                entry_point=ssh_hosts[0],
                target_asset=ssh_hosts[0],
                objective="SSH access to Linux hosts",
                success_probability=0.4,
                impact_level="high",
                complexity="low",
                stealth_rating=0.2,  # Noisy
                steps=[
                    AttackStep(1, "Prepare username list", "", "manual", f"Users: {', '.join(analysis['known_usernames'][:5])}"),
                    AttackStep(2, "Run password spray", ssh_hosts[0], "hydra", "Common passwords"),
                    AttackStep(3, "Validate access", ssh_hosts[0], "ssh", "Login attempt"),
                    AttackStep(4, "Escalate privileges", ssh_hosts[0], "manual", "Privilege escalation")
                ]
            )
            paths.append(path)
        
        return paths
    
    def _generate_credential_paths(
        self,
        attack_surface: AttackSurface,
        analysis: Dict[str, Any]
    ) -> List[AttackPath]:
        """Generate credential-based attack paths"""
        paths = []
        
        # Use valid credentials
        for cred in analysis["valid_credentials"][:2]:
            for service in cred.services[:1]:
                path = AttackPath(
                    id=f"PATH-CRED-{len(paths)+1}",
                    name=f"Credential-Based Access ({cred.username})",
                    description=f"Use valid credentials for {cred.username} on {service}",
                    vector=AttackVector.CREDENTIAL_ATTACK,
                    entry_point=service,
                    target_asset=service,
                    objective="Direct system access with valid credentials",
                    success_probability=0.9,  # High because creds are valid
                    impact_level="high",
                    complexity="low",
                    stealth_rating=0.8,  # Legitimate-looking access
                    steps=[
                        AttackStep(1, "Verify credentials", service, "manual", "Login attempt"),
                        AttackStep(2, "Enumerate access", service, "manual", "Check permissions"),
                        AttackStep(3, "Collect sensitive data", service, "manual", "Data access"),
                        AttackStep(4, "Check lateral movement", service, "crackmapexec", "Network pivoting")
                    ]
                )
                paths.append(path)
        
        return paths
    
    async def _ai_generate_paths(
        self,
        attack_surface: AttackSurface,
        objectives: List[str]
    ) -> List[AttackPath]:
        """Use AI to generate additional attack paths"""
        paths = []
        
        if not self.ai_brain:
            return paths
        
        try:
            await self.ai_brain.initialize()
            
            response = await self.ai_brain.ai_client.analyze(
                prompt=f"""Based on this attack surface, suggest 2-3 creative attack paths:

Target: {attack_surface.primary_target}
Assets: {len(attack_surface.assets)}
Vulnerabilities: {len(attack_surface.all_vulnerabilities)}
Credentials: {len(attack_surface.all_credentials)}

Key findings:
{json.dumps([v.to_dict() for v in attack_surface.get_critical_vulnerabilities()[:3]], indent=2)}

Objectives: {', '.join(objectives)}

Suggest attack paths in JSON format:
{{
    "paths": [
        {{
            "name": "attack name",
            "description": "description",
            "entry_point": "where to start",
            "steps": ["step 1", "step 2"],
            "tools": ["tool1", "tool2"],
            "success_probability": 0.5,
            "impact": "high/medium/low"
        }}
    ]
}}""",
                system_prompt="You are an expert penetration tester. Suggest realistic attack paths."
            )
            
            # Parse AI response
            import re
            json_match = re.search(r'\{[\s\S]*\}', response.content)
            if json_match:
                data = json.loads(json_match.group())
                for i, p in enumerate(data.get("paths", [])):
                    path = AttackPath(
                        id=f"PATH-AI-{i+1}",
                        name=p.get("name", "AI-Generated Path"),
                        description=p.get("description", ""),
                        vector=AttackVector.WEB_EXPLOIT,
                        entry_point=p.get("entry_point", ""),
                        target_asset=attack_surface.primary_target,
                        objective=p.get("description", ""),
                        success_probability=p.get("success_probability", 0.5),
                        impact_level=p.get("impact", "medium"),
                        complexity="medium",
                        stealth_rating=0.5,
                        steps=[
                            AttackStep(j+1, step, "", p.get("tools", ["manual"])[0] if p.get("tools") else "manual")
                            for j, step in enumerate(p.get("steps", []))
                        ]
                    )
                    paths.append(path)
        except Exception as e:
            console.print(f"[yellow]AI path generation failed: {e}[/yellow]")
        
        return paths
    
    def _prioritize_paths(self, paths: List[AttackPath]) -> List[AttackPath]:
        """Prioritize attack paths by effectiveness"""
        def path_score(path: AttackPath) -> float:
            score = path.success_probability * 100
            
            # Impact bonus
            if path.impact_level == "critical":
                score += 30
            elif path.impact_level == "high":
                score += 20
            elif path.impact_level == "medium":
                score += 10
            
            # Complexity bonus (easier = better)
            if path.complexity == "low":
                score += 15
            elif path.complexity == "medium":
                score += 5
            
            # Stealth bonus
            score += path.stealth_rating * 10
            
            return score
        
        return sorted(paths, key=path_score, reverse=True)
    
    def _generate_summary(self, attack_surface: AttackSurface, paths: List[AttackPath]) -> str:
        """Generate executive summary"""
        summary = attack_surface.get_summary()
        
        if not paths:
            return "No viable attack paths identified. Additional reconnaissance recommended."
        
        top_path = paths[0]
        return f"""Attack surface analysis of {attack_surface.primary_target} identified {len(paths)} potential attack paths.

Primary recommended approach: {top_path.name}
Success probability: {top_path.success_probability*100:.0f}%
Expected impact: {top_path.impact_level}

Key statistics:
- Total assets: {summary['total_assets']}
- Critical vulnerabilities: {summary['vulnerabilities_by_severity']['critical']}
- High vulnerabilities: {summary['vulnerabilities_by_severity']['high']}
- Valid credentials: {summary['valid_credentials']}
"""
    
    def _assess_risks(self, paths: List[AttackPath]) -> str:
        """Assess risks of attack paths"""
        if not paths:
            return "No paths to assess"
        
        high_risk = [p for p in paths if p.stealth_rating < 0.3]
        
        return f"""Risk Assessment:
- {len(paths)} attack paths identified
- {len(high_risk)} paths with high detection risk
- Recommended: Start with highest stealth rating paths
- Monitor for defensive responses during testing
"""
    
    def _estimate_timeline(self, paths: List[AttackPath]) -> str:
        """Estimate timeline for attack paths"""
        if not paths:
            return "N/A"
        
        total_steps = sum(len(p.steps) for p in paths)
        hours_estimate = total_steps * 0.5  # 30 min per step estimate
        
        return f"Estimated {hours_estimate:.1f} hours for all paths ({total_steps} total steps)"
    
    def _list_resources(self, paths: List[AttackPath]) -> List[str]:
        """List resources needed"""
        tools = set()
        for path in paths:
            for step in path.steps:
                if step.tool:
                    tools.add(step.tool)
        
        return list(tools)
    
    def display_plan(self, plan: AttackPlan) -> None:
        """Display attack plan in rich format"""
        console.print("\n")
        console.print(f"[bold cyan]‚ïê‚ïê‚ïê Attack Plan: {plan.id} ‚ïê‚ïê‚ïê[/bold cyan]")
        console.print(f"Target: {plan.target}")
        console.print(f"Created: {plan.created_at.strftime('%Y-%m-%d %H:%M')}\n")
        
        console.print("[bold]Executive Summary:[/bold]")
        console.print(plan.executive_summary)
        console.print()
        
        # Attack paths table
        table = Table(title="Attack Paths", show_header=True)
        table.add_column("ID", style="cyan")
        table.add_column("Name", style="white")
        table.add_column("Vector", style="yellow")
        table.add_column("Success", style="green")
        table.add_column("Impact", style="red")
        table.add_column("Stealth", style="blue")
        
        for path in plan.paths:
            rec = "‚Üí " if path.id == plan.recommended_path else "  "
            table.add_row(
                f"{rec}{path.id}",
                path.name[:40],
                path.vector.value,
                f"{path.success_probability*100:.0f}%",
                path.impact_level,
                f"{path.stealth_rating:.1f}"
            )
        
        console.print(table)
        console.print()
        
        # Detailed path view (recommended)
        if plan.recommended_path:
            rec_path = next((p for p in plan.paths if p.id == plan.recommended_path), None)
            if rec_path:
                console.print(f"[bold green]Recommended Path: {rec_path.name}[/bold green]")
                
                tree = Tree(f"[cyan]{rec_path.name}[/cyan]")
                for step in rec_path.steps:
                    tree.add(f"[{step.order}] {step.action} ({step.tool})")
                
                console.print(tree)
        
        console.print(f"\n[bold]Resources Needed:[/bold] {', '.join(plan.resources_needed)}")
        console.print(f"[bold]Timeline:[/bold] {plan.timeline_estimate}")
