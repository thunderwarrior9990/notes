"""
Attack Surface Model
====================

Data structures to represent the discovered attack surface.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Set
from enum import Enum
import json


class AssetType(Enum):
    """Types of assets"""
    DOMAIN = "domain"
    SUBDOMAIN = "subdomain"
    IP_ADDRESS = "ip_address"
    HOST = "host"
    WEB_APPLICATION = "web_application"
    API = "api"
    DATABASE = "database"
    NETWORK_DEVICE = "network_device"
    CLOUD_RESOURCE = "cloud_resource"
    CONTAINER = "container"
    USER_ACCOUNT = "user_account"
    CREDENTIAL = "credential"


class ServiceType(Enum):
    """Types of services"""
    HTTP = "http"
    HTTPS = "https"
    SSH = "ssh"
    FTP = "ftp"
    SMB = "smb"
    RDP = "rdp"
    MYSQL = "mysql"
    POSTGRES = "postgres"
    MSSQL = "mssql"
    MONGODB = "mongodb"
    REDIS = "redis"
    DNS = "dns"
    SMTP = "smtp"
    LDAP = "ldap"
    WINRM = "winrm"
    VNC = "vnc"
    TELNET = "telnet"
    UNKNOWN = "unknown"


class VulnSeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnStatus(Enum):
    """Vulnerability status"""
    DISCOVERED = "discovered"
    CONFIRMED = "confirmed"
    EXPLOITED = "exploited"
    FALSE_POSITIVE = "false_positive"


@dataclass
class Technology:
    """Detected technology"""
    name: str
    version: str = ""
    category: str = ""  # cms, framework, server, language, etc.
    cpe: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "version": self.version,
            "category": self.category,
            "cpe": self.cpe
        }


@dataclass
class Service:
    """A network service"""
    port: int
    protocol: str = "tcp"
    service_type: ServiceType = ServiceType.UNKNOWN
    name: str = ""
    version: str = ""
    banner: str = ""
    state: str = "open"
    technologies: List[Technology] = field(default_factory=list)
    vulnerabilities: List["Vulnerability"] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "port": self.port,
            "protocol": self.protocol,
            "service_type": self.service_type.value,
            "name": self.name,
            "version": self.version,
            "banner": self.banner,
            "state": self.state,
            "technologies": [t.to_dict() for t in self.technologies],
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "metadata": self.metadata
        }


@dataclass
class Credential:
    """Discovered credential"""
    username: str
    password: str = ""
    hash: str = ""
    hash_type: str = ""
    source: str = ""
    valid: bool = False
    services: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "username": self.username,
            "password": "***" if self.password else "",
            "hash": self.hash[:20] + "..." if len(self.hash) > 20 else self.hash,
            "hash_type": self.hash_type,
            "source": self.source,
            "valid": self.valid,
            "services": self.services
        }


@dataclass
class Vulnerability:
    """A discovered vulnerability"""
    id: str
    title: str
    severity: VulnSeverity
    description: str = ""
    affected_asset: str = ""
    affected_service: str = ""
    cve_id: str = ""
    cwe_id: str = ""
    cvss_score: float = 0.0
    evidence: str = ""
    payload: str = ""
    remediation: str = ""
    references: List[str] = field(default_factory=list)
    status: VulnStatus = VulnStatus.DISCOVERED
    exploitable: bool = False
    exploit_available: bool = False
    discovered_by: str = ""
    discovered_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "title": self.title,
            "severity": self.severity.value,
            "description": self.description,
            "affected_asset": self.affected_asset,
            "affected_service": self.affected_service,
            "cve_id": self.cve_id,
            "cwe_id": self.cwe_id,
            "cvss_score": self.cvss_score,
            "evidence": self.evidence[:500] if self.evidence else "",
            "payload": self.payload,
            "remediation": self.remediation,
            "references": self.references,
            "status": self.status.value,
            "exploitable": self.exploitable,
            "exploit_available": self.exploit_available,
            "discovered_by": self.discovered_by,
            "discovered_at": self.discovered_at.isoformat()
        }


@dataclass
class WebEndpoint:
    """A web endpoint/URL"""
    url: str
    method: str = "GET"
    status_code: int = 0
    content_type: str = ""
    content_length: int = 0
    title: str = ""
    parameters: List[str] = field(default_factory=list)
    forms: List[Dict[str, Any]] = field(default_factory=list)
    technologies: List[Technology] = field(default_factory=list)
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "url": self.url,
            "method": self.method,
            "status_code": self.status_code,
            "content_type": self.content_type,
            "title": self.title,
            "parameters": self.parameters,
            "technologies": [t.to_dict() for t in self.technologies]
        }


@dataclass
class Asset:
    """An asset in the attack surface"""
    id: str
    name: str
    asset_type: AssetType
    ip_addresses: List[str] = field(default_factory=list)
    hostnames: List[str] = field(default_factory=list)
    services: List[Service] = field(default_factory=list)
    technologies: List[Technology] = field(default_factory=list)
    web_endpoints: List[WebEndpoint] = field(default_factory=list)
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    credentials: List[Credential] = field(default_factory=list)
    parent_asset: Optional[str] = None
    child_assets: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    discovered_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "asset_type": self.asset_type.value,
            "ip_addresses": self.ip_addresses,
            "hostnames": self.hostnames,
            "services": [s.to_dict() for s in self.services],
            "technologies": [t.to_dict() for t in self.technologies],
            "web_endpoints_count": len(self.web_endpoints),
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "credentials_count": len(self.credentials),
            "metadata": self.metadata,
            "discovered_at": self.discovered_at.isoformat()
        }
    
    def get_open_ports(self) -> List[int]:
        """Get list of open ports"""
        return [s.port for s in self.services if s.state == "open"]
    
    def get_vulnerabilities_by_severity(self, severity: VulnSeverity) -> List[Vulnerability]:
        """Get vulnerabilities by severity"""
        return [v for v in self.vulnerabilities if v.severity == severity]
    
    def has_web_service(self) -> bool:
        """Check if asset has web services"""
        web_ports = [80, 443, 8080, 8443, 8000, 8888, 3000, 5000]
        return any(s.port in web_ports for s in self.services)


class AttackSurface:
    """
    Complete attack surface model
    
    Maintains all discovered assets, services, vulnerabilities,
    and credentials during the penetration test.
    """
    
    def __init__(self, primary_target: str):
        self.primary_target = primary_target
        self.assets: Dict[str, Asset] = {}
        self.domains: Set[str] = set()
        self.ip_addresses: Set[str] = set()
        self.subdomains: Set[str] = set()
        self.all_vulnerabilities: List[Vulnerability] = []
        self.all_credentials: List[Credential] = []
        self.scan_history: List[Dict[str, Any]] = []
        self.notes: List[str] = []
        self.created_at: datetime = datetime.now()
        self.last_updated: datetime = datetime.now()
    
    def add_asset(self, asset: Asset) -> None:
        """Add an asset to the attack surface"""
        self.assets[asset.id] = asset
        
        # Track domains and IPs
        for ip in asset.ip_addresses:
            self.ip_addresses.add(ip)
        
        for hostname in asset.hostnames:
            if asset.asset_type == AssetType.SUBDOMAIN:
                self.subdomains.add(hostname)
            elif asset.asset_type == AssetType.DOMAIN:
                self.domains.add(hostname)
        
        self.last_updated = datetime.now()
    
    def get_asset(self, asset_id: str) -> Optional[Asset]:
        """Get asset by ID"""
        return self.assets.get(asset_id)
    
    def find_assets_by_type(self, asset_type: AssetType) -> List[Asset]:
        """Find all assets of a specific type"""
        return [a for a in self.assets.values() if a.asset_type == asset_type]
    
    def find_assets_with_service(self, service_type: ServiceType) -> List[Asset]:
        """Find assets with a specific service type"""
        results = []
        for asset in self.assets.values():
            for service in asset.services:
                if service.service_type == service_type:
                    results.append(asset)
                    break
        return results
    
    def add_vulnerability(self, vuln: Vulnerability) -> None:
        """Add a vulnerability"""
        self.all_vulnerabilities.append(vuln)
        
        # Also add to the affected asset if exists
        if vuln.affected_asset and vuln.affected_asset in self.assets:
            self.assets[vuln.affected_asset].vulnerabilities.append(vuln)
        
        self.last_updated = datetime.now()
    
    def add_credential(self, cred: Credential) -> None:
        """Add a credential"""
        self.all_credentials.append(cred)
        self.last_updated = datetime.now()
    
    def get_critical_vulnerabilities(self) -> List[Vulnerability]:
        """Get all critical vulnerabilities"""
        return [v for v in self.all_vulnerabilities if v.severity == VulnSeverity.CRITICAL]
    
    def get_high_value_targets(self) -> List[Asset]:
        """Get high-value targets based on services and vulnerabilities"""
        high_value = []
        for asset in self.assets.values():
            score = 0
            
            # Score based on vulnerabilities
            score += len(asset.get_vulnerabilities_by_severity(VulnSeverity.CRITICAL)) * 10
            score += len(asset.get_vulnerabilities_by_severity(VulnSeverity.HIGH)) * 5
            
            # Score based on services
            if any(s.service_type in [ServiceType.SMB, ServiceType.RDP, ServiceType.WINRM] for s in asset.services):
                score += 5  # Windows services
            if any(s.service_type == ServiceType.SSH for s in asset.services):
                score += 3  # SSH access
            if asset.has_web_service():
                score += 2
            
            # Score based on credentials
            score += len(asset.credentials) * 5
            
            if score > 0:
                high_value.append((asset, score))
        
        # Sort by score descending
        high_value.sort(key=lambda x: x[1], reverse=True)
        return [a[0] for a in high_value]
    
    def get_attack_paths(self) -> List[Dict[str, Any]]:
        """Identify potential attack paths"""
        paths = []
        
        # Find credential-based paths
        for cred in self.all_credentials:
            if cred.valid:
                for service in cred.services:
                    paths.append({
                        "type": "credential_access",
                        "credential": cred.username,
                        "service": service,
                        "description": f"Valid credential for {service}"
                    })
        
        # Find exploit-based paths
        for vuln in self.all_vulnerabilities:
            if vuln.exploitable or vuln.exploit_available:
                paths.append({
                    "type": "exploit",
                    "vulnerability": vuln.id,
                    "title": vuln.title,
                    "severity": vuln.severity.value,
                    "asset": vuln.affected_asset,
                    "description": f"Exploitable vulnerability: {vuln.title}"
                })
        
        return paths
    
    def get_summary(self) -> Dict[str, Any]:
        """Get attack surface summary"""
        vuln_by_severity = {
            "critical": len([v for v in self.all_vulnerabilities if v.severity == VulnSeverity.CRITICAL]),
            "high": len([v for v in self.all_vulnerabilities if v.severity == VulnSeverity.HIGH]),
            "medium": len([v for v in self.all_vulnerabilities if v.severity == VulnSeverity.MEDIUM]),
            "low": len([v for v in self.all_vulnerabilities if v.severity == VulnSeverity.LOW]),
            "info": len([v for v in self.all_vulnerabilities if v.severity == VulnSeverity.INFO]),
        }
        
        return {
            "primary_target": self.primary_target,
            "total_assets": len(self.assets),
            "total_domains": len(self.domains),
            "total_subdomains": len(self.subdomains),
            "total_ips": len(self.ip_addresses),
            "total_vulnerabilities": len(self.all_vulnerabilities),
            "vulnerabilities_by_severity": vuln_by_severity,
            "total_credentials": len(self.all_credentials),
            "valid_credentials": len([c for c in self.all_credentials if c.valid]),
            "high_value_targets": len(self.get_high_value_targets()),
            "attack_paths": len(self.get_attack_paths()),
            "scan_count": len(self.scan_history),
            "created_at": self.created_at.isoformat(),
            "last_updated": self.last_updated.isoformat()
        }
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert entire attack surface to dictionary"""
        return {
            "summary": self.get_summary(),
            "assets": {k: v.to_dict() for k, v in self.assets.items()},
            "domains": list(self.domains),
            "subdomains": list(self.subdomains),
            "ip_addresses": list(self.ip_addresses),
            "vulnerabilities": [v.to_dict() for v in self.all_vulnerabilities],
            "credentials": [c.to_dict() for c in self.all_credentials],
            "attack_paths": self.get_attack_paths(),
            "notes": self.notes
        }
    
    def to_json(self, indent: int = 2) -> str:
        """Export attack surface as JSON"""
        return json.dumps(self.to_dict(), indent=indent, default=str)
    
    def log_scan(self, tool: str, target: str, findings: int) -> None:
        """Log a scan in history"""
        self.scan_history.append({
            "tool": tool,
            "target": target,
            "findings": findings,
            "timestamp": datetime.now().isoformat()
        })
    
    def add_note(self, note: str) -> None:
        """Add a note"""
        self.notes.append(f"[{datetime.now().isoformat()}] {note}")
