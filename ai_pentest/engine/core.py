"""
Pentest Engine Core
===================

The main orchestrator for AI-driven penetration testing.
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Type
import json

from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich.live import Live
from rich.table import Table

from .attack_surface import AttackSurface, Asset, AssetType
from .brain import AIBrain, AIDecision, DecisionType
from .phases import (
    PentestPhase, PhaseResult,
    ReconnaissancePhase,
    EnumerationPhase,
    VulnerabilityPhase,
    ExploitationPhase,
    PostExploitationPhase,
    ReportingPhase
)
from .planner import AttackPlanner, AttackPlan
from ..tools.manager import ToolManager


console = Console()


@dataclass
class EngineConfig:
    """Configuration for the pentest engine"""
    target: str
    scope: List[str] = field(default_factory=list)  # Additional in-scope targets
    out_of_scope: List[str] = field(default_factory=list)
    output_dir: str = "./pentest_output"
    
    # Phase configuration
    phases_to_run: List[str] = field(default_factory=lambda: [
        "reconnaissance", "enumeration", "vulnerability", "exploitation", "reporting"
    ])
    
    # AI configuration
    ai_enabled: bool = True
    api_key: Optional[str] = None
    
    # Automation settings
    auto_mode: bool = True  # Let AI make decisions
    max_iterations_per_phase: int = 10
    stop_on_critical: bool = False  # Stop if critical vuln found
    
    # Safety settings
    safe_mode: bool = True  # Avoid aggressive scans
    respect_rate_limits: bool = True
    max_concurrent_tools: int = 5
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "scope": self.scope,
            "out_of_scope": self.out_of_scope,
            "output_dir": self.output_dir,
            "phases_to_run": self.phases_to_run,
            "ai_enabled": self.ai_enabled,
            "auto_mode": self.auto_mode,
            "max_iterations_per_phase": self.max_iterations_per_phase,
            "safe_mode": self.safe_mode
        }


@dataclass
class EngineResult:
    """Result from a complete pentest run"""
    success: bool
    target: str
    start_time: datetime
    end_time: Optional[datetime] = None
    config: Optional[EngineConfig] = None
    phase_results: Dict[str, PhaseResult] = field(default_factory=dict)
    attack_plan: Optional[AttackPlan] = None
    total_findings: int = 0
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    report_path: str = ""
    errors: List[str] = field(default_factory=list)
    
    @property
    def duration(self) -> float:
        if self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "target": self.target,
            "duration_seconds": self.duration,
            "phases_completed": list(self.phase_results.keys()),
            "total_findings": self.total_findings,
            "total_vulnerabilities": self.total_vulnerabilities,
            "critical_count": self.critical_count,
            "high_count": self.high_count,
            "report_path": self.report_path,
            "errors": self.errors
        }


class PentestEngine:
    """
    AI-Driven Penetration Testing Engine
    
    Orchestrates the complete penetration testing process:
    1. Reconnaissance - Discover assets and gather information
    2. Enumeration - Deep dive into discovered services
    3. Vulnerability Assessment - Identify security issues
    4. Exploitation - Validate and exploit vulnerabilities
    5. Post-Exploitation - Demonstrate impact
    6. Reporting - Generate comprehensive report
    
    The AI brain makes decisions throughout the process,
    analyzing tool outputs and determining next steps.
    """
    
    PHASE_CLASSES: Dict[str, Type[PentestPhase]] = {
        "reconnaissance": ReconnaissancePhase,
        "enumeration": EnumerationPhase,
        "vulnerability": VulnerabilityPhase,
        "exploitation": ExploitationPhase,
        "post_exploitation": PostExploitationPhase,
        "reporting": ReportingPhase
    }
    
    def __init__(self, config: EngineConfig):
        self.config = config
        self.output_dir = Path(config.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize components
        self.attack_surface = AttackSurface(config.target)
        self.tool_manager = ToolManager(output_dir=self.output_dir)
        self.ai_brain = AIBrain(api_key=config.api_key) if config.ai_enabled else None
        self.attack_planner = AttackPlanner(self.ai_brain)
        
        # State
        self.result = EngineResult(
            success=False,
            target=config.target,
            start_time=datetime.now(),
            config=config
        )
        self.current_phase: Optional[str] = None
        self._running = False
    
    async def run(self) -> EngineResult:
        """
        Run the complete penetration test
        
        Returns:
            EngineResult with all findings and phase results
        """
        self._running = True
        
        try:
            self._display_banner()
            self._display_config()
            
            # Check tool availability
            console.print("\n[bold]Checking Tool Availability...[/bold]")
            installed = await self.tool_manager.check_installed_tools()
            available_count = sum(1 for v in installed.values() if v)
            console.print(f"[green]✓ {available_count}/{len(installed)} tools available[/green]")
            
            # Initialize primary target asset
            self._initialize_target()
            
            # Run phases
            for phase_name in self.config.phases_to_run:
                if not self._running:
                    console.print("[yellow]Pentest stopped by user[/yellow]")
                    break
                
                self.current_phase = phase_name
                
                if phase_name not in self.PHASE_CLASSES:
                    console.print(f"[yellow]Unknown phase: {phase_name}[/yellow]")
                    continue
                
                # Create phase instance
                phase_class = self.PHASE_CLASSES[phase_name]
                phase = phase_class(
                    tool_manager=self.tool_manager,
                    ai_brain=self.ai_brain,
                    attack_surface=self.attack_surface,
                    max_iterations=self.config.max_iterations_per_phase,
                    auto_mode=self.config.auto_mode
                )
                
                # Execute phase
                console.print(f"\n[bold cyan]{'═' * 50}[/bold cyan]")
                try:
                    phase_result = await phase.execute()
                    self.result.phase_results[phase_name] = phase_result
                    
                    # Update totals
                    self.result.total_findings += phase_result.findings_count
                    self.result.total_vulnerabilities += phase_result.new_vulnerabilities
                    
                except Exception as e:
                    console.print(f"[red]Phase {phase_name} failed: {e}[/red]")
                    self.result.errors.append(f"Phase {phase_name}: {str(e)}")
                
                # Check for critical findings
                if self.config.stop_on_critical:
                    critical = self.attack_surface.get_critical_vulnerabilities()
                    if critical:
                        console.print("[red]Critical vulnerability found! Stopping as configured.[/red]")
                        break
                
                # Generate attack plan after vulnerability phase
                if phase_name == "vulnerability" and self.config.ai_enabled:
                    console.print("\n[bold]Generating Attack Plan...[/bold]")
                    self.result.attack_plan = await self.attack_planner.generate_plan(
                        self.attack_surface
                    )
                    self.attack_planner.display_plan(self.result.attack_plan)
            
            # Calculate final statistics
            self._calculate_statistics()
            
            self.result.success = True
            
        except Exception as e:
            console.print(f"[red]Engine error: {e}[/red]")
            self.result.errors.append(str(e))
            raise
        finally:
            self.result.end_time = datetime.now()
            self._running = False
            
            if self.ai_brain:
                await self.ai_brain.close()
            
            # Save results
            await self._save_results()
            
            self._display_final_summary()
        
        return self.result
    
    def stop(self) -> None:
        """Stop the pentest gracefully"""
        self._running = False
        console.print("[yellow]Stopping pentest...[/yellow]")
    
    def _display_banner(self) -> None:
        """Display the engine banner"""
        banner = """
╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║     █████╗ ██╗    ██████╗ ███████╗███╗   ██╗████████╗        ║
║    ██╔══██╗██║    ██╔══██╗██╔════╝████╗  ██║╚══██╔══╝        ║
║    ███████║██║    ██████╔╝█████╗  ██╔██╗ ██║   ██║           ║
║    ██╔══██║██║    ██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║           ║
║    ██║  ██║██║    ██║     ███████╗██║ ╚████║   ██║           ║
║    ╚═╝  ╚═╝╚═╝    ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝           ║
║                                                               ║
║         AI-Powered Penetration Testing Engine                 ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
"""
        console.print(banner, style="cyan")
    
    def _display_config(self) -> None:
        """Display engine configuration"""
        table = Table(title="Engine Configuration", show_header=True)
        table.add_column("Setting", style="cyan")
        table.add_column("Value", style="white")
        
        table.add_row("Target", self.config.target)
        table.add_row("Output Directory", str(self.output_dir))
        table.add_row("Phases", ", ".join(self.config.phases_to_run))
        table.add_row("AI Enabled", "✓" if self.config.ai_enabled else "✗")
        table.add_row("Auto Mode", "✓" if self.config.auto_mode else "✗")
        table.add_row("Safe Mode", "✓" if self.config.safe_mode else "✗")
        table.add_row("Max Iterations", str(self.config.max_iterations_per_phase))
        
        console.print(table)
    
    def _initialize_target(self) -> None:
        """Initialize the primary target asset"""
        target = self.config.target
        
        # Determine target type
        import re
        ip_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
        
        if re.match(ip_pattern, target):
            asset_type = AssetType.IP_ADDRESS
            ip_addresses = [target]
            hostnames = []
        else:
            # Assume domain
            asset_type = AssetType.DOMAIN
            ip_addresses = []
            hostnames = [target]
            self.attack_surface.domains.add(target)
        
        # Create primary asset
        primary_asset = Asset(
            id=f"primary-{target}",
            name=target,
            asset_type=asset_type,
            ip_addresses=ip_addresses,
            hostnames=hostnames
        )
        
        self.attack_surface.add_asset(primary_asset)
        
        # Add scope
        for scope_target in self.config.scope:
            self.attack_surface.domains.add(scope_target)
        
        console.print(f"\n[green]✓ Primary target initialized: {target}[/green]")
    
    def _calculate_statistics(self) -> None:
        """Calculate final statistics"""
        from .attack_surface import VulnSeverity
        
        for vuln in self.attack_surface.all_vulnerabilities:
            if vuln.severity == VulnSeverity.CRITICAL:
                self.result.critical_count += 1
            elif vuln.severity == VulnSeverity.HIGH:
                self.result.high_count += 1
    
    async def _save_results(self) -> None:
        """Save all results to disk"""
        # Save attack surface
        surface_path = self.output_dir / "attack_surface.json"
        with open(surface_path, "w") as f:
            f.write(self.attack_surface.to_json())
        
        # Save engine result
        result_path = self.output_dir / "engine_result.json"
        with open(result_path, "w") as f:
            json.dump(self.result.to_dict(), f, indent=2, default=str)
        
        # Save attack plan if available
        if self.result.attack_plan:
            plan_path = self.output_dir / "attack_plan.json"
            with open(plan_path, "w") as f:
                json.dump(self.result.attack_plan.to_dict(), f, indent=2, default=str)
        
        console.print(f"\n[green]Results saved to: {self.output_dir}[/green]")
    
    def _display_final_summary(self) -> None:
        """Display final summary"""
        summary = self.attack_surface.get_summary()
        
        console.print("\n")
        console.print(Panel(
            f"""[bold]Penetration Test Complete[/bold]

Target: {self.config.target}
Duration: {self.result.duration:.1f} seconds

[bold]Findings Summary:[/bold]
• Total Assets: {summary['total_assets']}
• Subdomains: {summary['total_subdomains']}
• Vulnerabilities: {summary['total_vulnerabilities']}
  - Critical: {summary['vulnerabilities_by_severity']['critical']}
  - High: {summary['vulnerabilities_by_severity']['high']}
  - Medium: {summary['vulnerabilities_by_severity']['medium']}
  - Low: {summary['vulnerabilities_by_severity']['low']}
• Credentials: {summary['total_credentials']} ({summary['valid_credentials']} valid)
• Attack Paths: {summary['attack_paths']}

[bold]Phases Completed:[/bold] {len(self.result.phase_results)}/{len(self.config.phases_to_run)}
[bold]Errors:[/bold] {len(self.result.errors)}

Output: {self.output_dir}
""",
            title="✅ Pentest Summary",
            style="green" if self.result.success else "yellow"
        ))
    
    async def run_phase(self, phase_name: str) -> PhaseResult:
        """Run a single phase"""
        if phase_name not in self.PHASE_CLASSES:
            raise ValueError(f"Unknown phase: {phase_name}")
        
        phase_class = self.PHASE_CLASSES[phase_name]
        phase = phase_class(
            tool_manager=self.tool_manager,
            ai_brain=self.ai_brain,
            attack_surface=self.attack_surface,
            max_iterations=self.config.max_iterations_per_phase,
            auto_mode=self.config.auto_mode
        )
        
        return await phase.execute()
    
    def get_status(self) -> Dict[str, Any]:
        """Get current engine status"""
        return {
            "running": self._running,
            "current_phase": self.current_phase,
            "target": self.config.target,
            "assets_discovered": len(self.attack_surface.assets),
            "vulnerabilities_found": len(self.attack_surface.all_vulnerabilities),
            "phases_completed": list(self.result.phase_results.keys()),
            "duration_so_far": (datetime.now() - self.result.start_time).total_seconds()
        }


async def run_pentest(
    target: str,
    output_dir: str = "./pentest_output",
    phases: Optional[List[str]] = None,
    ai_enabled: bool = True,
    auto_mode: bool = True,
    api_key: Optional[str] = None
) -> EngineResult:
    """
    Convenience function to run a penetration test
    
    Args:
        target: Primary target (domain or IP)
        output_dir: Output directory for results
        phases: List of phases to run (default: all)
        ai_enabled: Enable AI analysis
        auto_mode: Let AI make decisions
        api_key: API key for AI services
        
    Returns:
        EngineResult with all findings
    """
    config = EngineConfig(
        target=target,
        output_dir=output_dir,
        phases_to_run=phases or ["reconnaissance", "enumeration", "vulnerability", "reporting"],
        ai_enabled=ai_enabled,
        auto_mode=auto_mode,
        api_key=api_key
    )
    
    engine = PentestEngine(config)
    return await engine.run()
