"""
Pentest Phases
==============

Individual phases of the penetration testing methodology.
"""

import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Type

from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

from .attack_surface import (
    AttackSurface, Asset, Service, Vulnerability, Technology,
    Credential, WebEndpoint, AssetType, ServiceType, VulnSeverity
)
from .brain import AIBrain, AIDecision, ToolAnalysis, DecisionType
from ..tools.base import ToolWrapper, ToolResult, ToolStatus
from ..tools.manager import ToolManager


console = Console()


@dataclass
class PhaseResult:
    """Result from a phase execution"""
    phase_name: str
    success: bool
    start_time: datetime
    end_time: Optional[datetime] = None
    tools_run: List[str] = field(default_factory=list)
    findings_count: int = 0
    new_assets: int = 0
    new_vulnerabilities: int = 0
    ai_analyses: List[ToolAnalysis] = field(default_factory=list)
    decisions_made: List[AIDecision] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    notes: str = ""
    
    @property
    def duration(self) -> float:
        if self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "phase_name": self.phase_name,
            "success": self.success,
            "duration_seconds": self.duration,
            "tools_run": self.tools_run,
            "findings_count": self.findings_count,
            "new_assets": self.new_assets,
            "new_vulnerabilities": self.new_vulnerabilities,
            "ai_analyses": [a.to_dict() for a in self.ai_analyses],
            "decisions_made": [d.to_dict() for d in self.decisions_made],
            "errors": self.errors,
            "notes": self.notes
        }


class PentestPhase(ABC):
    """Base class for pentest phases"""
    
    PHASE_NAME: str = ""
    DESCRIPTION: str = ""
    DEFAULT_TOOLS: List[str] = []
    MAX_CONCURRENT_TOOLS: int = 5  # Maximum parallel tool executions
    
    def __init__(
        self,
        tool_manager: ToolManager,
        ai_brain: AIBrain,
        attack_surface: AttackSurface,
        max_iterations: int = 10,
        auto_mode: bool = True
    ):
        self.tool_manager = tool_manager
        self.ai_brain = ai_brain
        self.attack_surface = attack_surface
        self.max_iterations = max_iterations
        self.auto_mode = auto_mode
        self._tool_semaphore = asyncio.Semaphore(self.MAX_CONCURRENT_TOOLS)
        self.result = PhaseResult(
            phase_name=self.PHASE_NAME,
            success=False,
            start_time=datetime.now()
        )
    
    @abstractmethod
    async def execute(self) -> PhaseResult:
        """Execute the phase"""
        pass
    
    @abstractmethod
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process results from a tool and update attack surface"""
        pass
    
    def _show_phase_banner(self) -> None:
        """Show phase banner"""
        console.print(Panel(
            f"[bold]{self.DESCRIPTION}[/bold]\n\n"
            f"Target: {self.attack_surface.primary_target}\n"
            f"Current Assets: {len(self.attack_surface.assets)}\n"
            f"Current Vulns: {len(self.attack_surface.all_vulnerabilities)}",
            title=f"ðŸ“ Phase: {self.PHASE_NAME}",
            style="cyan"
        ))
    
    async def _run_tool_with_analysis(
        self,
        tool_name: str,
        target: str,
        **kwargs
    ) -> Optional[ToolAnalysis]:
        """Run a tool and analyze results with AI"""
        async with self._tool_semaphore:
            console.print(f"\n[cyan]â–¶ Running {tool_name} on {target}[/cyan]")
            
            result = await self.tool_manager.run_tool(tool_name, target, **kwargs)
            
            if not result:
                self.result.errors.append(f"Tool {tool_name} failed to run")
                return None
            
            self.result.tools_run.append(tool_name)
            self.attack_surface.log_scan(tool_name, target, len(result.findings))
            
            # Process the results
            self._process_tool_result(tool_name, result)
            
            # AI analysis
            if result.findings or result.output:
                analysis = await self.ai_brain.analyze_tool_output(
                    tool_name=tool_name,
                    target=target,
                    output=result.output,
                    findings=result.findings,
                    attack_surface=self.attack_surface
                )
                
                self.result.ai_analyses.append(analysis)
                self.result.findings_count += len(result.findings)
                
                # Process AI recommendations
                await self._process_ai_analysis(analysis)
                
                return analysis
            
            return None
    
    async def _run_tools_parallel(
        self,
        tool_runs: List[tuple],
        max_concurrent: int = None
    ) -> List[Optional[ToolAnalysis]]:
        """
        Run multiple tools in parallel with concurrency limit.
        
        Args:
            tool_runs: List of (tool_name, target, kwargs) tuples
            max_concurrent: Override for max concurrent tools (uses class default if None)
            
        Returns:
            List of ToolAnalysis results (None for failed tools)
        """
        if max_concurrent and max_concurrent != self.MAX_CONCURRENT_TOOLS:
            # Temporarily use different semaphore
            semaphore = asyncio.Semaphore(max_concurrent)
            original_semaphore = self._tool_semaphore
            self._tool_semaphore = semaphore
        
        console.print(f"\n[bold cyan]Running {len(tool_runs)} tools in parallel (max {self.MAX_CONCURRENT_TOOLS} concurrent)[/bold cyan]")
        
        tasks = []
        for tool_run in tool_runs:
            tool_name = tool_run[0]
            target = tool_run[1]
            kwargs = tool_run[2] if len(tool_run) > 2 else {}
            tasks.append(self._run_tool_with_analysis(tool_name, target, **kwargs))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Restore original semaphore if changed
        if max_concurrent and max_concurrent != self.MAX_CONCURRENT_TOOLS:
            self._tool_semaphore = original_semaphore
        
        # Filter out exceptions and log them
        filtered_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                tool_name = tool_runs[i][0]
                console.print(f"[red]Tool {tool_name} failed: {result}[/red]")
                self.result.errors.append(f"Tool {tool_name}: {str(result)}")
                filtered_results.append(None)
            else:
                filtered_results.append(result)
        
        return filtered_results
    
    async def _batch_process_targets(
        self,
        targets: List[str],
        tool_name: str,
        batch_size: int = 10,
        **kwargs
    ) -> List[Optional[ToolAnalysis]]:
        """
        Process multiple targets with the same tool in batches.
        
        Args:
            targets: List of targets to scan
            tool_name: Tool to use for scanning
            batch_size: Number of targets per batch
            
        Returns:
            List of ToolAnalysis results
        """
        all_results = []
        total_batches = (len(targets) + batch_size - 1) // batch_size
        
        console.print(f"\n[bold cyan]Processing {len(targets)} targets in {total_batches} batches[/bold cyan]")
        
        for i in range(0, len(targets), batch_size):
            batch = targets[i:i + batch_size]
            batch_num = i // batch_size + 1
            console.print(f"\n[dim]Batch {batch_num}/{total_batches} ({len(batch)} targets)[/dim]")
            
            tool_runs = [(tool_name, target, kwargs) for target in batch]
            batch_results = await self._run_tools_parallel(tool_runs)
            all_results.extend(batch_results)
        
        return all_results
    
    async def _process_ai_analysis(self, analysis: ToolAnalysis) -> None:
        """Process AI analysis and update attack surface"""
        # Add new vulnerabilities
        for vuln_data in analysis.new_vulnerabilities:
            severity = {
                "critical": VulnSeverity.CRITICAL,
                "high": VulnSeverity.HIGH,
                "medium": VulnSeverity.MEDIUM,
                "low": VulnSeverity.LOW,
            }.get(vuln_data.get("severity", "info").lower(), VulnSeverity.INFO)
            
            vuln = Vulnerability(
                id=f"AI-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                title=vuln_data.get("type", "Unknown"),
                severity=severity,
                description=vuln_data.get("description", ""),
                affected_asset=vuln_data.get("target", ""),
                discovered_by=analysis.tool_name
            )
            self.attack_surface.add_vulnerability(vuln)
            self.result.new_vulnerabilities += 1
        
        # Log key findings
        for finding in analysis.key_findings:
            self.attack_surface.add_note(
                f"[{analysis.tool_name}] {finding.get('finding', '')} ({finding.get('severity', 'info')})"
            )
    
    async def _make_ai_decision(self) -> List[AIDecision]:
        """Get AI decisions for next steps"""
        recent = self.result.ai_analyses[-1] if self.result.ai_analyses else None
        
        decisions = await self.ai_brain.decide_next_steps(
            attack_surface=self.attack_surface,
            current_phase=self.PHASE_NAME,
            recent_analysis=recent,
            available_tools=self.DEFAULT_TOOLS
        )
        
        self.result.decisions_made.extend(decisions)
        
        return decisions
    
    def _display_phase_summary(self) -> None:
        """Display phase summary"""
        console.print(Panel(
            f"[bold]Phase Complete: {self.PHASE_NAME}[/bold]\n\n"
            f"Duration: {self.result.duration:.1f}s\n"
            f"Tools Run: {len(self.result.tools_run)}\n"
            f"Findings: {self.result.findings_count}\n"
            f"New Assets: {self.result.new_assets}\n"
            f"New Vulnerabilities: {self.result.new_vulnerabilities}\n"
            f"Errors: {len(self.result.errors)}",
            title="âœ… Phase Summary",
            style="green" if self.result.success else "yellow"
        ))


class ReconnaissancePhase(PentestPhase):
    """
    Reconnaissance Phase
    
    Goals:
    - Identify live hosts
    - Discover subdomains
    - Map network infrastructure
    - Gather OSINT
    """
    
    PHASE_NAME = "reconnaissance"
    DESCRIPTION = "Information Gathering & Target Discovery"
    DEFAULT_TOOLS = [
        "NmapScanner", "SubfinderEnumerator", "AmassEnumerator",
        "TheHarvesterScanner", "DnsenumScanner", "HttpxScanner"
    ]
    MAX_CONCURRENT_TOOLS = 5  # Allow more parallelism for recon
    
    async def execute(self) -> PhaseResult:
        """Execute reconnaissance phase"""
        self._show_phase_banner()
        
        target = self.attack_surface.primary_target
        iteration = 0
        
        # Initial reconnaissance - run tools in parallel
        console.print("\n[bold]Stage 1: Initial Discovery (Parallel)[/bold]")
        
        # Run initial discovery tools in parallel
        initial_tools = [
            ("SubfinderEnumerator", target, {}),
            ("NmapScanner", target, {"scan_type": "comprehensive"}),
            ("DnsenumScanner", target, {}),
        ]
        await self._run_tools_parallel(initial_tools)
        
        # AI-driven exploration loop
        console.print("\n[bold]Stage 2: AI-Driven Discovery[/bold]")
        
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            console.print(f"\n[dim]Iteration {iteration}/{self.max_iterations}[/dim]")
            
            # Get AI decisions
            decisions = await self._make_ai_decision()
            
            if not decisions:
                break
            
            # Collect high-priority decisions to run in parallel
            tool_runs = []
            skip_phase = False
            
            for decision in decisions:
                if decision.priority < 6:  # Skip low priority
                    continue
                    
                if decision.decision_type == DecisionType.RUN_TOOL:
                    if decision.tool in self.DEFAULT_TOOLS:
                        tool_runs.append((
                            decision.tool,
                            decision.target or target,
                            decision.parameters
                        ))
                        
                elif decision.decision_type == DecisionType.SKIP:
                    console.print(f"[dim]Skipping: {decision.reasoning}[/dim]")
                    skip_phase = True
                    break
                
                if len(tool_runs) >= 3:  # Max 3 tools per iteration
                    break
            
            if skip_phase or not tool_runs:
                break
            
            # Execute collected decisions in parallel
            await self._run_tools_parallel(tool_runs)
        
        # Probe discovered subdomains - batch process for speed
        console.print("\n[bold]Stage 3: Subdomain Probing (Parallel)[/bold]")
        subdomains = list(self.attack_surface.subdomains)[:20]
        if subdomains:
            await self._batch_process_targets(
                targets=subdomains,
                tool_name="HttpxScanner",
                batch_size=10  # Process 10 subdomains at a time
            )
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process recon tool results"""
        if not result.is_success:
            return
        
        # Process based on tool
        if "subfinder" in tool_name.lower() or "amass" in tool_name.lower():
            # Subdomain results
            for subdomain in result.raw_data.get("subdomains", []):
                if isinstance(subdomain, str):
                    self.attack_surface.subdomains.add(subdomain)
                    
                    # Create asset
                    asset = Asset(
                        id=f"subdomain-{subdomain}",
                        name=subdomain,
                        asset_type=AssetType.SUBDOMAIN,
                        hostnames=[subdomain]
                    )
                    self.attack_surface.add_asset(asset)
                    self.result.new_assets += 1
        
        elif "nmap" in tool_name.lower():
            # Port scan results
            for host_data in result.raw_data.get("hosts", []):
                ip = host_data.get("addresses", [{}])[0].get("addr", "")
                if ip:
                    self.attack_surface.ip_addresses.add(ip)
                
                # Add services
                for port_data in host_data.get("ports", []):
                    if port_data.get("state") == "open":
                        service = Service(
                            port=port_data.get("port", 0),
                            protocol=port_data.get("protocol", "tcp"),
                            name=port_data.get("service", ""),
                            version=port_data.get("version", ""),
                            state="open"
                        )
                        
                        # Update or create asset
                        asset_id = f"host-{ip}"
                        if asset_id not in self.attack_surface.assets:
                            asset = Asset(
                                id=asset_id,
                                name=ip,
                                asset_type=AssetType.HOST,
                                ip_addresses=[ip]
                            )
                            self.attack_surface.add_asset(asset)
                            self.result.new_assets += 1
                        
                        self.attack_surface.assets[asset_id].services.append(service)
        
        elif "httpx" in tool_name.lower():
            # HTTP probe results
            for host_data in result.raw_data.get("hosts", []):
                url = host_data.get("url", "")
                if url:
                    endpoint = WebEndpoint(
                        url=url,
                        status_code=host_data.get("status_code", 0),
                        title=host_data.get("title", ""),
                        content_type=host_data.get("content_type", "")
                    )
                    
                    # Add technologies
                    for tech in host_data.get("technologies", []):
                        endpoint.technologies.append(Technology(name=tech))


class EnumerationPhase(PentestPhase):
    """
    Enumeration Phase
    
    Goals:
    - Enumerate web directories/files
    - Identify technologies
    - Discover parameters
    - Map application structure
    """
    
    PHASE_NAME = "enumeration"
    DESCRIPTION = "Service Enumeration & Technology Fingerprinting"
    DEFAULT_TOOLS = [
        "GobusterScanner", "FeroxbusterScanner", "FfufScanner",
        "HttpxScanner", "KatanaCrawler", "WpscanScanner",
        "Enum4linuxScanner", "ArjunScanner"
    ]
    MAX_CONCURRENT_TOOLS = 4  # Moderate parallelism for enumeration
    
    async def execute(self) -> PhaseResult:
        """Execute enumeration phase"""
        self._show_phase_banner()
        
        # Get high-value targets with web services
        web_targets = [
            a for a in self.attack_surface.assets.values()
            if a.has_web_service()
        ]
        
        # Get Windows/SMB targets
        smb_targets = self.attack_surface.find_assets_with_service(ServiceType.SMB)
        
        console.print(f"\n[bold]Found {len(web_targets)} web targets and {len(smb_targets)} SMB targets[/bold]")
        
        iteration = 0
        
        # Build list of web target URLs
        target_urls = []
        wordpress_targets = []
        for asset in web_targets[:10]:  # Limit to 10
            target_url = f"https://{asset.name}"
            if any(s.port == 80 for s in asset.services):
                target_url = f"http://{asset.name}"
            target_urls.append(target_url)
            
            # Track WordPress sites
            if any("wordpress" in str(t.name).lower() for t in asset.technologies):
                wordpress_targets.append(target_url)
        
        # Stage 1: Parallel directory enumeration and tech detection
        console.print("\n[bold]Stage 1: Directory & Technology Enumeration (Parallel)[/bold]")
        
        # Run GobusterScanner and HttpxScanner on all targets in parallel
        tool_runs = []
        for target_url in target_urls:
            tool_runs.append(("GobusterScanner", target_url, {}))
            tool_runs.append(("HttpxScanner", target_url, {}))
        
        if tool_runs:
            await self._run_tools_parallel(tool_runs)
        
        # Stage 2: WordPress scanning (parallel)
        if wordpress_targets:
            console.print(f"\n[bold]Stage 2: WordPress Scanning ({len(wordpress_targets)} sites)[/bold]")
            await self._batch_process_targets(
                targets=wordpress_targets,
                tool_name="WpscanScanner",
                batch_size=3
            )
        
        # Stage 3: Parameter discovery (parallel)
        console.print("\n[bold]Stage 3: Parameter Discovery (Parallel)[/bold]")
        await self._batch_process_targets(
            targets=target_urls[:5],  # Top 5 targets
            tool_name="ArjunScanner",
            batch_size=5
        )
        
        # Stage 4: SMB enumeration (parallel)
        if smb_targets:
            console.print(f"\n[bold]Stage 4: SMB Enumeration ({len(smb_targets)} targets)[/bold]")
            smb_hosts = [asset.name for asset in smb_targets[:5]]
            await self._batch_process_targets(
                targets=smb_hosts,
                tool_name="Enum4linuxScanner",
                batch_size=3
            )
        
        # AI-driven additional enumeration
        console.print("\n[bold]Stage 5: AI-Driven Enumeration[/bold]")
        
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            
            decisions = await self._make_ai_decision()
            
            # Collect high-priority tool runs
            tool_runs = []
            for decision in decisions:
                if decision.decision_type == DecisionType.RUN_TOOL and decision.priority >= 7:
                    tool_runs.append((
                        decision.tool,
                        decision.target,
                        decision.parameters
                    ))
                
                if len(tool_runs) >= 2:
                    break
            
            if not tool_runs:
                break
            
            # Execute in parallel
            await self._run_tools_parallel(tool_runs)
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process enumeration tool results"""
        if not result.is_success:
            return
        
        if "gobuster" in tool_name.lower() or "feroxbuster" in tool_name.lower():
            for url_data in result.raw_data.get("urls", []) + result.raw_data.get("directories", []):
                url = url_data if isinstance(url_data, str) else url_data.get("url", "")
                if url:
                    # Find matching asset and add endpoint
                    for asset in self.attack_surface.assets.values():
                        if any(h in url for h in asset.hostnames):
                            asset.web_endpoints.append(WebEndpoint(url=url))
                            break
        
        elif "enum4linux" in tool_name.lower():
            # Process Windows enumeration
            for user in result.raw_data.get("users", []):
                username = user.get("username", user) if isinstance(user, dict) else user
                self.attack_surface.add_credential(Credential(
                    username=username,
                    source=tool_name
                ))
        
        elif "wpscan" in tool_name.lower():
            # Process WordPress scan
            for vuln in result.raw_data.get("vulnerabilities", []):
                self.attack_surface.add_vulnerability(Vulnerability(
                    id=f"WP-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                    title=vuln.get("title", "WordPress Vulnerability"),
                    severity=VulnSeverity.HIGH,
                    description=vuln.get("description", ""),
                    discovered_by=tool_name
                ))
                self.result.new_vulnerabilities += 1


class VulnerabilityPhase(PentestPhase):
    """
    Vulnerability Assessment Phase
    
    Goals:
    - Identify vulnerabilities
    - Test for common issues (SQLi, XSS, etc.)
    - Assess security configurations
    - Prioritize findings
    """
    
    PHASE_NAME = "vulnerability"
    DESCRIPTION = "Vulnerability Assessment & Security Testing"
    DEFAULT_TOOLS = [
        "NucleiScanner", "NiktoScanner", "SqlmapScanner",
        "DalfoxScanner", "Wafw00fScanner", "TrivyScanner"
    ]
    MAX_CONCURRENT_TOOLS = 4  # Moderate parallelism for vuln scanning
    
    async def execute(self) -> PhaseResult:
        """Execute vulnerability assessment phase"""
        self._show_phase_banner()
        
        # Prioritize targets
        high_value = self.attack_surface.get_high_value_targets()
        web_targets = [a for a in high_value if a.has_web_service()]
        
        console.print(f"\n[bold]Scanning {len(high_value)} high-value targets ({len(web_targets)} web)[/bold]")
        
        # Build target URLs
        target_urls = []
        for asset in web_targets[:10]:
            target_url = f"https://{asset.name}"
            if any(s.port == 80 for s in asset.services):
                target_url = f"http://{asset.name}"
            target_urls.append(target_url)
        
        # Stage 1: WAF detection (parallel)
        console.print("\n[bold]Stage 1: WAF Detection (Parallel)[/bold]")
        waf_targets = target_urls[:5]
        if waf_targets:
            await self._batch_process_targets(
                targets=waf_targets,
                tool_name="Wafw00fScanner",
                batch_size=5
            )
        
        # Stage 2: Nuclei template scanning (parallel)
        console.print("\n[bold]Stage 2: Template-Based Scanning (Parallel)[/bold]")
        if target_urls:
            # Run Nuclei on all targets in parallel batches
            nuclei_runs = [
                ("NucleiScanner", url, {"severity": ["critical", "high", "medium"]})
                for url in target_urls[:10]
            ]
            await self._run_tools_parallel(nuclei_runs)
        
        # Stage 3: Deep vulnerability scanning (parallel per target)
        console.print("\n[bold]Stage 3: Deep Vulnerability Scanning (Parallel)[/bold]")
        
        # Collect all deep scan tool runs
        deep_scan_runs = []
        sqli_targets = []
        
        for asset in high_value[:5]:
            if asset.has_web_service():
                target_url = f"https://{asset.name}"
                if any(s.port == 80 for s in asset.services):
                    target_url = f"http://{asset.name}"
                
                # Add Nikto and Dalfox scans
                deep_scan_runs.append(("NiktoScanner", target_url, {}))
                deep_scan_runs.append(("DalfoxScanner", target_url, {}))
                
                # Collect endpoints with parameters for SQLmap
                for endpoint in asset.web_endpoints:
                    if endpoint.parameters or "?" in endpoint.url:
                        sqli_targets.append(endpoint.url)
                        break  # Only first parameterized endpoint per asset
        
        # Execute deep scans in parallel
        if deep_scan_runs:
            await self._run_tools_parallel(deep_scan_runs)
        
        # Stage 4: SQL injection testing (parallel)
        if sqli_targets:
            console.print(f"\n[bold]Stage 4: SQL Injection Testing ({len(sqli_targets)} endpoints)[/bold]")
            sqli_runs = [
                ("SqlmapScanner", url, {"batch": True, "level": 2})
                for url in sqli_targets[:3]  # Limit SQLmap runs
            ]
            await self._run_tools_parallel(sqli_runs)
        
        # AI analysis of critical vulnerabilities (can be parallelized too)
        critical_vulns = self.attack_surface.get_critical_vulnerabilities()
        if critical_vulns:
            console.print("\n[bold]Stage 5: AI Deep Analysis of Critical Vulnerabilities[/bold]")
            # Analyze up to 3 critical vulns in parallel
            analysis_tasks = []
            for vuln in critical_vulns[:3]:
                analysis_tasks.append(
                    self.ai_brain.analyze_vulnerability(vuln, self.attack_surface)
                )
            
            if analysis_tasks:
                analyses = await asyncio.gather(*analysis_tasks, return_exceptions=True)
                for i, analysis in enumerate(analyses):
                    if not isinstance(analysis, Exception) and analysis:
                        vuln_id = critical_vulns[i].id
                        self.attack_surface.add_note(
                            f"AI Analysis for {vuln_id}: {analysis.get('analysis', '')[:500]}"
                        )
        
        # AI-driven additional testing
        iteration = 0
        console.print("\n[bold]Stage 6: AI-Driven Testing[/bold]")
        
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            
            decisions = await self._make_ai_decision()
            
            # Collect high-priority tool runs
            tool_runs = []
            for decision in decisions:
                if decision.decision_type == DecisionType.RUN_TOOL and decision.priority >= 8:
                    tool_runs.append((
                        decision.tool,
                        decision.target,
                        decision.parameters
                    ))
                elif decision.decision_type == DecisionType.ANALYZE_DEEPER:
                    console.print(f"[dim]Deep analysis: {decision.reasoning}[/dim]")
                
                if len(tool_runs) >= 2:
                    break
            
            if not tool_runs:
                break
            
            # Execute in parallel
            await self._run_tools_parallel(tool_runs)
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process vulnerability scan results"""
        if not result.is_success:
            return
        
        # Extract vulnerabilities from findings
        for finding in result.findings:
            severity_str = finding.get("severity", "info").lower()
            severity = {
                "critical": VulnSeverity.CRITICAL,
                "high": VulnSeverity.HIGH,
                "medium": VulnSeverity.MEDIUM,
                "low": VulnSeverity.LOW,
            }.get(severity_str, VulnSeverity.INFO)
            
            if severity in [VulnSeverity.CRITICAL, VulnSeverity.HIGH, VulnSeverity.MEDIUM]:
                vuln = Vulnerability(
                    id=f"{tool_name[:3].upper()}-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                    title=finding.get("title", "Unknown Vulnerability"),
                    severity=severity,
                    description=finding.get("description", ""),
                    evidence=finding.get("evidence", ""),
                    cve_id=finding.get("cve_id", ""),
                    cwe_id=finding.get("cwe_id", ""),
                    cvss_score=finding.get("cvss_score", 0.0),
                    remediation=finding.get("remediation", ""),
                    discovered_by=tool_name,
                    affected_asset=finding.get("url", finding.get("target", ""))
                )
                
                # Check exploitability for SQLi/XSS
                if any(x in finding.get("title", "").lower() for x in ["sql injection", "xss", "rce", "command injection"]):
                    vuln.exploitable = True
                
                self.attack_surface.add_vulnerability(vuln)
                self.result.new_vulnerabilities += 1


class ExploitationPhase(PentestPhase):
    """
    Exploitation Phase
    
    Goals:
    - Validate vulnerabilities
    - Attempt exploitation
    - Gain initial access
    - Document proof of concept
    """
    
    PHASE_NAME = "exploitation"
    DESCRIPTION = "Vulnerability Validation & Exploitation"
    DEFAULT_TOOLS = [
        "HydraAttacker", "CrackmapexecScanner", "NetexecScanner",
        "SqlmapScanner", "EvilWinrmShell"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute exploitation phase"""
        self._show_phase_banner()
        
        # Generate attack plan
        console.print("\n[bold]Generating Attack Plan[/bold]")
        attack_plan = await self.ai_brain.generate_attack_plan(self.attack_surface)
        self.attack_surface.add_note(f"Attack Plan: {attack_plan.get('attack_plan', '')[:1000]}")
        
        # Get exploitable vulnerabilities
        exploitable = [v for v in self.attack_surface.all_vulnerabilities if v.exploitable]
        
        console.print(f"\n[bold]Found {len(exploitable)} potentially exploitable vulnerabilities[/bold]")
        
        # Attempt exploitation based on vulnerability type
        for vuln in exploitable[:5]:
            console.print(f"\n[cyan]Attempting: {vuln.title}[/cyan]")
            
            if "sql injection" in vuln.title.lower():
                # SQL injection exploitation
                if vuln.affected_asset:
                    await self._run_tool_with_analysis(
                        "SqlmapScanner", vuln.affected_asset,
                        dbs=True, batch=True
                    )
                    vuln.status = VulnStatus.CONFIRMED
            
            elif any(x in vuln.title.lower() for x in ["smb", "windows", "netbios"]):
                # Windows exploitation
                target = vuln.affected_asset.split("/")[0] if "/" in vuln.affected_asset else vuln.affected_asset
                
                # Try credential attacks if we have creds
                for cred in self.attack_surface.all_credentials:
                    if cred.password or cred.hash:
                        await self._run_tool_with_analysis(
                            "CrackmapexecScanner", target,
                            username=cred.username,
                            password=cred.password or None,
                            hash=cred.hash or None
                        )
        
        # Password attacks on discovered services
        console.print("\n[bold]Password Attack Attempts[/bold]")
        for asset in self.attack_surface.find_assets_with_service(ServiceType.SSH)[:3]:
            # Only attempt with valid usernames
            users = [c.username for c in self.attack_surface.all_credentials if c.username]
            if users:
                console.print(f"[dim]Attempting SSH brute force on {asset.name}[/dim]")
                # Note: In real scenario, would use proper wordlist
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process exploitation results"""
        if not result.is_success:
            return
        
        # Look for successful exploits
        for finding in result.findings:
            if finding.get("severity") == "critical":
                # Mark vulnerability as exploited
                for vuln in self.attack_surface.all_vulnerabilities:
                    if finding.get("title", "") in vuln.title:
                        vuln.status = VulnStatus.EXPLOITED
                        break
        
        # Extract credentials
        for cred in result.raw_data.get("credentials", []):
            self.attack_surface.add_credential(Credential(
                username=cred.get("username", ""),
                password=cred.get("password", ""),
                hash=cred.get("hash", ""),
                source=tool_name,
                valid=True
            ))


class PostExploitationPhase(PentestPhase):
    """
    Post-Exploitation Phase
    
    Goals:
    - Privilege escalation
    - Lateral movement
    - Data collection
    - Persistence (documentation only)
    """
    
    PHASE_NAME = "post_exploitation"
    DESCRIPTION = "Post-Exploitation & Impact Demonstration"
    DEFAULT_TOOLS = [
        "CrackmapexecScanner", "NetexecScanner", "EvilWinrmShell"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute post-exploitation phase"""
        self._show_phase_banner()
        
        # Find exploited assets
        exploited_vulns = [v for v in self.attack_surface.all_vulnerabilities if v.status == VulnStatus.EXPLOITED]
        
        if not exploited_vulns:
            console.print("[yellow]No exploited vulnerabilities - limited post-exploitation[/yellow]")
            self.result.success = True
            self.result.end_time = datetime.now()
            self.result.notes = "Skipped - no initial access achieved"
            return self.result
        
        console.print(f"\n[bold]Post-exploitation on {len(exploited_vulns)} compromised targets[/bold]")
        
        # Get AI recommendations for post-exploitation
        decisions = await self._make_ai_decision()
        
        for decision in decisions:
            if decision.decision_type == DecisionType.RUN_TOOL:
                console.print(f"[cyan]Running: {decision.tool}[/cyan]")
                console.print(f"[dim]Reason: {decision.reasoning}[/dim]")
                
                await self._run_tool_with_analysis(
                    decision.tool,
                    decision.target,
                    **decision.parameters
                )
            elif decision.decision_type == DecisionType.PIVOT:
                console.print(f"[yellow]Pivot opportunity: {decision.reasoning}[/yellow]")
                self.attack_surface.add_note(f"Pivot: {decision.reasoning}")
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process post-exploitation results"""
        # Collect any additional credentials or access
        for cred in result.raw_data.get("credentials", []):
            self.attack_surface.add_credential(Credential(
                username=cred.get("username", ""),
                password=cred.get("password", ""),
                hash=cred.get("hash", ""),
                source=f"post_exploitation_{tool_name}",
                valid=True
            ))


class ReportingPhase(PentestPhase):
    """
    Reporting Phase
    
    Goals:
    - Compile all findings
    - Generate comprehensive report
    - Provide remediation guidance
    - Executive summary
    """
    
    PHASE_NAME = "reporting"
    DESCRIPTION = "Report Generation & Documentation"
    DEFAULT_TOOLS = []
    
    async def execute(self) -> PhaseResult:
        """Execute reporting phase"""
        self._show_phase_banner()
        
        from ..reports.generator import ReportGenerator, PentestReport, Finding
        
        console.print("\n[bold]Generating Comprehensive Report[/bold]")
        
        # Convert attack surface to report findings
        findings = []
        for vuln in self.attack_surface.all_vulnerabilities:
            findings.append(Finding(
                id=vuln.id,
                title=vuln.title,
                severity=vuln.severity.value,
                category=vuln.discovered_by,
                description=vuln.description,
                impact=self._get_impact(vuln.severity),
                remediation=vuln.remediation,
                evidence=vuln.evidence,
                url=vuln.affected_asset,
                cwe_id=vuln.cwe_id,
                cvss_score=vuln.cvss_score
            ))
        
        # Create report
        report = PentestReport(
            title=f"Penetration Test Report - {self.attack_surface.primary_target}",
            target=self.attack_surface.primary_target,
            findings=findings,
            scope=", ".join(self.attack_surface.domains),
            network_findings={"assets": len(self.attack_surface.assets)},
        )
        
        # Generate with AI enhancement
        generator = ReportGenerator()
        report_path = await generator.generate(report, format="html", use_ai=True)
        
        # Also generate JSON export
        json_path = self.tool_manager.output_dir / "attack_surface.json"
        with open(json_path, "w") as f:
            f.write(self.attack_surface.to_json())
        
        console.print(f"\n[green]âœ“ Report generated: {report_path}[/green]")
        console.print(f"[green]âœ“ Attack surface exported: {json_path}[/green]")
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self.result.notes = f"Report: {report_path}"
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        pass
    
    def _get_impact(self, severity: VulnSeverity) -> str:
        impacts = {
            VulnSeverity.CRITICAL: "Complete system compromise possible",
            VulnSeverity.HIGH: "Significant security risk",
            VulnSeverity.MEDIUM: "Moderate security concern",
            VulnSeverity.LOW: "Minor security issue",
            VulnSeverity.INFO: "Informational finding"
        }
        return impacts.get(severity, "Unknown impact")
