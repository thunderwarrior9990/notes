"""
Pentest Phases
==============

Individual phases of the penetration testing methodology.
"""

import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Type

from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

from .attack_surface import (
    AttackSurface, Asset, Service, Vulnerability, Technology,
    Credential, WebEndpoint, AssetType, ServiceType, VulnSeverity
)
from .brain import AIBrain, AIDecision, ToolAnalysis, DecisionType
from ..tools.base import ToolWrapper, ToolResult, ToolStatus
from ..tools.manager import ToolManager


console = Console()


@dataclass
class PhaseResult:
    """Result from a phase execution"""
    phase_name: str
    success: bool
    start_time: datetime
    end_time: Optional[datetime] = None
    tools_run: List[str] = field(default_factory=list)
    findings_count: int = 0
    new_assets: int = 0
    new_vulnerabilities: int = 0
    ai_analyses: List[ToolAnalysis] = field(default_factory=list)
    decisions_made: List[AIDecision] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    notes: str = ""
    
    @property
    def duration(self) -> float:
        if self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "phase_name": self.phase_name,
            "success": self.success,
            "duration_seconds": self.duration,
            "tools_run": self.tools_run,
            "findings_count": self.findings_count,
            "new_assets": self.new_assets,
            "new_vulnerabilities": self.new_vulnerabilities,
            "ai_analyses": [a.to_dict() for a in self.ai_analyses],
            "decisions_made": [d.to_dict() for d in self.decisions_made],
            "errors": self.errors,
            "notes": self.notes
        }


class PentestPhase(ABC):
    """Base class for pentest phases"""
    
    PHASE_NAME: str = ""
    DESCRIPTION: str = ""
    DEFAULT_TOOLS: List[str] = []
    
    def __init__(
        self,
        tool_manager: ToolManager,
        ai_brain: AIBrain,
        attack_surface: AttackSurface,
        max_iterations: int = 10,
        auto_mode: bool = True
    ):
        self.tool_manager = tool_manager
        self.ai_brain = ai_brain
        self.attack_surface = attack_surface
        self.max_iterations = max_iterations
        self.auto_mode = auto_mode
        self.result = PhaseResult(
            phase_name=self.PHASE_NAME,
            success=False,
            start_time=datetime.now()
        )
    
    @abstractmethod
    async def execute(self) -> PhaseResult:
        """Execute the phase"""
        pass
    
    @abstractmethod
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process results from a tool and update attack surface"""
        pass
    
    def _show_phase_banner(self) -> None:
        """Show phase banner"""
        console.print(Panel(
            f"[bold]{self.DESCRIPTION}[/bold]\n\n"
            f"Target: {self.attack_surface.primary_target}\n"
            f"Current Assets: {len(self.attack_surface.assets)}\n"
            f"Current Vulns: {len(self.attack_surface.all_vulnerabilities)}",
            title=f"ðŸ“ Phase: {self.PHASE_NAME}",
            style="cyan"
        ))
    
    async def _run_tool_with_analysis(
        self,
        tool_name: str,
        target: str,
        **kwargs
    ) -> Optional[ToolAnalysis]:
        """Run a tool and analyze results with AI"""
        console.print(f"\n[cyan]â–¶ Running {tool_name} on {target}[/cyan]")
        
        result = await self.tool_manager.run_tool(tool_name, target, **kwargs)
        
        if not result:
            self.result.errors.append(f"Tool {tool_name} failed to run")
            return None
        
        self.result.tools_run.append(tool_name)
        self.attack_surface.log_scan(tool_name, target, len(result.findings))
        
        # Process the results
        self._process_tool_result(tool_name, result)
        
        # AI analysis
        if result.findings or result.output:
            analysis = await self.ai_brain.analyze_tool_output(
                tool_name=tool_name,
                target=target,
                output=result.output,
                findings=result.findings,
                attack_surface=self.attack_surface
            )
            
            self.result.ai_analyses.append(analysis)
            self.result.findings_count += len(result.findings)
            
            # Process AI recommendations
            await self._process_ai_analysis(analysis)
            
            return analysis
        
        return None
    
    async def _process_ai_analysis(self, analysis: ToolAnalysis) -> None:
        """Process AI analysis and update attack surface"""
        # Add new vulnerabilities
        for vuln_data in analysis.new_vulnerabilities:
            severity = {
                "critical": VulnSeverity.CRITICAL,
                "high": VulnSeverity.HIGH,
                "medium": VulnSeverity.MEDIUM,
                "low": VulnSeverity.LOW,
            }.get(vuln_data.get("severity", "info").lower(), VulnSeverity.INFO)
            
            vuln = Vulnerability(
                id=f"AI-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                title=vuln_data.get("type", "Unknown"),
                severity=severity,
                description=vuln_data.get("description", ""),
                affected_asset=vuln_data.get("target", ""),
                discovered_by=analysis.tool_name
            )
            self.attack_surface.add_vulnerability(vuln)
            self.result.new_vulnerabilities += 1
        
        # Log key findings
        for finding in analysis.key_findings:
            self.attack_surface.add_note(
                f"[{analysis.tool_name}] {finding.get('finding', '')} ({finding.get('severity', 'info')})"
            )
    
    async def _make_ai_decision(self) -> List[AIDecision]:
        """Get AI decisions for next steps"""
        recent = self.result.ai_analyses[-1] if self.result.ai_analyses else None
        
        decisions = await self.ai_brain.decide_next_steps(
            attack_surface=self.attack_surface,
            current_phase=self.PHASE_NAME,
            recent_analysis=recent,
            available_tools=self.DEFAULT_TOOLS
        )
        
        self.result.decisions_made.extend(decisions)
        
        return decisions
    
    def _display_phase_summary(self) -> None:
        """Display phase summary"""
        console.print(Panel(
            f"[bold]Phase Complete: {self.PHASE_NAME}[/bold]\n\n"
            f"Duration: {self.result.duration:.1f}s\n"
            f"Tools Run: {len(self.result.tools_run)}\n"
            f"Findings: {self.result.findings_count}\n"
            f"New Assets: {self.result.new_assets}\n"
            f"New Vulnerabilities: {self.result.new_vulnerabilities}\n"
            f"Errors: {len(self.result.errors)}",
            title="âœ… Phase Summary",
            style="green" if self.result.success else "yellow"
        ))


class ReconnaissancePhase(PentestPhase):
    """
    Reconnaissance Phase
    
    Goals:
    - Identify live hosts
    - Discover subdomains
    - Map network infrastructure
    - Gather OSINT
    """
    
    PHASE_NAME = "reconnaissance"
    DESCRIPTION = "Information Gathering & Target Discovery"
    DEFAULT_TOOLS = [
        "NmapScanner", "SubfinderEnumerator", "AmassEnumerator",
        "TheHarvesterScanner", "DnsenumScanner", "HttpxScanner"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute reconnaissance phase"""
        self._show_phase_banner()
        
        target = self.attack_surface.primary_target
        iteration = 0
        
        # Initial reconnaissance
        console.print("\n[bold]Stage 1: Initial Discovery[/bold]")
        
        # Subdomain enumeration
        await self._run_tool_with_analysis("SubfinderEnumerator", target)
        
        # Port scanning on main target
        await self._run_tool_with_analysis(
            "NmapScanner", target,
            scan_type="comprehensive"
        )
        
        # DNS enumeration
        await self._run_tool_with_analysis("DnsenumScanner", target)
        
        # AI-driven exploration loop
        console.print("\n[bold]Stage 2: AI-Driven Discovery[/bold]")
        
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            console.print(f"\n[dim]Iteration {iteration}/{self.max_iterations}[/dim]")
            
            # Get AI decisions
            decisions = await self._make_ai_decision()
            
            if not decisions:
                break
            
            # Execute high-priority decisions
            executed = 0
            for decision in decisions:
                if decision.priority < 6:  # Skip low priority
                    continue
                    
                if decision.decision_type == DecisionType.RUN_TOOL:
                    if decision.tool in self.DEFAULT_TOOLS:
                        await self._run_tool_with_analysis(
                            decision.tool,
                            decision.target or target,
                            **decision.parameters
                        )
                        executed += 1
                        
                elif decision.decision_type == DecisionType.SKIP:
                    console.print(f"[dim]Skipping: {decision.reasoning}[/dim]")
                    break
                
                if executed >= 3:  # Max 3 tools per iteration
                    break
            
            if executed == 0:
                break
        
        # Probe discovered subdomains
        console.print("\n[bold]Stage 3: Subdomain Probing[/bold]")
        for subdomain in list(self.attack_surface.subdomains)[:20]:
            await self._run_tool_with_analysis("HttpxScanner", subdomain)
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process recon tool results"""
        if not result.is_success:
            return
        
        # Process based on tool
        if "subfinder" in tool_name.lower() or "amass" in tool_name.lower():
            # Subdomain results
            for subdomain in result.raw_data.get("subdomains", []):
                if isinstance(subdomain, str):
                    self.attack_surface.subdomains.add(subdomain)
                    
                    # Create asset
                    asset = Asset(
                        id=f"subdomain-{subdomain}",
                        name=subdomain,
                        asset_type=AssetType.SUBDOMAIN,
                        hostnames=[subdomain]
                    )
                    self.attack_surface.add_asset(asset)
                    self.result.new_assets += 1
        
        elif "nmap" in tool_name.lower():
            # Port scan results
            for host_data in result.raw_data.get("hosts", []):
                ip = host_data.get("addresses", [{}])[0].get("addr", "")
                if ip:
                    self.attack_surface.ip_addresses.add(ip)
                
                # Add services
                for port_data in host_data.get("ports", []):
                    if port_data.get("state") == "open":
                        service = Service(
                            port=port_data.get("port", 0),
                            protocol=port_data.get("protocol", "tcp"),
                            name=port_data.get("service", ""),
                            version=port_data.get("version", ""),
                            state="open"
                        )
                        
                        # Update or create asset
                        asset_id = f"host-{ip}"
                        if asset_id not in self.attack_surface.assets:
                            asset = Asset(
                                id=asset_id,
                                name=ip,
                                asset_type=AssetType.HOST,
                                ip_addresses=[ip]
                            )
                            self.attack_surface.add_asset(asset)
                            self.result.new_assets += 1
                        
                        self.attack_surface.assets[asset_id].services.append(service)
        
        elif "httpx" in tool_name.lower():
            # HTTP probe results
            for host_data in result.raw_data.get("hosts", []):
                url = host_data.get("url", "")
                if url:
                    endpoint = WebEndpoint(
                        url=url,
                        status_code=host_data.get("status_code", 0),
                        title=host_data.get("title", ""),
                        content_type=host_data.get("content_type", "")
                    )
                    
                    # Add technologies
                    for tech in host_data.get("technologies", []):
                        endpoint.technologies.append(Technology(name=tech))


class EnumerationPhase(PentestPhase):
    """
    Enumeration Phase
    
    Goals:
    - Enumerate web directories/files
    - Identify technologies
    - Discover parameters
    - Map application structure
    """
    
    PHASE_NAME = "enumeration"
    DESCRIPTION = "Service Enumeration & Technology Fingerprinting"
    DEFAULT_TOOLS = [
        "GobusterScanner", "FeroxbusterScanner", "FfufScanner",
        "HttpxScanner", "KatanaCrawler", "WpscanScanner",
        "Enum4linuxScanner", "ArjunScanner"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute enumeration phase"""
        self._show_phase_banner()
        
        # Get high-value targets with web services
        web_targets = [
            a for a in self.attack_surface.assets.values()
            if a.has_web_service()
        ]
        
        # Get Windows/SMB targets
        smb_targets = self.attack_surface.find_assets_with_service(ServiceType.SMB)
        
        console.print(f"\n[bold]Found {len(web_targets)} web targets and {len(smb_targets)} SMB targets[/bold]")
        
        iteration = 0
        
        # Enumerate each web target
        for asset in web_targets[:10]:  # Limit to 10
            console.print(f"\n[bold]Enumerating: {asset.name}[/bold]")
            
            # Determine target URL
            target_url = f"https://{asset.name}"
            if any(s.port == 80 for s in asset.services):
                target_url = f"http://{asset.name}"
            
            # Directory enumeration
            await self._run_tool_with_analysis("GobusterScanner", target_url)
            
            # Technology detection
            await self._run_tool_with_analysis("HttpxScanner", target_url)
            
            # WordPress check
            if any("wordpress" in str(t.name).lower() for t in asset.technologies):
                await self._run_tool_with_analysis("WpscanScanner", target_url)
            
            # Parameter discovery
            await self._run_tool_with_analysis("ArjunScanner", target_url)
        
        # Enumerate SMB targets
        for asset in smb_targets[:5]:
            console.print(f"\n[bold]Enumerating SMB: {asset.name}[/bold]")
            await self._run_tool_with_analysis("Enum4linuxScanner", asset.name)
        
        # AI-driven additional enumeration
        console.print("\n[bold]AI-Driven Enumeration[/bold]")
        
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            
            decisions = await self._make_ai_decision()
            
            executed = 0
            for decision in decisions:
                if decision.decision_type == DecisionType.RUN_TOOL and decision.priority >= 7:
                    await self._run_tool_with_analysis(
                        decision.tool,
                        decision.target,
                        **decision.parameters
                    )
                    executed += 1
                
                if executed >= 2:
                    break
            
            if executed == 0:
                break
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process enumeration tool results"""
        if not result.is_success:
            return
        
        if "gobuster" in tool_name.lower() or "feroxbuster" in tool_name.lower():
            for url_data in result.raw_data.get("urls", []) + result.raw_data.get("directories", []):
                url = url_data if isinstance(url_data, str) else url_data.get("url", "")
                if url:
                    # Find matching asset and add endpoint
                    for asset in self.attack_surface.assets.values():
                        if any(h in url for h in asset.hostnames):
                            asset.web_endpoints.append(WebEndpoint(url=url))
                            break
        
        elif "enum4linux" in tool_name.lower():
            # Process Windows enumeration
            for user in result.raw_data.get("users", []):
                username = user.get("username", user) if isinstance(user, dict) else user
                self.attack_surface.add_credential(Credential(
                    username=username,
                    source=tool_name
                ))
        
        elif "wpscan" in tool_name.lower():
            # Process WordPress scan
            for vuln in result.raw_data.get("vulnerabilities", []):
                self.attack_surface.add_vulnerability(Vulnerability(
                    id=f"WP-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                    title=vuln.get("title", "WordPress Vulnerability"),
                    severity=VulnSeverity.HIGH,
                    description=vuln.get("description", ""),
                    discovered_by=tool_name
                ))
                self.result.new_vulnerabilities += 1


class VulnerabilityPhase(PentestPhase):
    """
    Vulnerability Assessment Phase
    
    Goals:
    - Identify vulnerabilities
    - Test for common issues (SQLi, XSS, etc.)
    - Assess security configurations
    - Prioritize findings
    """
    
    PHASE_NAME = "vulnerability"
    DESCRIPTION = "Vulnerability Assessment & Security Testing"
    DEFAULT_TOOLS = [
        "NucleiScanner", "NiktoScanner", "SqlmapScanner",
        "DalfoxScanner", "Wafw00fScanner", "TrivyScanner"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute vulnerability assessment phase"""
        self._show_phase_banner()
        
        # Prioritize targets
        high_value = self.attack_surface.get_high_value_targets()
        
        console.print(f"\n[bold]Scanning {len(high_value)} high-value targets[/bold]")
        
        # WAF detection first
        web_targets = [a for a in high_value if a.has_web_service()]
        for asset in web_targets[:5]:
            target_url = f"https://{asset.name}"
            await self._run_tool_with_analysis("Wafw00fScanner", target_url)
        
        # Nuclei scan on all web targets
        console.print("\n[bold]Template-Based Scanning[/bold]")
        for asset in web_targets[:10]:
            target_url = f"https://{asset.name}"
            await self._run_tool_with_analysis(
                "NucleiScanner", target_url,
                severity=["critical", "high", "medium"]
            )
        
        # Deep scanning on top targets
        console.print("\n[bold]Deep Vulnerability Scanning[/bold]")
        for asset in high_value[:5]:
            if asset.has_web_service():
                target_url = f"https://{asset.name}"
                
                # Nikto
                await self._run_tool_with_analysis("NiktoScanner", target_url)
                
                # SQL injection testing on endpoints with parameters
                for endpoint in asset.web_endpoints:
                    if endpoint.parameters or "?" in endpoint.url:
                        await self._run_tool_with_analysis(
                            "SqlmapScanner", endpoint.url,
                            batch=True, level=2
                        )
                        break  # Only test first parameterized endpoint
                
                # XSS testing
                await self._run_tool_with_analysis("DalfoxScanner", target_url)
        
        # AI analysis of all vulnerabilities
        if self.attack_surface.get_critical_vulnerabilities():
            console.print("\n[bold]AI Deep Analysis of Critical Vulnerabilities[/bold]")
            for vuln in self.attack_surface.get_critical_vulnerabilities()[:3]:
                analysis = await self.ai_brain.analyze_vulnerability(
                    vuln, self.attack_surface
                )
                self.attack_surface.add_note(
                    f"AI Analysis for {vuln.id}: {analysis.get('analysis', '')[:500]}"
                )
        
        # AI-driven additional testing
        iteration = 0
        while iteration < self.max_iterations and self.auto_mode:
            iteration += 1
            
            decisions = await self._make_ai_decision()
            
            executed = 0
            for decision in decisions:
                if decision.decision_type == DecisionType.RUN_TOOL and decision.priority >= 8:
                    await self._run_tool_with_analysis(
                        decision.tool,
                        decision.target,
                        **decision.parameters
                    )
                    executed += 1
                elif decision.decision_type == DecisionType.ANALYZE_DEEPER:
                    # More detailed analysis on specific target
                    console.print(f"[dim]Deep analysis: {decision.reasoning}[/dim]")
                
                if executed >= 2:
                    break
            
            if executed == 0:
                break
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process vulnerability scan results"""
        if not result.is_success:
            return
        
        # Extract vulnerabilities from findings
        for finding in result.findings:
            severity_str = finding.get("severity", "info").lower()
            severity = {
                "critical": VulnSeverity.CRITICAL,
                "high": VulnSeverity.HIGH,
                "medium": VulnSeverity.MEDIUM,
                "low": VulnSeverity.LOW,
            }.get(severity_str, VulnSeverity.INFO)
            
            if severity in [VulnSeverity.CRITICAL, VulnSeverity.HIGH, VulnSeverity.MEDIUM]:
                vuln = Vulnerability(
                    id=f"{tool_name[:3].upper()}-{len(self.attack_surface.all_vulnerabilities)+1:04d}",
                    title=finding.get("title", "Unknown Vulnerability"),
                    severity=severity,
                    description=finding.get("description", ""),
                    evidence=finding.get("evidence", ""),
                    cve_id=finding.get("cve_id", ""),
                    cwe_id=finding.get("cwe_id", ""),
                    cvss_score=finding.get("cvss_score", 0.0),
                    remediation=finding.get("remediation", ""),
                    discovered_by=tool_name,
                    affected_asset=finding.get("url", finding.get("target", ""))
                )
                
                # Check exploitability for SQLi/XSS
                if any(x in finding.get("title", "").lower() for x in ["sql injection", "xss", "rce", "command injection"]):
                    vuln.exploitable = True
                
                self.attack_surface.add_vulnerability(vuln)
                self.result.new_vulnerabilities += 1


class ExploitationPhase(PentestPhase):
    """
    Exploitation Phase
    
    Goals:
    - Validate vulnerabilities
    - Attempt exploitation
    - Gain initial access
    - Document proof of concept
    """
    
    PHASE_NAME = "exploitation"
    DESCRIPTION = "Vulnerability Validation & Exploitation"
    DEFAULT_TOOLS = [
        "HydraAttacker", "CrackmapexecScanner", "NetexecScanner",
        "SqlmapScanner", "EvilWinrmShell"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute exploitation phase"""
        self._show_phase_banner()
        
        # Generate attack plan
        console.print("\n[bold]Generating Attack Plan[/bold]")
        attack_plan = await self.ai_brain.generate_attack_plan(self.attack_surface)
        self.attack_surface.add_note(f"Attack Plan: {attack_plan.get('attack_plan', '')[:1000]}")
        
        # Get exploitable vulnerabilities
        exploitable = [v for v in self.attack_surface.all_vulnerabilities if v.exploitable]
        
        console.print(f"\n[bold]Found {len(exploitable)} potentially exploitable vulnerabilities[/bold]")
        
        # Attempt exploitation based on vulnerability type
        for vuln in exploitable[:5]:
            console.print(f"\n[cyan]Attempting: {vuln.title}[/cyan]")
            
            if "sql injection" in vuln.title.lower():
                # SQL injection exploitation
                if vuln.affected_asset:
                    await self._run_tool_with_analysis(
                        "SqlmapScanner", vuln.affected_asset,
                        dbs=True, batch=True
                    )
                    vuln.status = VulnStatus.CONFIRMED
            
            elif any(x in vuln.title.lower() for x in ["smb", "windows", "netbios"]):
                # Windows exploitation
                target = vuln.affected_asset.split("/")[0] if "/" in vuln.affected_asset else vuln.affected_asset
                
                # Try credential attacks if we have creds
                for cred in self.attack_surface.all_credentials:
                    if cred.password or cred.hash:
                        await self._run_tool_with_analysis(
                            "CrackmapexecScanner", target,
                            username=cred.username,
                            password=cred.password or None,
                            hash=cred.hash or None
                        )
        
        # Password attacks on discovered services
        console.print("\n[bold]Password Attack Attempts[/bold]")
        for asset in self.attack_surface.find_assets_with_service(ServiceType.SSH)[:3]:
            # Only attempt with valid usernames
            users = [c.username for c in self.attack_surface.all_credentials if c.username]
            if users:
                console.print(f"[dim]Attempting SSH brute force on {asset.name}[/dim]")
                # Note: In real scenario, would use proper wordlist
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process exploitation results"""
        if not result.is_success:
            return
        
        # Look for successful exploits
        for finding in result.findings:
            if finding.get("severity") == "critical":
                # Mark vulnerability as exploited
                for vuln in self.attack_surface.all_vulnerabilities:
                    if finding.get("title", "") in vuln.title:
                        vuln.status = VulnStatus.EXPLOITED
                        break
        
        # Extract credentials
        for cred in result.raw_data.get("credentials", []):
            self.attack_surface.add_credential(Credential(
                username=cred.get("username", ""),
                password=cred.get("password", ""),
                hash=cred.get("hash", ""),
                source=tool_name,
                valid=True
            ))


class PostExploitationPhase(PentestPhase):
    """
    Post-Exploitation Phase
    
    Goals:
    - Privilege escalation
    - Lateral movement
    - Data collection
    - Persistence (documentation only)
    """
    
    PHASE_NAME = "post_exploitation"
    DESCRIPTION = "Post-Exploitation & Impact Demonstration"
    DEFAULT_TOOLS = [
        "CrackmapexecScanner", "NetexecScanner", "EvilWinrmShell"
    ]
    
    async def execute(self) -> PhaseResult:
        """Execute post-exploitation phase"""
        self._show_phase_banner()
        
        # Find exploited assets
        exploited_vulns = [v for v in self.attack_surface.all_vulnerabilities if v.status == VulnStatus.EXPLOITED]
        
        if not exploited_vulns:
            console.print("[yellow]No exploited vulnerabilities - limited post-exploitation[/yellow]")
            self.result.success = True
            self.result.end_time = datetime.now()
            self.result.notes = "Skipped - no initial access achieved"
            return self.result
        
        console.print(f"\n[bold]Post-exploitation on {len(exploited_vulns)} compromised targets[/bold]")
        
        # Get AI recommendations for post-exploitation
        decisions = await self._make_ai_decision()
        
        for decision in decisions:
            if decision.decision_type == DecisionType.RUN_TOOL:
                console.print(f"[cyan]Running: {decision.tool}[/cyan]")
                console.print(f"[dim]Reason: {decision.reasoning}[/dim]")
                
                await self._run_tool_with_analysis(
                    decision.tool,
                    decision.target,
                    **decision.parameters
                )
            elif decision.decision_type == DecisionType.PIVOT:
                console.print(f"[yellow]Pivot opportunity: {decision.reasoning}[/yellow]")
                self.attack_surface.add_note(f"Pivot: {decision.reasoning}")
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self._display_phase_summary()
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        """Process post-exploitation results"""
        # Collect any additional credentials or access
        for cred in result.raw_data.get("credentials", []):
            self.attack_surface.add_credential(Credential(
                username=cred.get("username", ""),
                password=cred.get("password", ""),
                hash=cred.get("hash", ""),
                source=f"post_exploitation_{tool_name}",
                valid=True
            ))


class ReportingPhase(PentestPhase):
    """
    Reporting Phase
    
    Goals:
    - Compile all findings
    - Generate comprehensive report
    - Provide remediation guidance
    - Executive summary
    """
    
    PHASE_NAME = "reporting"
    DESCRIPTION = "Report Generation & Documentation"
    DEFAULT_TOOLS = []
    
    async def execute(self) -> PhaseResult:
        """Execute reporting phase"""
        self._show_phase_banner()
        
        from ..reports.generator import ReportGenerator, PentestReport, Finding
        
        console.print("\n[bold]Generating Comprehensive Report[/bold]")
        
        # Convert attack surface to report findings
        findings = []
        for vuln in self.attack_surface.all_vulnerabilities:
            findings.append(Finding(
                id=vuln.id,
                title=vuln.title,
                severity=vuln.severity.value,
                category=vuln.discovered_by,
                description=vuln.description,
                impact=self._get_impact(vuln.severity),
                remediation=vuln.remediation,
                evidence=vuln.evidence,
                url=vuln.affected_asset,
                cwe_id=vuln.cwe_id,
                cvss_score=vuln.cvss_score
            ))
        
        # Create report
        report = PentestReport(
            title=f"Penetration Test Report - {self.attack_surface.primary_target}",
            target=self.attack_surface.primary_target,
            findings=findings,
            scope=", ".join(self.attack_surface.domains),
            network_findings={"assets": len(self.attack_surface.assets)},
        )
        
        # Generate with AI enhancement
        generator = ReportGenerator()
        report_path = await generator.generate(report, format="html", use_ai=True)
        
        # Also generate JSON export
        json_path = self.tool_manager.output_dir / "attack_surface.json"
        with open(json_path, "w") as f:
            f.write(self.attack_surface.to_json())
        
        console.print(f"\n[green]âœ“ Report generated: {report_path}[/green]")
        console.print(f"[green]âœ“ Attack surface exported: {json_path}[/green]")
        
        self.result.success = True
        self.result.end_time = datetime.now()
        self.result.notes = f"Report: {report_path}"
        
        return self.result
    
    def _process_tool_result(self, tool_name: str, result: ToolResult) -> None:
        pass
    
    def _get_impact(self, severity: VulnSeverity) -> str:
        impacts = {
            VulnSeverity.CRITICAL: "Complete system compromise possible",
            VulnSeverity.HIGH: "Significant security risk",
            VulnSeverity.MEDIUM: "Moderate security concern",
            VulnSeverity.LOW: "Minor security issue",
            VulnSeverity.INFO: "Informational finding"
        }
        return impacts.get(severity, "Unknown impact")
